
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model brands
 * 
 */
export type brands = $Result.DefaultSelection<Prisma.$brandsPayload>
/**
 * Model categories
 * 
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model channels
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type channels = $Result.DefaultSelection<Prisma.$channelsPayload>
/**
 * Model coupon_sales
 * 
 */
export type coupon_sales = $Result.DefaultSelection<Prisma.$coupon_salesPayload>
/**
 * Model coupons
 * 
 */
export type coupons = $Result.DefaultSelection<Prisma.$couponsPayload>
/**
 * Model customers
 * 
 */
export type customers = $Result.DefaultSelection<Prisma.$customersPayload>
/**
 * Model delivery_addresses
 * 
 */
export type delivery_addresses = $Result.DefaultSelection<Prisma.$delivery_addressesPayload>
/**
 * Model delivery_sales
 * 
 */
export type delivery_sales = $Result.DefaultSelection<Prisma.$delivery_salesPayload>
/**
 * Model item_item_product_sales
 * 
 */
export type item_item_product_sales = $Result.DefaultSelection<Prisma.$item_item_product_salesPayload>
/**
 * Model item_product_sales
 * 
 */
export type item_product_sales = $Result.DefaultSelection<Prisma.$item_product_salesPayload>
/**
 * Model items
 * 
 */
export type items = $Result.DefaultSelection<Prisma.$itemsPayload>
/**
 * Model option_groups
 * 
 */
export type option_groups = $Result.DefaultSelection<Prisma.$option_groupsPayload>
/**
 * Model payment_types
 * 
 */
export type payment_types = $Result.DefaultSelection<Prisma.$payment_typesPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model product_sales
 * 
 */
export type product_sales = $Result.DefaultSelection<Prisma.$product_salesPayload>
/**
 * Model products
 * 
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model sales
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type sales = $Result.DefaultSelection<Prisma.$salesPayload>
/**
 * Model stores
 * 
 */
export type stores = $Result.DefaultSelection<Prisma.$storesPayload>
/**
 * Model sub_brands
 * 
 */
export type sub_brands = $Result.DefaultSelection<Prisma.$sub_brandsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Brands
 * const brands = await prisma.brands.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Brands
   * const brands = await prisma.brands.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.brands`: Exposes CRUD operations for the **brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brands.findMany()
    * ```
    */
  get brands(): Prisma.brandsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channels`: Exposes CRUD operations for the **channels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channels.findMany()
    * ```
    */
  get channels(): Prisma.channelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon_sales`: Exposes CRUD operations for the **coupon_sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupon_sales
    * const coupon_sales = await prisma.coupon_sales.findMany()
    * ```
    */
  get coupon_sales(): Prisma.coupon_salesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupons`: Exposes CRUD operations for the **coupons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupons.findMany()
    * ```
    */
  get coupons(): Prisma.couponsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.customersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delivery_addresses`: Exposes CRUD operations for the **delivery_addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delivery_addresses
    * const delivery_addresses = await prisma.delivery_addresses.findMany()
    * ```
    */
  get delivery_addresses(): Prisma.delivery_addressesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delivery_sales`: Exposes CRUD operations for the **delivery_sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delivery_sales
    * const delivery_sales = await prisma.delivery_sales.findMany()
    * ```
    */
  get delivery_sales(): Prisma.delivery_salesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item_item_product_sales`: Exposes CRUD operations for the **item_item_product_sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Item_item_product_sales
    * const item_item_product_sales = await prisma.item_item_product_sales.findMany()
    * ```
    */
  get item_item_product_sales(): Prisma.item_item_product_salesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item_product_sales`: Exposes CRUD operations for the **item_product_sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Item_product_sales
    * const item_product_sales = await prisma.item_product_sales.findMany()
    * ```
    */
  get item_product_sales(): Prisma.item_product_salesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.items`: Exposes CRUD operations for the **items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.items.findMany()
    * ```
    */
  get items(): Prisma.itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.option_groups`: Exposes CRUD operations for the **option_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Option_groups
    * const option_groups = await prisma.option_groups.findMany()
    * ```
    */
  get option_groups(): Prisma.option_groupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_types`: Exposes CRUD operations for the **payment_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_types
    * const payment_types = await prisma.payment_types.findMany()
    * ```
    */
  get payment_types(): Prisma.payment_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product_sales`: Exposes CRUD operations for the **product_sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_sales
    * const product_sales = await prisma.product_sales.findMany()
    * ```
    */
  get product_sales(): Prisma.product_salesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sales`: Exposes CRUD operations for the **sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sales.findMany()
    * ```
    */
  get sales(): Prisma.salesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stores`: Exposes CRUD operations for the **stores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.stores.findMany()
    * ```
    */
  get stores(): Prisma.storesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sub_brands`: Exposes CRUD operations for the **sub_brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sub_brands
    * const sub_brands = await prisma.sub_brands.findMany()
    * ```
    */
  get sub_brands(): Prisma.sub_brandsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    brands: 'brands',
    categories: 'categories',
    channels: 'channels',
    coupon_sales: 'coupon_sales',
    coupons: 'coupons',
    customers: 'customers',
    delivery_addresses: 'delivery_addresses',
    delivery_sales: 'delivery_sales',
    item_item_product_sales: 'item_item_product_sales',
    item_product_sales: 'item_product_sales',
    items: 'items',
    option_groups: 'option_groups',
    payment_types: 'payment_types',
    payments: 'payments',
    product_sales: 'product_sales',
    products: 'products',
    sales: 'sales',
    stores: 'stores',
    sub_brands: 'sub_brands'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "brands" | "categories" | "channels" | "coupon_sales" | "coupons" | "customers" | "delivery_addresses" | "delivery_sales" | "item_item_product_sales" | "item_product_sales" | "items" | "option_groups" | "payment_types" | "payments" | "product_sales" | "products" | "sales" | "stores" | "sub_brands"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      brands: {
        payload: Prisma.$brandsPayload<ExtArgs>
        fields: Prisma.brandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findFirst: {
            args: Prisma.brandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findMany: {
            args: Prisma.brandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          create: {
            args: Prisma.brandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          createMany: {
            args: Prisma.brandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.brandsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          delete: {
            args: Prisma.brandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          update: {
            args: Prisma.brandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          deleteMany: {
            args: Prisma.brandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.brandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.brandsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          upsert: {
            args: Prisma.brandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          aggregate: {
            args: Prisma.BrandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrands>
          }
          groupBy: {
            args: Prisma.brandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandsGroupByOutputType>[]
          }
          count: {
            args: Prisma.brandsCountArgs<ExtArgs>
            result: $Utils.Optional<BrandsCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      channels: {
        payload: Prisma.$channelsPayload<ExtArgs>
        fields: Prisma.channelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.channelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.channelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>
          }
          findFirst: {
            args: Prisma.channelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.channelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>
          }
          findMany: {
            args: Prisma.channelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>[]
          }
          create: {
            args: Prisma.channelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>
          }
          createMany: {
            args: Prisma.channelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.channelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>[]
          }
          delete: {
            args: Prisma.channelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>
          }
          update: {
            args: Prisma.channelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>
          }
          deleteMany: {
            args: Prisma.channelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.channelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.channelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>[]
          }
          upsert: {
            args: Prisma.channelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelsPayload>
          }
          aggregate: {
            args: Prisma.ChannelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannels>
          }
          groupBy: {
            args: Prisma.channelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.channelsCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelsCountAggregateOutputType> | number
          }
        }
      }
      coupon_sales: {
        payload: Prisma.$coupon_salesPayload<ExtArgs>
        fields: Prisma.coupon_salesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coupon_salesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coupon_salesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>
          }
          findFirst: {
            args: Prisma.coupon_salesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coupon_salesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>
          }
          findMany: {
            args: Prisma.coupon_salesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>[]
          }
          create: {
            args: Prisma.coupon_salesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>
          }
          createMany: {
            args: Prisma.coupon_salesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.coupon_salesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>[]
          }
          delete: {
            args: Prisma.coupon_salesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>
          }
          update: {
            args: Prisma.coupon_salesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>
          }
          deleteMany: {
            args: Prisma.coupon_salesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coupon_salesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.coupon_salesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>[]
          }
          upsert: {
            args: Prisma.coupon_salesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coupon_salesPayload>
          }
          aggregate: {
            args: Prisma.Coupon_salesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon_sales>
          }
          groupBy: {
            args: Prisma.coupon_salesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Coupon_salesGroupByOutputType>[]
          }
          count: {
            args: Prisma.coupon_salesCountArgs<ExtArgs>
            result: $Utils.Optional<Coupon_salesCountAggregateOutputType> | number
          }
        }
      }
      coupons: {
        payload: Prisma.$couponsPayload<ExtArgs>
        fields: Prisma.couponsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.couponsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.couponsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          findFirst: {
            args: Prisma.couponsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.couponsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          findMany: {
            args: Prisma.couponsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>[]
          }
          create: {
            args: Prisma.couponsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          createMany: {
            args: Prisma.couponsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.couponsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>[]
          }
          delete: {
            args: Prisma.couponsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          update: {
            args: Prisma.couponsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          deleteMany: {
            args: Prisma.couponsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.couponsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.couponsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>[]
          }
          upsert: {
            args: Prisma.couponsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          aggregate: {
            args: Prisma.CouponsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupons>
          }
          groupBy: {
            args: Prisma.couponsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponsGroupByOutputType>[]
          }
          count: {
            args: Prisma.couponsCountArgs<ExtArgs>
            result: $Utils.Optional<CouponsCountAggregateOutputType> | number
          }
        }
      }
      customers: {
        payload: Prisma.$customersPayload<ExtArgs>
        fields: Prisma.customersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findFirst: {
            args: Prisma.customersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findMany: {
            args: Prisma.customersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          create: {
            args: Prisma.customersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          createMany: {
            args: Prisma.customersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          delete: {
            args: Prisma.customersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          update: {
            args: Prisma.customersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          deleteMany: {
            args: Prisma.customersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          upsert: {
            args: Prisma.customersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.customersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.customersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      delivery_addresses: {
        payload: Prisma.$delivery_addressesPayload<ExtArgs>
        fields: Prisma.delivery_addressesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.delivery_addressesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.delivery_addressesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>
          }
          findFirst: {
            args: Prisma.delivery_addressesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.delivery_addressesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>
          }
          findMany: {
            args: Prisma.delivery_addressesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>[]
          }
          create: {
            args: Prisma.delivery_addressesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>
          }
          createMany: {
            args: Prisma.delivery_addressesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.delivery_addressesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>[]
          }
          delete: {
            args: Prisma.delivery_addressesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>
          }
          update: {
            args: Prisma.delivery_addressesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>
          }
          deleteMany: {
            args: Prisma.delivery_addressesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.delivery_addressesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.delivery_addressesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>[]
          }
          upsert: {
            args: Prisma.delivery_addressesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_addressesPayload>
          }
          aggregate: {
            args: Prisma.Delivery_addressesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelivery_addresses>
          }
          groupBy: {
            args: Prisma.delivery_addressesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Delivery_addressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.delivery_addressesCountArgs<ExtArgs>
            result: $Utils.Optional<Delivery_addressesCountAggregateOutputType> | number
          }
        }
      }
      delivery_sales: {
        payload: Prisma.$delivery_salesPayload<ExtArgs>
        fields: Prisma.delivery_salesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.delivery_salesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.delivery_salesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>
          }
          findFirst: {
            args: Prisma.delivery_salesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.delivery_salesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>
          }
          findMany: {
            args: Prisma.delivery_salesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>[]
          }
          create: {
            args: Prisma.delivery_salesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>
          }
          createMany: {
            args: Prisma.delivery_salesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.delivery_salesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>[]
          }
          delete: {
            args: Prisma.delivery_salesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>
          }
          update: {
            args: Prisma.delivery_salesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>
          }
          deleteMany: {
            args: Prisma.delivery_salesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.delivery_salesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.delivery_salesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>[]
          }
          upsert: {
            args: Prisma.delivery_salesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delivery_salesPayload>
          }
          aggregate: {
            args: Prisma.Delivery_salesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelivery_sales>
          }
          groupBy: {
            args: Prisma.delivery_salesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Delivery_salesGroupByOutputType>[]
          }
          count: {
            args: Prisma.delivery_salesCountArgs<ExtArgs>
            result: $Utils.Optional<Delivery_salesCountAggregateOutputType> | number
          }
        }
      }
      item_item_product_sales: {
        payload: Prisma.$item_item_product_salesPayload<ExtArgs>
        fields: Prisma.item_item_product_salesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.item_item_product_salesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.item_item_product_salesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>
          }
          findFirst: {
            args: Prisma.item_item_product_salesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.item_item_product_salesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>
          }
          findMany: {
            args: Prisma.item_item_product_salesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>[]
          }
          create: {
            args: Prisma.item_item_product_salesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>
          }
          createMany: {
            args: Prisma.item_item_product_salesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.item_item_product_salesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>[]
          }
          delete: {
            args: Prisma.item_item_product_salesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>
          }
          update: {
            args: Prisma.item_item_product_salesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>
          }
          deleteMany: {
            args: Prisma.item_item_product_salesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.item_item_product_salesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.item_item_product_salesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>[]
          }
          upsert: {
            args: Prisma.item_item_product_salesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_item_product_salesPayload>
          }
          aggregate: {
            args: Prisma.Item_item_product_salesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem_item_product_sales>
          }
          groupBy: {
            args: Prisma.item_item_product_salesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Item_item_product_salesGroupByOutputType>[]
          }
          count: {
            args: Prisma.item_item_product_salesCountArgs<ExtArgs>
            result: $Utils.Optional<Item_item_product_salesCountAggregateOutputType> | number
          }
        }
      }
      item_product_sales: {
        payload: Prisma.$item_product_salesPayload<ExtArgs>
        fields: Prisma.item_product_salesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.item_product_salesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.item_product_salesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>
          }
          findFirst: {
            args: Prisma.item_product_salesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.item_product_salesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>
          }
          findMany: {
            args: Prisma.item_product_salesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>[]
          }
          create: {
            args: Prisma.item_product_salesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>
          }
          createMany: {
            args: Prisma.item_product_salesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.item_product_salesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>[]
          }
          delete: {
            args: Prisma.item_product_salesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>
          }
          update: {
            args: Prisma.item_product_salesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>
          }
          deleteMany: {
            args: Prisma.item_product_salesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.item_product_salesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.item_product_salesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>[]
          }
          upsert: {
            args: Prisma.item_product_salesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_product_salesPayload>
          }
          aggregate: {
            args: Prisma.Item_product_salesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem_product_sales>
          }
          groupBy: {
            args: Prisma.item_product_salesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Item_product_salesGroupByOutputType>[]
          }
          count: {
            args: Prisma.item_product_salesCountArgs<ExtArgs>
            result: $Utils.Optional<Item_product_salesCountAggregateOutputType> | number
          }
        }
      }
      items: {
        payload: Prisma.$itemsPayload<ExtArgs>
        fields: Prisma.itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findFirst: {
            args: Prisma.itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findMany: {
            args: Prisma.itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>[]
          }
          create: {
            args: Prisma.itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          createMany: {
            args: Prisma.itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>[]
          }
          delete: {
            args: Prisma.itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          update: {
            args: Prisma.itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          deleteMany: {
            args: Prisma.itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>[]
          }
          upsert: {
            args: Prisma.itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          aggregate: {
            args: Prisma.ItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItems>
          }
          groupBy: {
            args: Prisma.itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemsCountArgs<ExtArgs>
            result: $Utils.Optional<ItemsCountAggregateOutputType> | number
          }
        }
      }
      option_groups: {
        payload: Prisma.$option_groupsPayload<ExtArgs>
        fields: Prisma.option_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.option_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.option_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>
          }
          findFirst: {
            args: Prisma.option_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.option_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>
          }
          findMany: {
            args: Prisma.option_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>[]
          }
          create: {
            args: Prisma.option_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>
          }
          createMany: {
            args: Prisma.option_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.option_groupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>[]
          }
          delete: {
            args: Prisma.option_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>
          }
          update: {
            args: Prisma.option_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>
          }
          deleteMany: {
            args: Prisma.option_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.option_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.option_groupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>[]
          }
          upsert: {
            args: Prisma.option_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_groupsPayload>
          }
          aggregate: {
            args: Prisma.Option_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOption_groups>
          }
          groupBy: {
            args: Prisma.option_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Option_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.option_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Option_groupsCountAggregateOutputType> | number
          }
        }
      }
      payment_types: {
        payload: Prisma.$payment_typesPayload<ExtArgs>
        fields: Prisma.payment_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          findFirst: {
            args: Prisma.payment_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          findMany: {
            args: Prisma.payment_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>[]
          }
          create: {
            args: Prisma.payment_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          createMany: {
            args: Prisma.payment_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>[]
          }
          delete: {
            args: Prisma.payment_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          update: {
            args: Prisma.payment_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          deleteMany: {
            args: Prisma.payment_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_typesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>[]
          }
          upsert: {
            args: Prisma.payment_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          aggregate: {
            args: Prisma.Payment_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_types>
          }
          groupBy: {
            args: Prisma.payment_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_typesCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      product_sales: {
        payload: Prisma.$product_salesPayload<ExtArgs>
        fields: Prisma.product_salesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_salesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_salesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>
          }
          findFirst: {
            args: Prisma.product_salesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_salesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>
          }
          findMany: {
            args: Prisma.product_salesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>[]
          }
          create: {
            args: Prisma.product_salesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>
          }
          createMany: {
            args: Prisma.product_salesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.product_salesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>[]
          }
          delete: {
            args: Prisma.product_salesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>
          }
          update: {
            args: Prisma.product_salesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>
          }
          deleteMany: {
            args: Prisma.product_salesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.product_salesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.product_salesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>[]
          }
          upsert: {
            args: Prisma.product_salesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_salesPayload>
          }
          aggregate: {
            args: Prisma.Product_salesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct_sales>
          }
          groupBy: {
            args: Prisma.product_salesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Product_salesGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_salesCountArgs<ExtArgs>
            result: $Utils.Optional<Product_salesCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      sales: {
        payload: Prisma.$salesPayload<ExtArgs>
        fields: Prisma.salesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.salesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.salesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          findFirst: {
            args: Prisma.salesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.salesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          findMany: {
            args: Prisma.salesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>[]
          }
          create: {
            args: Prisma.salesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          createMany: {
            args: Prisma.salesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.salesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>[]
          }
          delete: {
            args: Prisma.salesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          update: {
            args: Prisma.salesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          deleteMany: {
            args: Prisma.salesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.salesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.salesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>[]
          }
          upsert: {
            args: Prisma.salesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salesPayload>
          }
          aggregate: {
            args: Prisma.SalesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSales>
          }
          groupBy: {
            args: Prisma.salesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesGroupByOutputType>[]
          }
          count: {
            args: Prisma.salesCountArgs<ExtArgs>
            result: $Utils.Optional<SalesCountAggregateOutputType> | number
          }
        }
      }
      stores: {
        payload: Prisma.$storesPayload<ExtArgs>
        fields: Prisma.storesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.storesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.storesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          findFirst: {
            args: Prisma.storesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.storesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          findMany: {
            args: Prisma.storesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>[]
          }
          create: {
            args: Prisma.storesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          createMany: {
            args: Prisma.storesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.storesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>[]
          }
          delete: {
            args: Prisma.storesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          update: {
            args: Prisma.storesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          deleteMany: {
            args: Prisma.storesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.storesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.storesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>[]
          }
          upsert: {
            args: Prisma.storesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          aggregate: {
            args: Prisma.StoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStores>
          }
          groupBy: {
            args: Prisma.storesGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.storesCountArgs<ExtArgs>
            result: $Utils.Optional<StoresCountAggregateOutputType> | number
          }
        }
      }
      sub_brands: {
        payload: Prisma.$sub_brandsPayload<ExtArgs>
        fields: Prisma.sub_brandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sub_brandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sub_brandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>
          }
          findFirst: {
            args: Prisma.sub_brandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sub_brandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>
          }
          findMany: {
            args: Prisma.sub_brandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>[]
          }
          create: {
            args: Prisma.sub_brandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>
          }
          createMany: {
            args: Prisma.sub_brandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sub_brandsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>[]
          }
          delete: {
            args: Prisma.sub_brandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>
          }
          update: {
            args: Prisma.sub_brandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>
          }
          deleteMany: {
            args: Prisma.sub_brandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sub_brandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sub_brandsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>[]
          }
          upsert: {
            args: Prisma.sub_brandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_brandsPayload>
          }
          aggregate: {
            args: Prisma.Sub_brandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSub_brands>
          }
          groupBy: {
            args: Prisma.sub_brandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sub_brandsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sub_brandsCountArgs<ExtArgs>
            result: $Utils.Optional<Sub_brandsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    brands?: brandsOmit
    categories?: categoriesOmit
    channels?: channelsOmit
    coupon_sales?: coupon_salesOmit
    coupons?: couponsOmit
    customers?: customersOmit
    delivery_addresses?: delivery_addressesOmit
    delivery_sales?: delivery_salesOmit
    item_item_product_sales?: item_item_product_salesOmit
    item_product_sales?: item_product_salesOmit
    items?: itemsOmit
    option_groups?: option_groupsOmit
    payment_types?: payment_typesOmit
    payments?: paymentsOmit
    product_sales?: product_salesOmit
    products?: productsOmit
    sales?: salesOmit
    stores?: storesOmit
    sub_brands?: sub_brandsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BrandsCountOutputType
   */

  export type BrandsCountOutputType = {
    categories: number
    channels: number
    coupons: number
    items: number
    option_groups: number
    payment_types: number
    products: number
    stores: number
    sub_brands: number
  }

  export type BrandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | BrandsCountOutputTypeCountCategoriesArgs
    channels?: boolean | BrandsCountOutputTypeCountChannelsArgs
    coupons?: boolean | BrandsCountOutputTypeCountCouponsArgs
    items?: boolean | BrandsCountOutputTypeCountItemsArgs
    option_groups?: boolean | BrandsCountOutputTypeCountOption_groupsArgs
    payment_types?: boolean | BrandsCountOutputTypeCountPayment_typesArgs
    products?: boolean | BrandsCountOutputTypeCountProductsArgs
    stores?: boolean | BrandsCountOutputTypeCountStoresArgs
    sub_brands?: boolean | BrandsCountOutputTypeCountSub_brandsArgs
  }

  // Custom InputTypes
  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandsCountOutputType
     */
    select?: BrandsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountOption_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: option_groupsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountPayment_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_typesWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storesWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountSub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sub_brandsWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    items: number
    option_groups: number
    products: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CategoriesCountOutputTypeCountItemsArgs
    option_groups?: boolean | CategoriesCountOutputTypeCountOption_groupsArgs
    products?: boolean | CategoriesCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountOption_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: option_groupsWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }


  /**
   * Count Type ChannelsCountOutputType
   */

  export type ChannelsCountOutputType = {
    sales: number
  }

  export type ChannelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | ChannelsCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * ChannelsCountOutputType without action
   */
  export type ChannelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelsCountOutputType
     */
    select?: ChannelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelsCountOutputType without action
   */
  export type ChannelsCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salesWhereInput
  }


  /**
   * Count Type CouponsCountOutputType
   */

  export type CouponsCountOutputType = {
    coupon_sales: number
  }

  export type CouponsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon_sales?: boolean | CouponsCountOutputTypeCountCoupon_salesArgs
  }

  // Custom InputTypes
  /**
   * CouponsCountOutputType without action
   */
  export type CouponsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponsCountOutputType
     */
    select?: CouponsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponsCountOutputType without action
   */
  export type CouponsCountOutputTypeCountCoupon_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coupon_salesWhereInput
  }


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    sales: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CustomersCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salesWhereInput
  }


  /**
   * Count Type Delivery_salesCountOutputType
   */

  export type Delivery_salesCountOutputType = {
    delivery_addresses: number
  }

  export type Delivery_salesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery_addresses?: boolean | Delivery_salesCountOutputTypeCountDelivery_addressesArgs
  }

  // Custom InputTypes
  /**
   * Delivery_salesCountOutputType without action
   */
  export type Delivery_salesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery_salesCountOutputType
     */
    select?: Delivery_salesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Delivery_salesCountOutputType without action
   */
  export type Delivery_salesCountOutputTypeCountDelivery_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: delivery_addressesWhereInput
  }


  /**
   * Count Type Item_product_salesCountOutputType
   */

  export type Item_product_salesCountOutputType = {
    item_item_product_sales: number
  }

  export type Item_product_salesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_item_product_sales?: boolean | Item_product_salesCountOutputTypeCountItem_item_product_salesArgs
  }

  // Custom InputTypes
  /**
   * Item_product_salesCountOutputType without action
   */
  export type Item_product_salesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item_product_salesCountOutputType
     */
    select?: Item_product_salesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Item_product_salesCountOutputType without action
   */
  export type Item_product_salesCountOutputTypeCountItem_item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_item_product_salesWhereInput
  }


  /**
   * Count Type ItemsCountOutputType
   */

  export type ItemsCountOutputType = {
    item_item_product_sales: number
    item_product_sales: number
  }

  export type ItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_item_product_sales?: boolean | ItemsCountOutputTypeCountItem_item_product_salesArgs
    item_product_sales?: boolean | ItemsCountOutputTypeCountItem_product_salesArgs
  }

  // Custom InputTypes
  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsCountOutputType
     */
    select?: ItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeCountItem_item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_item_product_salesWhereInput
  }

  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeCountItem_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_product_salesWhereInput
  }


  /**
   * Count Type Option_groupsCountOutputType
   */

  export type Option_groupsCountOutputType = {
    item_item_product_sales: number
    item_product_sales: number
  }

  export type Option_groupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_item_product_sales?: boolean | Option_groupsCountOutputTypeCountItem_item_product_salesArgs
    item_product_sales?: boolean | Option_groupsCountOutputTypeCountItem_product_salesArgs
  }

  // Custom InputTypes
  /**
   * Option_groupsCountOutputType without action
   */
  export type Option_groupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option_groupsCountOutputType
     */
    select?: Option_groupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Option_groupsCountOutputType without action
   */
  export type Option_groupsCountOutputTypeCountItem_item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_item_product_salesWhereInput
  }

  /**
   * Option_groupsCountOutputType without action
   */
  export type Option_groupsCountOutputTypeCountItem_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_product_salesWhereInput
  }


  /**
   * Count Type Payment_typesCountOutputType
   */

  export type Payment_typesCountOutputType = {
    payments: number
  }

  export type Payment_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Payment_typesCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * Payment_typesCountOutputType without action
   */
  export type Payment_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_typesCountOutputType
     */
    select?: Payment_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Payment_typesCountOutputType without action
   */
  export type Payment_typesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type Product_salesCountOutputType
   */

  export type Product_salesCountOutputType = {
    item_product_sales: number
  }

  export type Product_salesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_product_sales?: boolean | Product_salesCountOutputTypeCountItem_product_salesArgs
  }

  // Custom InputTypes
  /**
   * Product_salesCountOutputType without action
   */
  export type Product_salesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product_salesCountOutputType
     */
    select?: Product_salesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Product_salesCountOutputType without action
   */
  export type Product_salesCountOutputTypeCountItem_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_product_salesWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    product_sales: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_sales?: boolean | ProductsCountOutputTypeCountProduct_salesArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountProduct_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_salesWhereInput
  }


  /**
   * Count Type SalesCountOutputType
   */

  export type SalesCountOutputType = {
    coupon_sales: number
    delivery_addresses: number
    delivery_sales: number
    payments: number
    product_sales: number
  }

  export type SalesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon_sales?: boolean | SalesCountOutputTypeCountCoupon_salesArgs
    delivery_addresses?: boolean | SalesCountOutputTypeCountDelivery_addressesArgs
    delivery_sales?: boolean | SalesCountOutputTypeCountDelivery_salesArgs
    payments?: boolean | SalesCountOutputTypeCountPaymentsArgs
    product_sales?: boolean | SalesCountOutputTypeCountProduct_salesArgs
  }

  // Custom InputTypes
  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesCountOutputType
     */
    select?: SalesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeCountCoupon_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coupon_salesWhereInput
  }

  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeCountDelivery_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: delivery_addressesWhereInput
  }

  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeCountDelivery_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: delivery_salesWhereInput
  }

  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeCountProduct_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_salesWhereInput
  }


  /**
   * Count Type StoresCountOutputType
   */

  export type StoresCountOutputType = {
    customers: number
    sales: number
  }

  export type StoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | StoresCountOutputTypeCountCustomersArgs
    sales?: boolean | StoresCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoresCountOutputType
     */
    select?: StoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salesWhereInput
  }


  /**
   * Count Type Sub_brandsCountOutputType
   */

  export type Sub_brandsCountOutputType = {
    categories: number
    customers: number
    items: number
    option_groups: number
    products: number
    sales: number
    stores: number
  }

  export type Sub_brandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Sub_brandsCountOutputTypeCountCategoriesArgs
    customers?: boolean | Sub_brandsCountOutputTypeCountCustomersArgs
    items?: boolean | Sub_brandsCountOutputTypeCountItemsArgs
    option_groups?: boolean | Sub_brandsCountOutputTypeCountOption_groupsArgs
    products?: boolean | Sub_brandsCountOutputTypeCountProductsArgs
    sales?: boolean | Sub_brandsCountOutputTypeCountSalesArgs
    stores?: boolean | Sub_brandsCountOutputTypeCountStoresArgs
  }

  // Custom InputTypes
  /**
   * Sub_brandsCountOutputType without action
   */
  export type Sub_brandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_brandsCountOutputType
     */
    select?: Sub_brandsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Sub_brandsCountOutputType without action
   */
  export type Sub_brandsCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
  }

  /**
   * Sub_brandsCountOutputType without action
   */
  export type Sub_brandsCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
  }

  /**
   * Sub_brandsCountOutputType without action
   */
  export type Sub_brandsCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
  }

  /**
   * Sub_brandsCountOutputType without action
   */
  export type Sub_brandsCountOutputTypeCountOption_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: option_groupsWhereInput
  }

  /**
   * Sub_brandsCountOutputType without action
   */
  export type Sub_brandsCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }

  /**
   * Sub_brandsCountOutputType without action
   */
  export type Sub_brandsCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salesWhereInput
  }

  /**
   * Sub_brandsCountOutputType without action
   */
  export type Sub_brandsCountOutputTypeCountStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model brands
   */

  export type AggregateBrands = {
    _count: BrandsCountAggregateOutputType | null
    _avg: BrandsAvgAggregateOutputType | null
    _sum: BrandsSumAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  export type BrandsAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandsSumAggregateOutputType = {
    id: number | null
  }

  export type BrandsMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
  }

  export type BrandsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
  }

  export type BrandsCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    _all: number
  }


  export type BrandsAvgAggregateInputType = {
    id?: true
  }

  export type BrandsSumAggregateInputType = {
    id?: true
  }

  export type BrandsMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type BrandsMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type BrandsCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type BrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to aggregate.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brands
    **/
    _count?: true | BrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandsMaxAggregateInputType
  }

  export type GetBrandsAggregateType<T extends BrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrands[P]>
      : GetScalarType<T[P], AggregateBrands[P]>
  }




  export type brandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithAggregationInput | brandsOrderByWithAggregationInput[]
    by: BrandsScalarFieldEnum[] | BrandsScalarFieldEnum
    having?: brandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandsCountAggregateInputType | true
    _avg?: BrandsAvgAggregateInputType
    _sum?: BrandsSumAggregateInputType
    _min?: BrandsMinAggregateInputType
    _max?: BrandsMaxAggregateInputType
  }

  export type BrandsGroupByOutputType = {
    id: number
    name: string
    created_at: Date | null
    _count: BrandsCountAggregateOutputType | null
    _avg: BrandsAvgAggregateOutputType | null
    _sum: BrandsSumAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  type GetBrandsGroupByPayload<T extends brandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandsGroupByOutputType[P]>
            : GetScalarType<T[P], BrandsGroupByOutputType[P]>
        }
      >
    >


  export type brandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    categories?: boolean | brands$categoriesArgs<ExtArgs>
    channels?: boolean | brands$channelsArgs<ExtArgs>
    coupons?: boolean | brands$couponsArgs<ExtArgs>
    items?: boolean | brands$itemsArgs<ExtArgs>
    option_groups?: boolean | brands$option_groupsArgs<ExtArgs>
    payment_types?: boolean | brands$payment_typesArgs<ExtArgs>
    products?: boolean | brands$productsArgs<ExtArgs>
    stores?: boolean | brands$storesArgs<ExtArgs>
    sub_brands?: boolean | brands$sub_brandsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>

  export type brandsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["brands"]>

  export type brandsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["brands"]>

  export type brandsSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type brandsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at", ExtArgs["result"]["brands"]>
  export type brandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | brands$categoriesArgs<ExtArgs>
    channels?: boolean | brands$channelsArgs<ExtArgs>
    coupons?: boolean | brands$couponsArgs<ExtArgs>
    items?: boolean | brands$itemsArgs<ExtArgs>
    option_groups?: boolean | brands$option_groupsArgs<ExtArgs>
    payment_types?: boolean | brands$payment_typesArgs<ExtArgs>
    products?: boolean | brands$productsArgs<ExtArgs>
    stores?: boolean | brands$storesArgs<ExtArgs>
    sub_brands?: boolean | brands$sub_brandsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type brandsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type brandsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $brandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brands"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs>[]
      channels: Prisma.$channelsPayload<ExtArgs>[]
      coupons: Prisma.$couponsPayload<ExtArgs>[]
      items: Prisma.$itemsPayload<ExtArgs>[]
      option_groups: Prisma.$option_groupsPayload<ExtArgs>[]
      payment_types: Prisma.$payment_typesPayload<ExtArgs>[]
      products: Prisma.$productsPayload<ExtArgs>[]
      stores: Prisma.$storesPayload<ExtArgs>[]
      sub_brands: Prisma.$sub_brandsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date | null
    }, ExtArgs["result"]["brands"]>
    composites: {}
  }

  type brandsGetPayload<S extends boolean | null | undefined | brandsDefaultArgs> = $Result.GetResult<Prisma.$brandsPayload, S>

  type brandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<brandsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandsCountAggregateInputType | true
    }

  export interface brandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brands'], meta: { name: 'brands' } }
    /**
     * Find zero or one Brands that matches the filter.
     * @param {brandsFindUniqueArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends brandsFindUniqueArgs>(args: SelectSubset<T, brandsFindUniqueArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brands that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {brandsFindUniqueOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends brandsFindUniqueOrThrowArgs>(args: SelectSubset<T, brandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends brandsFindFirstArgs>(args?: SelectSubset<T, brandsFindFirstArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends brandsFindFirstOrThrowArgs>(args?: SelectSubset<T, brandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brands.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandsWithIdOnly = await prisma.brands.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends brandsFindManyArgs>(args?: SelectSubset<T, brandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brands.
     * @param {brandsCreateArgs} args - Arguments to create a Brands.
     * @example
     * // Create one Brands
     * const Brands = await prisma.brands.create({
     *   data: {
     *     // ... data to create a Brands
     *   }
     * })
     * 
     */
    create<T extends brandsCreateArgs>(args: SelectSubset<T, brandsCreateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {brandsCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends brandsCreateManyArgs>(args?: SelectSubset<T, brandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {brandsCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandsWithIdOnly = await prisma.brands.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends brandsCreateManyAndReturnArgs>(args?: SelectSubset<T, brandsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brands.
     * @param {brandsDeleteArgs} args - Arguments to delete one Brands.
     * @example
     * // Delete one Brands
     * const Brands = await prisma.brands.delete({
     *   where: {
     *     // ... filter to delete one Brands
     *   }
     * })
     * 
     */
    delete<T extends brandsDeleteArgs>(args: SelectSubset<T, brandsDeleteArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brands.
     * @param {brandsUpdateArgs} args - Arguments to update one Brands.
     * @example
     * // Update one Brands
     * const brands = await prisma.brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends brandsUpdateArgs>(args: SelectSubset<T, brandsUpdateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {brandsDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends brandsDeleteManyArgs>(args?: SelectSubset<T, brandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends brandsUpdateManyArgs>(args: SelectSubset<T, brandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {brandsUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandsWithIdOnly = await prisma.brands.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends brandsUpdateManyAndReturnArgs>(args: SelectSubset<T, brandsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brands.
     * @param {brandsUpsertArgs} args - Arguments to update or create a Brands.
     * @example
     * // Update or create a Brands
     * const brands = await prisma.brands.upsert({
     *   create: {
     *     // ... data to create a Brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brands we want to update
     *   }
     * })
     */
    upsert<T extends brandsUpsertArgs>(args: SelectSubset<T, brandsUpsertArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brands.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends brandsCountArgs>(
      args?: Subset<T, brandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandsAggregateArgs>(args: Subset<T, BrandsAggregateArgs>): Prisma.PrismaPromise<GetBrandsAggregateType<T>>

    /**
     * Group by Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brandsGroupByArgs['orderBy'] }
        : { orderBy?: brandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brands model
   */
  readonly fields: brandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends brands$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, brands$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    channels<T extends brands$channelsArgs<ExtArgs> = {}>(args?: Subset<T, brands$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupons<T extends brands$couponsArgs<ExtArgs> = {}>(args?: Subset<T, brands$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends brands$itemsArgs<ExtArgs> = {}>(args?: Subset<T, brands$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    option_groups<T extends brands$option_groupsArgs<ExtArgs> = {}>(args?: Subset<T, brands$option_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_types<T extends brands$payment_typesArgs<ExtArgs> = {}>(args?: Subset<T, brands$payment_typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends brands$productsArgs<ExtArgs> = {}>(args?: Subset<T, brands$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stores<T extends brands$storesArgs<ExtArgs> = {}>(args?: Subset<T, brands$storesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sub_brands<T extends brands$sub_brandsArgs<ExtArgs> = {}>(args?: Subset<T, brands$sub_brandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the brands model
   */
  interface brandsFieldRefs {
    readonly id: FieldRef<"brands", 'Int'>
    readonly name: FieldRef<"brands", 'String'>
    readonly created_at: FieldRef<"brands", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * brands findUnique
   */
  export type brandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findUniqueOrThrow
   */
  export type brandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findFirst
   */
  export type brandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findFirstOrThrow
   */
  export type brandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findMany
   */
  export type brandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands create
   */
  export type brandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to create a brands.
     */
    data: XOR<brandsCreateInput, brandsUncheckedCreateInput>
  }

  /**
   * brands createMany
   */
  export type brandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brands.
     */
    data: brandsCreateManyInput | brandsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * brands createManyAndReturn
   */
  export type brandsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * The data used to create many brands.
     */
    data: brandsCreateManyInput | brandsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * brands update
   */
  export type brandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to update a brands.
     */
    data: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
    /**
     * Choose, which brands to update.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands updateMany
   */
  export type brandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brands.
     */
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandsWhereInput
    /**
     * Limit how many brands to update.
     */
    limit?: number
  }

  /**
   * brands updateManyAndReturn
   */
  export type brandsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * The data used to update brands.
     */
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandsWhereInput
    /**
     * Limit how many brands to update.
     */
    limit?: number
  }

  /**
   * brands upsert
   */
  export type brandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The filter to search for the brands to update in case it exists.
     */
    where: brandsWhereUniqueInput
    /**
     * In case the brands found by the `where` argument doesn't exist, create a new brands with this data.
     */
    create: XOR<brandsCreateInput, brandsUncheckedCreateInput>
    /**
     * In case the brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
  }

  /**
   * brands delete
   */
  export type brandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter which brands to delete.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands deleteMany
   */
  export type brandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to delete
     */
    where?: brandsWhereInput
    /**
     * Limit how many brands to delete.
     */
    limit?: number
  }

  /**
   * brands.categories
   */
  export type brands$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    cursor?: categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * brands.channels
   */
  export type brands$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    where?: channelsWhereInput
    orderBy?: channelsOrderByWithRelationInput | channelsOrderByWithRelationInput[]
    cursor?: channelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelsScalarFieldEnum | ChannelsScalarFieldEnum[]
  }

  /**
   * brands.coupons
   */
  export type brands$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    where?: couponsWhereInput
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    cursor?: couponsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * brands.items
   */
  export type brands$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * brands.option_groups
   */
  export type brands$option_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    where?: option_groupsWhereInput
    orderBy?: option_groupsOrderByWithRelationInput | option_groupsOrderByWithRelationInput[]
    cursor?: option_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Option_groupsScalarFieldEnum | Option_groupsScalarFieldEnum[]
  }

  /**
   * brands.payment_types
   */
  export type brands$payment_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    where?: payment_typesWhereInput
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    cursor?: payment_typesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_typesScalarFieldEnum | Payment_typesScalarFieldEnum[]
  }

  /**
   * brands.products
   */
  export type brands$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * brands.stores
   */
  export type brands$storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    where?: storesWhereInput
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    cursor?: storesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * brands.sub_brands
   */
  export type brands$sub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    where?: sub_brandsWhereInput
    orderBy?: sub_brandsOrderByWithRelationInput | sub_brandsOrderByWithRelationInput[]
    cursor?: sub_brandsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sub_brandsScalarFieldEnum | Sub_brandsScalarFieldEnum[]
  }

  /**
   * brands without action
   */
  export type brandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    name: string | null
    type: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    name: string | null
    type: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    name: number
    type: number
    pos_uuid: number
    deleted_at: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    type?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    type?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    type?: true
    pos_uuid?: true
    deleted_at?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: number
    brand_id: number | null
    sub_brand_id: number | null
    name: string
    type: string | null
    pos_uuid: string | null
    deleted_at: Date | null
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    type?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | categories$brandsArgs<ExtArgs>
    sub_brands?: boolean | categories$sub_brandsArgs<ExtArgs>
    items?: boolean | categories$itemsArgs<ExtArgs>
    option_groups?: boolean | categories$option_groupsArgs<ExtArgs>
    products?: boolean | categories$productsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    type?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | categories$brandsArgs<ExtArgs>
    sub_brands?: boolean | categories$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    type?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | categories$brandsArgs<ExtArgs>
    sub_brands?: boolean | categories$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    type?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
  }

  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "name" | "type" | "pos_uuid" | "deleted_at", ExtArgs["result"]["categories"]>
  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | categories$brandsArgs<ExtArgs>
    sub_brands?: boolean | categories$sub_brandsArgs<ExtArgs>
    items?: boolean | categories$itemsArgs<ExtArgs>
    option_groups?: boolean | categories$option_groupsArgs<ExtArgs>
    products?: boolean | categories$productsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | categories$brandsArgs<ExtArgs>
    sub_brands?: boolean | categories$sub_brandsArgs<ExtArgs>
  }
  export type categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | categories$brandsArgs<ExtArgs>
    sub_brands?: boolean | categories$sub_brandsArgs<ExtArgs>
  }

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      brands: Prisma.$brandsPayload<ExtArgs> | null
      sub_brands: Prisma.$sub_brandsPayload<ExtArgs> | null
      items: Prisma.$itemsPayload<ExtArgs>[]
      option_groups: Prisma.$option_groupsPayload<ExtArgs>[]
      products: Prisma.$productsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      sub_brand_id: number | null
      name: string
      type: string | null
      pos_uuid: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brands<T extends categories$brandsArgs<ExtArgs> = {}>(args?: Subset<T, categories$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sub_brands<T extends categories$sub_brandsArgs<ExtArgs> = {}>(args?: Subset<T, categories$sub_brandsArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends categories$itemsArgs<ExtArgs> = {}>(args?: Subset<T, categories$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    option_groups<T extends categories$option_groupsArgs<ExtArgs> = {}>(args?: Subset<T, categories$option_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends categories$productsArgs<ExtArgs> = {}>(args?: Subset<T, categories$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'Int'>
    readonly brand_id: FieldRef<"categories", 'Int'>
    readonly sub_brand_id: FieldRef<"categories", 'Int'>
    readonly name: FieldRef<"categories", 'String'>
    readonly type: FieldRef<"categories", 'String'>
    readonly pos_uuid: FieldRef<"categories", 'String'>
    readonly deleted_at: FieldRef<"categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories createManyAndReturn
   */
  export type categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories updateManyAndReturn
   */
  export type categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * categories.brands
   */
  export type categories$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * categories.sub_brands
   */
  export type categories$sub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    where?: sub_brandsWhereInput
  }

  /**
   * categories.items
   */
  export type categories$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * categories.option_groups
   */
  export type categories$option_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    where?: option_groupsWhereInput
    orderBy?: option_groupsOrderByWithRelationInput | option_groupsOrderByWithRelationInput[]
    cursor?: option_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Option_groupsScalarFieldEnum | Option_groupsScalarFieldEnum[]
  }

  /**
   * categories.products
   */
  export type categories$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model channels
   */

  export type AggregateChannels = {
    _count: ChannelsCountAggregateOutputType | null
    _avg: ChannelsAvgAggregateOutputType | null
    _sum: ChannelsSumAggregateOutputType | null
    _min: ChannelsMinAggregateOutputType | null
    _max: ChannelsMaxAggregateOutputType | null
  }

  export type ChannelsAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type ChannelsSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type ChannelsMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    name: string | null
    description: string | null
    type: string | null
    created_at: Date | null
  }

  export type ChannelsMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    name: string | null
    description: string | null
    type: string | null
    created_at: Date | null
  }

  export type ChannelsCountAggregateOutputType = {
    id: number
    brand_id: number
    name: number
    description: number
    type: number
    created_at: number
    _all: number
  }


  export type ChannelsAvgAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type ChannelsSumAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type ChannelsMinAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
  }

  export type ChannelsMaxAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
  }

  export type ChannelsCountAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
    _all?: true
  }

  export type ChannelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channels to aggregate.
     */
    where?: channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelsOrderByWithRelationInput | channelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned channels
    **/
    _count?: true | ChannelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelsMaxAggregateInputType
  }

  export type GetChannelsAggregateType<T extends ChannelsAggregateArgs> = {
        [P in keyof T & keyof AggregateChannels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannels[P]>
      : GetScalarType<T[P], AggregateChannels[P]>
  }




  export type channelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelsWhereInput
    orderBy?: channelsOrderByWithAggregationInput | channelsOrderByWithAggregationInput[]
    by: ChannelsScalarFieldEnum[] | ChannelsScalarFieldEnum
    having?: channelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelsCountAggregateInputType | true
    _avg?: ChannelsAvgAggregateInputType
    _sum?: ChannelsSumAggregateInputType
    _min?: ChannelsMinAggregateInputType
    _max?: ChannelsMaxAggregateInputType
  }

  export type ChannelsGroupByOutputType = {
    id: number
    brand_id: number | null
    name: string
    description: string | null
    type: string | null
    created_at: Date | null
    _count: ChannelsCountAggregateOutputType | null
    _avg: ChannelsAvgAggregateOutputType | null
    _sum: ChannelsSumAggregateOutputType | null
    _min: ChannelsMinAggregateOutputType | null
    _max: ChannelsMaxAggregateOutputType | null
  }

  type GetChannelsGroupByPayload<T extends channelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelsGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelsGroupByOutputType[P]>
        }
      >
    >


  export type channelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    brands?: boolean | channels$brandsArgs<ExtArgs>
    sales?: boolean | channels$salesArgs<ExtArgs>
    _count?: boolean | ChannelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channels"]>

  export type channelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    brands?: boolean | channels$brandsArgs<ExtArgs>
  }, ExtArgs["result"]["channels"]>

  export type channelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    brands?: boolean | channels$brandsArgs<ExtArgs>
  }, ExtArgs["result"]["channels"]>

  export type channelsSelectScalar = {
    id?: boolean
    brand_id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
  }

  export type channelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "name" | "description" | "type" | "created_at", ExtArgs["result"]["channels"]>
  export type channelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | channels$brandsArgs<ExtArgs>
    sales?: boolean | channels$salesArgs<ExtArgs>
    _count?: boolean | ChannelsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type channelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | channels$brandsArgs<ExtArgs>
  }
  export type channelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | channels$brandsArgs<ExtArgs>
  }

  export type $channelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "channels"
    objects: {
      brands: Prisma.$brandsPayload<ExtArgs> | null
      sales: Prisma.$salesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      name: string
      description: string | null
      type: string | null
      created_at: Date | null
    }, ExtArgs["result"]["channels"]>
    composites: {}
  }

  type channelsGetPayload<S extends boolean | null | undefined | channelsDefaultArgs> = $Result.GetResult<Prisma.$channelsPayload, S>

  type channelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<channelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelsCountAggregateInputType | true
    }

  export interface channelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['channels'], meta: { name: 'channels' } }
    /**
     * Find zero or one Channels that matches the filter.
     * @param {channelsFindUniqueArgs} args - Arguments to find a Channels
     * @example
     * // Get one Channels
     * const channels = await prisma.channels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends channelsFindUniqueArgs>(args: SelectSubset<T, channelsFindUniqueArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Channels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {channelsFindUniqueOrThrowArgs} args - Arguments to find a Channels
     * @example
     * // Get one Channels
     * const channels = await prisma.channels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends channelsFindUniqueOrThrowArgs>(args: SelectSubset<T, channelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsFindFirstArgs} args - Arguments to find a Channels
     * @example
     * // Get one Channels
     * const channels = await prisma.channels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends channelsFindFirstArgs>(args?: SelectSubset<T, channelsFindFirstArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsFindFirstOrThrowArgs} args - Arguments to find a Channels
     * @example
     * // Get one Channels
     * const channels = await prisma.channels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends channelsFindFirstOrThrowArgs>(args?: SelectSubset<T, channelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channels.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelsWithIdOnly = await prisma.channels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends channelsFindManyArgs>(args?: SelectSubset<T, channelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Channels.
     * @param {channelsCreateArgs} args - Arguments to create a Channels.
     * @example
     * // Create one Channels
     * const Channels = await prisma.channels.create({
     *   data: {
     *     // ... data to create a Channels
     *   }
     * })
     * 
     */
    create<T extends channelsCreateArgs>(args: SelectSubset<T, channelsCreateArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Channels.
     * @param {channelsCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channels = await prisma.channels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends channelsCreateManyArgs>(args?: SelectSubset<T, channelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {channelsCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channels = await prisma.channels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelsWithIdOnly = await prisma.channels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends channelsCreateManyAndReturnArgs>(args?: SelectSubset<T, channelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Channels.
     * @param {channelsDeleteArgs} args - Arguments to delete one Channels.
     * @example
     * // Delete one Channels
     * const Channels = await prisma.channels.delete({
     *   where: {
     *     // ... filter to delete one Channels
     *   }
     * })
     * 
     */
    delete<T extends channelsDeleteArgs>(args: SelectSubset<T, channelsDeleteArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Channels.
     * @param {channelsUpdateArgs} args - Arguments to update one Channels.
     * @example
     * // Update one Channels
     * const channels = await prisma.channels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends channelsUpdateArgs>(args: SelectSubset<T, channelsUpdateArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Channels.
     * @param {channelsDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends channelsDeleteManyArgs>(args?: SelectSubset<T, channelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channels = await prisma.channels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends channelsUpdateManyArgs>(args: SelectSubset<T, channelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels and returns the data updated in the database.
     * @param {channelsUpdateManyAndReturnArgs} args - Arguments to update many Channels.
     * @example
     * // Update many Channels
     * const channels = await prisma.channels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Channels and only return the `id`
     * const channelsWithIdOnly = await prisma.channels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends channelsUpdateManyAndReturnArgs>(args: SelectSubset<T, channelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Channels.
     * @param {channelsUpsertArgs} args - Arguments to update or create a Channels.
     * @example
     * // Update or create a Channels
     * const channels = await prisma.channels.upsert({
     *   create: {
     *     // ... data to create a Channels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channels we want to update
     *   }
     * })
     */
    upsert<T extends channelsUpsertArgs>(args: SelectSubset<T, channelsUpsertArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channels.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends channelsCountArgs>(
      args?: Subset<T, channelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelsAggregateArgs>(args: Subset<T, ChannelsAggregateArgs>): Prisma.PrismaPromise<GetChannelsAggregateType<T>>

    /**
     * Group by Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends channelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: channelsGroupByArgs['orderBy'] }
        : { orderBy?: channelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, channelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the channels model
   */
  readonly fields: channelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for channels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__channelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brands<T extends channels$brandsArgs<ExtArgs> = {}>(args?: Subset<T, channels$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sales<T extends channels$salesArgs<ExtArgs> = {}>(args?: Subset<T, channels$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the channels model
   */
  interface channelsFieldRefs {
    readonly id: FieldRef<"channels", 'Int'>
    readonly brand_id: FieldRef<"channels", 'Int'>
    readonly name: FieldRef<"channels", 'String'>
    readonly description: FieldRef<"channels", 'String'>
    readonly type: FieldRef<"channels", 'String'>
    readonly created_at: FieldRef<"channels", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * channels findUnique
   */
  export type channelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * Filter, which channels to fetch.
     */
    where: channelsWhereUniqueInput
  }

  /**
   * channels findUniqueOrThrow
   */
  export type channelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * Filter, which channels to fetch.
     */
    where: channelsWhereUniqueInput
  }

  /**
   * channels findFirst
   */
  export type channelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * Filter, which channels to fetch.
     */
    where?: channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelsOrderByWithRelationInput | channelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     */
    cursor?: channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     */
    distinct?: ChannelsScalarFieldEnum | ChannelsScalarFieldEnum[]
  }

  /**
   * channels findFirstOrThrow
   */
  export type channelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * Filter, which channels to fetch.
     */
    where?: channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelsOrderByWithRelationInput | channelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     */
    cursor?: channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     */
    distinct?: ChannelsScalarFieldEnum | ChannelsScalarFieldEnum[]
  }

  /**
   * channels findMany
   */
  export type channelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * Filter, which channels to fetch.
     */
    where?: channelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelsOrderByWithRelationInput | channelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing channels.
     */
    cursor?: channelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    distinct?: ChannelsScalarFieldEnum | ChannelsScalarFieldEnum[]
  }

  /**
   * channels create
   */
  export type channelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * The data needed to create a channels.
     */
    data: XOR<channelsCreateInput, channelsUncheckedCreateInput>
  }

  /**
   * channels createMany
   */
  export type channelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many channels.
     */
    data: channelsCreateManyInput | channelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * channels createManyAndReturn
   */
  export type channelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * The data used to create many channels.
     */
    data: channelsCreateManyInput | channelsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * channels update
   */
  export type channelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * The data needed to update a channels.
     */
    data: XOR<channelsUpdateInput, channelsUncheckedUpdateInput>
    /**
     * Choose, which channels to update.
     */
    where: channelsWhereUniqueInput
  }

  /**
   * channels updateMany
   */
  export type channelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update channels.
     */
    data: XOR<channelsUpdateManyMutationInput, channelsUncheckedUpdateManyInput>
    /**
     * Filter which channels to update
     */
    where?: channelsWhereInput
    /**
     * Limit how many channels to update.
     */
    limit?: number
  }

  /**
   * channels updateManyAndReturn
   */
  export type channelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * The data used to update channels.
     */
    data: XOR<channelsUpdateManyMutationInput, channelsUncheckedUpdateManyInput>
    /**
     * Filter which channels to update
     */
    where?: channelsWhereInput
    /**
     * Limit how many channels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * channels upsert
   */
  export type channelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * The filter to search for the channels to update in case it exists.
     */
    where: channelsWhereUniqueInput
    /**
     * In case the channels found by the `where` argument doesn't exist, create a new channels with this data.
     */
    create: XOR<channelsCreateInput, channelsUncheckedCreateInput>
    /**
     * In case the channels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<channelsUpdateInput, channelsUncheckedUpdateInput>
  }

  /**
   * channels delete
   */
  export type channelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
    /**
     * Filter which channels to delete.
     */
    where: channelsWhereUniqueInput
  }

  /**
   * channels deleteMany
   */
  export type channelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channels to delete
     */
    where?: channelsWhereInput
    /**
     * Limit how many channels to delete.
     */
    limit?: number
  }

  /**
   * channels.brands
   */
  export type channels$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * channels.sales
   */
  export type channels$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    where?: salesWhereInput
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    cursor?: salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * channels without action
   */
  export type channelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channels
     */
    select?: channelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channels
     */
    omit?: channelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelsInclude<ExtArgs> | null
  }


  /**
   * Model coupon_sales
   */

  export type AggregateCoupon_sales = {
    _count: Coupon_salesCountAggregateOutputType | null
    _avg: Coupon_salesAvgAggregateOutputType | null
    _sum: Coupon_salesSumAggregateOutputType | null
    _min: Coupon_salesMinAggregateOutputType | null
    _max: Coupon_salesMaxAggregateOutputType | null
  }

  export type Coupon_salesAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    coupon_id: number | null
    value: number | null
  }

  export type Coupon_salesSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    coupon_id: number | null
    value: number | null
  }

  export type Coupon_salesMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    coupon_id: number | null
    value: number | null
    target: string | null
    sponsorship: string | null
  }

  export type Coupon_salesMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    coupon_id: number | null
    value: number | null
    target: string | null
    sponsorship: string | null
  }

  export type Coupon_salesCountAggregateOutputType = {
    id: number
    sale_id: number
    coupon_id: number
    value: number
    target: number
    sponsorship: number
    _all: number
  }


  export type Coupon_salesAvgAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
  }

  export type Coupon_salesSumAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
  }

  export type Coupon_salesMinAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
    target?: true
    sponsorship?: true
  }

  export type Coupon_salesMaxAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
    target?: true
    sponsorship?: true
  }

  export type Coupon_salesCountAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
    target?: true
    sponsorship?: true
    _all?: true
  }

  export type Coupon_salesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupon_sales to aggregate.
     */
    where?: coupon_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupon_sales to fetch.
     */
    orderBy?: coupon_salesOrderByWithRelationInput | coupon_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coupon_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupon_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupon_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coupon_sales
    **/
    _count?: true | Coupon_salesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Coupon_salesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Coupon_salesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Coupon_salesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Coupon_salesMaxAggregateInputType
  }

  export type GetCoupon_salesAggregateType<T extends Coupon_salesAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon_sales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon_sales[P]>
      : GetScalarType<T[P], AggregateCoupon_sales[P]>
  }




  export type coupon_salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coupon_salesWhereInput
    orderBy?: coupon_salesOrderByWithAggregationInput | coupon_salesOrderByWithAggregationInput[]
    by: Coupon_salesScalarFieldEnum[] | Coupon_salesScalarFieldEnum
    having?: coupon_salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Coupon_salesCountAggregateInputType | true
    _avg?: Coupon_salesAvgAggregateInputType
    _sum?: Coupon_salesSumAggregateInputType
    _min?: Coupon_salesMinAggregateInputType
    _max?: Coupon_salesMaxAggregateInputType
  }

  export type Coupon_salesGroupByOutputType = {
    id: number
    sale_id: number | null
    coupon_id: number | null
    value: number | null
    target: string | null
    sponsorship: string | null
    _count: Coupon_salesCountAggregateOutputType | null
    _avg: Coupon_salesAvgAggregateOutputType | null
    _sum: Coupon_salesSumAggregateOutputType | null
    _min: Coupon_salesMinAggregateOutputType | null
    _max: Coupon_salesMaxAggregateOutputType | null
  }

  type GetCoupon_salesGroupByPayload<T extends coupon_salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Coupon_salesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Coupon_salesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Coupon_salesGroupByOutputType[P]>
            : GetScalarType<T[P], Coupon_salesGroupByOutputType[P]>
        }
      >
    >


  export type coupon_salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    coupon_id?: boolean
    value?: boolean
    target?: boolean
    sponsorship?: boolean
    coupons?: boolean | coupon_sales$couponsArgs<ExtArgs>
    sales?: boolean | coupon_sales$salesArgs<ExtArgs>
  }, ExtArgs["result"]["coupon_sales"]>

  export type coupon_salesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    coupon_id?: boolean
    value?: boolean
    target?: boolean
    sponsorship?: boolean
    coupons?: boolean | coupon_sales$couponsArgs<ExtArgs>
    sales?: boolean | coupon_sales$salesArgs<ExtArgs>
  }, ExtArgs["result"]["coupon_sales"]>

  export type coupon_salesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    coupon_id?: boolean
    value?: boolean
    target?: boolean
    sponsorship?: boolean
    coupons?: boolean | coupon_sales$couponsArgs<ExtArgs>
    sales?: boolean | coupon_sales$salesArgs<ExtArgs>
  }, ExtArgs["result"]["coupon_sales"]>

  export type coupon_salesSelectScalar = {
    id?: boolean
    sale_id?: boolean
    coupon_id?: boolean
    value?: boolean
    target?: boolean
    sponsorship?: boolean
  }

  export type coupon_salesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "coupon_id" | "value" | "target" | "sponsorship", ExtArgs["result"]["coupon_sales"]>
  export type coupon_salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupons?: boolean | coupon_sales$couponsArgs<ExtArgs>
    sales?: boolean | coupon_sales$salesArgs<ExtArgs>
  }
  export type coupon_salesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupons?: boolean | coupon_sales$couponsArgs<ExtArgs>
    sales?: boolean | coupon_sales$salesArgs<ExtArgs>
  }
  export type coupon_salesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupons?: boolean | coupon_sales$couponsArgs<ExtArgs>
    sales?: boolean | coupon_sales$salesArgs<ExtArgs>
  }

  export type $coupon_salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coupon_sales"
    objects: {
      coupons: Prisma.$couponsPayload<ExtArgs> | null
      sales: Prisma.$salesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number | null
      coupon_id: number | null
      value: number | null
      target: string | null
      sponsorship: string | null
    }, ExtArgs["result"]["coupon_sales"]>
    composites: {}
  }

  type coupon_salesGetPayload<S extends boolean | null | undefined | coupon_salesDefaultArgs> = $Result.GetResult<Prisma.$coupon_salesPayload, S>

  type coupon_salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<coupon_salesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Coupon_salesCountAggregateInputType | true
    }

  export interface coupon_salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coupon_sales'], meta: { name: 'coupon_sales' } }
    /**
     * Find zero or one Coupon_sales that matches the filter.
     * @param {coupon_salesFindUniqueArgs} args - Arguments to find a Coupon_sales
     * @example
     * // Get one Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coupon_salesFindUniqueArgs>(args: SelectSubset<T, coupon_salesFindUniqueArgs<ExtArgs>>): Prisma__coupon_salesClient<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon_sales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {coupon_salesFindUniqueOrThrowArgs} args - Arguments to find a Coupon_sales
     * @example
     * // Get one Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coupon_salesFindUniqueOrThrowArgs>(args: SelectSubset<T, coupon_salesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coupon_salesClient<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coupon_salesFindFirstArgs} args - Arguments to find a Coupon_sales
     * @example
     * // Get one Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coupon_salesFindFirstArgs>(args?: SelectSubset<T, coupon_salesFindFirstArgs<ExtArgs>>): Prisma__coupon_salesClient<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon_sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coupon_salesFindFirstOrThrowArgs} args - Arguments to find a Coupon_sales
     * @example
     * // Get one Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coupon_salesFindFirstOrThrowArgs>(args?: SelectSubset<T, coupon_salesFindFirstOrThrowArgs<ExtArgs>>): Prisma__coupon_salesClient<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupon_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coupon_salesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.findMany()
     * 
     * // Get first 10 Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coupon_salesWithIdOnly = await prisma.coupon_sales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coupon_salesFindManyArgs>(args?: SelectSubset<T, coupon_salesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon_sales.
     * @param {coupon_salesCreateArgs} args - Arguments to create a Coupon_sales.
     * @example
     * // Create one Coupon_sales
     * const Coupon_sales = await prisma.coupon_sales.create({
     *   data: {
     *     // ... data to create a Coupon_sales
     *   }
     * })
     * 
     */
    create<T extends coupon_salesCreateArgs>(args: SelectSubset<T, coupon_salesCreateArgs<ExtArgs>>): Prisma__coupon_salesClient<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupon_sales.
     * @param {coupon_salesCreateManyArgs} args - Arguments to create many Coupon_sales.
     * @example
     * // Create many Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coupon_salesCreateManyArgs>(args?: SelectSubset<T, coupon_salesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupon_sales and returns the data saved in the database.
     * @param {coupon_salesCreateManyAndReturnArgs} args - Arguments to create many Coupon_sales.
     * @example
     * // Create many Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupon_sales and only return the `id`
     * const coupon_salesWithIdOnly = await prisma.coupon_sales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends coupon_salesCreateManyAndReturnArgs>(args?: SelectSubset<T, coupon_salesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon_sales.
     * @param {coupon_salesDeleteArgs} args - Arguments to delete one Coupon_sales.
     * @example
     * // Delete one Coupon_sales
     * const Coupon_sales = await prisma.coupon_sales.delete({
     *   where: {
     *     // ... filter to delete one Coupon_sales
     *   }
     * })
     * 
     */
    delete<T extends coupon_salesDeleteArgs>(args: SelectSubset<T, coupon_salesDeleteArgs<ExtArgs>>): Prisma__coupon_salesClient<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon_sales.
     * @param {coupon_salesUpdateArgs} args - Arguments to update one Coupon_sales.
     * @example
     * // Update one Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coupon_salesUpdateArgs>(args: SelectSubset<T, coupon_salesUpdateArgs<ExtArgs>>): Prisma__coupon_salesClient<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupon_sales.
     * @param {coupon_salesDeleteManyArgs} args - Arguments to filter Coupon_sales to delete.
     * @example
     * // Delete a few Coupon_sales
     * const { count } = await prisma.coupon_sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coupon_salesDeleteManyArgs>(args?: SelectSubset<T, coupon_salesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupon_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coupon_salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coupon_salesUpdateManyArgs>(args: SelectSubset<T, coupon_salesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupon_sales and returns the data updated in the database.
     * @param {coupon_salesUpdateManyAndReturnArgs} args - Arguments to update many Coupon_sales.
     * @example
     * // Update many Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupon_sales and only return the `id`
     * const coupon_salesWithIdOnly = await prisma.coupon_sales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends coupon_salesUpdateManyAndReturnArgs>(args: SelectSubset<T, coupon_salesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon_sales.
     * @param {coupon_salesUpsertArgs} args - Arguments to update or create a Coupon_sales.
     * @example
     * // Update or create a Coupon_sales
     * const coupon_sales = await prisma.coupon_sales.upsert({
     *   create: {
     *     // ... data to create a Coupon_sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon_sales we want to update
     *   }
     * })
     */
    upsert<T extends coupon_salesUpsertArgs>(args: SelectSubset<T, coupon_salesUpsertArgs<ExtArgs>>): Prisma__coupon_salesClient<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupon_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coupon_salesCountArgs} args - Arguments to filter Coupon_sales to count.
     * @example
     * // Count the number of Coupon_sales
     * const count = await prisma.coupon_sales.count({
     *   where: {
     *     // ... the filter for the Coupon_sales we want to count
     *   }
     * })
    **/
    count<T extends coupon_salesCountArgs>(
      args?: Subset<T, coupon_salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Coupon_salesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Coupon_salesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Coupon_salesAggregateArgs>(args: Subset<T, Coupon_salesAggregateArgs>): Prisma.PrismaPromise<GetCoupon_salesAggregateType<T>>

    /**
     * Group by Coupon_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coupon_salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coupon_salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coupon_salesGroupByArgs['orderBy'] }
        : { orderBy?: coupon_salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coupon_salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoupon_salesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coupon_sales model
   */
  readonly fields: coupon_salesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coupon_sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coupon_salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coupons<T extends coupon_sales$couponsArgs<ExtArgs> = {}>(args?: Subset<T, coupon_sales$couponsArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sales<T extends coupon_sales$salesArgs<ExtArgs> = {}>(args?: Subset<T, coupon_sales$salesArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coupon_sales model
   */
  interface coupon_salesFieldRefs {
    readonly id: FieldRef<"coupon_sales", 'Int'>
    readonly sale_id: FieldRef<"coupon_sales", 'Int'>
    readonly coupon_id: FieldRef<"coupon_sales", 'Int'>
    readonly value: FieldRef<"coupon_sales", 'Float'>
    readonly target: FieldRef<"coupon_sales", 'String'>
    readonly sponsorship: FieldRef<"coupon_sales", 'String'>
  }
    

  // Custom InputTypes
  /**
   * coupon_sales findUnique
   */
  export type coupon_salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * Filter, which coupon_sales to fetch.
     */
    where: coupon_salesWhereUniqueInput
  }

  /**
   * coupon_sales findUniqueOrThrow
   */
  export type coupon_salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * Filter, which coupon_sales to fetch.
     */
    where: coupon_salesWhereUniqueInput
  }

  /**
   * coupon_sales findFirst
   */
  export type coupon_salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * Filter, which coupon_sales to fetch.
     */
    where?: coupon_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupon_sales to fetch.
     */
    orderBy?: coupon_salesOrderByWithRelationInput | coupon_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupon_sales.
     */
    cursor?: coupon_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupon_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupon_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupon_sales.
     */
    distinct?: Coupon_salesScalarFieldEnum | Coupon_salesScalarFieldEnum[]
  }

  /**
   * coupon_sales findFirstOrThrow
   */
  export type coupon_salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * Filter, which coupon_sales to fetch.
     */
    where?: coupon_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupon_sales to fetch.
     */
    orderBy?: coupon_salesOrderByWithRelationInput | coupon_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupon_sales.
     */
    cursor?: coupon_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupon_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupon_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupon_sales.
     */
    distinct?: Coupon_salesScalarFieldEnum | Coupon_salesScalarFieldEnum[]
  }

  /**
   * coupon_sales findMany
   */
  export type coupon_salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * Filter, which coupon_sales to fetch.
     */
    where?: coupon_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupon_sales to fetch.
     */
    orderBy?: coupon_salesOrderByWithRelationInput | coupon_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coupon_sales.
     */
    cursor?: coupon_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupon_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupon_sales.
     */
    skip?: number
    distinct?: Coupon_salesScalarFieldEnum | Coupon_salesScalarFieldEnum[]
  }

  /**
   * coupon_sales create
   */
  export type coupon_salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * The data needed to create a coupon_sales.
     */
    data?: XOR<coupon_salesCreateInput, coupon_salesUncheckedCreateInput>
  }

  /**
   * coupon_sales createMany
   */
  export type coupon_salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coupon_sales.
     */
    data: coupon_salesCreateManyInput | coupon_salesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coupon_sales createManyAndReturn
   */
  export type coupon_salesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * The data used to create many coupon_sales.
     */
    data: coupon_salesCreateManyInput | coupon_salesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * coupon_sales update
   */
  export type coupon_salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * The data needed to update a coupon_sales.
     */
    data: XOR<coupon_salesUpdateInput, coupon_salesUncheckedUpdateInput>
    /**
     * Choose, which coupon_sales to update.
     */
    where: coupon_salesWhereUniqueInput
  }

  /**
   * coupon_sales updateMany
   */
  export type coupon_salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coupon_sales.
     */
    data: XOR<coupon_salesUpdateManyMutationInput, coupon_salesUncheckedUpdateManyInput>
    /**
     * Filter which coupon_sales to update
     */
    where?: coupon_salesWhereInput
    /**
     * Limit how many coupon_sales to update.
     */
    limit?: number
  }

  /**
   * coupon_sales updateManyAndReturn
   */
  export type coupon_salesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * The data used to update coupon_sales.
     */
    data: XOR<coupon_salesUpdateManyMutationInput, coupon_salesUncheckedUpdateManyInput>
    /**
     * Filter which coupon_sales to update
     */
    where?: coupon_salesWhereInput
    /**
     * Limit how many coupon_sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * coupon_sales upsert
   */
  export type coupon_salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * The filter to search for the coupon_sales to update in case it exists.
     */
    where: coupon_salesWhereUniqueInput
    /**
     * In case the coupon_sales found by the `where` argument doesn't exist, create a new coupon_sales with this data.
     */
    create: XOR<coupon_salesCreateInput, coupon_salesUncheckedCreateInput>
    /**
     * In case the coupon_sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coupon_salesUpdateInput, coupon_salesUncheckedUpdateInput>
  }

  /**
   * coupon_sales delete
   */
  export type coupon_salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    /**
     * Filter which coupon_sales to delete.
     */
    where: coupon_salesWhereUniqueInput
  }

  /**
   * coupon_sales deleteMany
   */
  export type coupon_salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupon_sales to delete
     */
    where?: coupon_salesWhereInput
    /**
     * Limit how many coupon_sales to delete.
     */
    limit?: number
  }

  /**
   * coupon_sales.coupons
   */
  export type coupon_sales$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    where?: couponsWhereInput
  }

  /**
   * coupon_sales.sales
   */
  export type coupon_sales$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    where?: salesWhereInput
  }

  /**
   * coupon_sales without action
   */
  export type coupon_salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
  }


  /**
   * Model coupons
   */

  export type AggregateCoupons = {
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  export type CouponsAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    discount_value: Decimal | null
  }

  export type CouponsSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    discount_value: Decimal | null
  }

  export type CouponsMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    code: string | null
    discount_type: string | null
    discount_value: Decimal | null
    is_active: boolean | null
    valid_from: Date | null
    valid_until: Date | null
  }

  export type CouponsMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    code: string | null
    discount_type: string | null
    discount_value: Decimal | null
    is_active: boolean | null
    valid_from: Date | null
    valid_until: Date | null
  }

  export type CouponsCountAggregateOutputType = {
    id: number
    brand_id: number
    code: number
    discount_type: number
    discount_value: number
    is_active: number
    valid_from: number
    valid_until: number
    _all: number
  }


  export type CouponsAvgAggregateInputType = {
    id?: true
    brand_id?: true
    discount_value?: true
  }

  export type CouponsSumAggregateInputType = {
    id?: true
    brand_id?: true
    discount_value?: true
  }

  export type CouponsMinAggregateInputType = {
    id?: true
    brand_id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    is_active?: true
    valid_from?: true
    valid_until?: true
  }

  export type CouponsMaxAggregateInputType = {
    id?: true
    brand_id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    is_active?: true
    valid_from?: true
    valid_until?: true
  }

  export type CouponsCountAggregateInputType = {
    id?: true
    brand_id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    is_active?: true
    valid_from?: true
    valid_until?: true
    _all?: true
  }

  export type CouponsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupons to aggregate.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coupons
    **/
    _count?: true | CouponsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponsMaxAggregateInputType
  }

  export type GetCouponsAggregateType<T extends CouponsAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupons[P]>
      : GetScalarType<T[P], AggregateCoupons[P]>
  }




  export type couponsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponsWhereInput
    orderBy?: couponsOrderByWithAggregationInput | couponsOrderByWithAggregationInput[]
    by: CouponsScalarFieldEnum[] | CouponsScalarFieldEnum
    having?: couponsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponsCountAggregateInputType | true
    _avg?: CouponsAvgAggregateInputType
    _sum?: CouponsSumAggregateInputType
    _min?: CouponsMinAggregateInputType
    _max?: CouponsMaxAggregateInputType
  }

  export type CouponsGroupByOutputType = {
    id: number
    brand_id: number | null
    code: string
    discount_type: string | null
    discount_value: Decimal | null
    is_active: boolean | null
    valid_from: Date | null
    valid_until: Date | null
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  type GetCouponsGroupByPayload<T extends couponsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponsGroupByOutputType[P]>
            : GetScalarType<T[P], CouponsGroupByOutputType[P]>
        }
      >
    >


  export type couponsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    is_active?: boolean
    valid_from?: boolean
    valid_until?: boolean
    coupon_sales?: boolean | coupons$coupon_salesArgs<ExtArgs>
    brands?: boolean | coupons$brandsArgs<ExtArgs>
    _count?: boolean | CouponsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupons"]>

  export type couponsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    is_active?: boolean
    valid_from?: boolean
    valid_until?: boolean
    brands?: boolean | coupons$brandsArgs<ExtArgs>
  }, ExtArgs["result"]["coupons"]>

  export type couponsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    is_active?: boolean
    valid_from?: boolean
    valid_until?: boolean
    brands?: boolean | coupons$brandsArgs<ExtArgs>
  }, ExtArgs["result"]["coupons"]>

  export type couponsSelectScalar = {
    id?: boolean
    brand_id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    is_active?: boolean
    valid_from?: boolean
    valid_until?: boolean
  }

  export type couponsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "code" | "discount_type" | "discount_value" | "is_active" | "valid_from" | "valid_until", ExtArgs["result"]["coupons"]>
  export type couponsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon_sales?: boolean | coupons$coupon_salesArgs<ExtArgs>
    brands?: boolean | coupons$brandsArgs<ExtArgs>
    _count?: boolean | CouponsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type couponsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | coupons$brandsArgs<ExtArgs>
  }
  export type couponsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | coupons$brandsArgs<ExtArgs>
  }

  export type $couponsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coupons"
    objects: {
      coupon_sales: Prisma.$coupon_salesPayload<ExtArgs>[]
      brands: Prisma.$brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      code: string
      discount_type: string | null
      discount_value: Prisma.Decimal | null
      is_active: boolean | null
      valid_from: Date | null
      valid_until: Date | null
    }, ExtArgs["result"]["coupons"]>
    composites: {}
  }

  type couponsGetPayload<S extends boolean | null | undefined | couponsDefaultArgs> = $Result.GetResult<Prisma.$couponsPayload, S>

  type couponsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<couponsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponsCountAggregateInputType | true
    }

  export interface couponsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coupons'], meta: { name: 'coupons' } }
    /**
     * Find zero or one Coupons that matches the filter.
     * @param {couponsFindUniqueArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends couponsFindUniqueArgs>(args: SelectSubset<T, couponsFindUniqueArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {couponsFindUniqueOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends couponsFindUniqueOrThrowArgs>(args: SelectSubset<T, couponsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindFirstArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends couponsFindFirstArgs>(args?: SelectSubset<T, couponsFindFirstArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindFirstOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends couponsFindFirstOrThrowArgs>(args?: SelectSubset<T, couponsFindFirstOrThrowArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupons.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponsWithIdOnly = await prisma.coupons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends couponsFindManyArgs>(args?: SelectSubset<T, couponsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupons.
     * @param {couponsCreateArgs} args - Arguments to create a Coupons.
     * @example
     * // Create one Coupons
     * const Coupons = await prisma.coupons.create({
     *   data: {
     *     // ... data to create a Coupons
     *   }
     * })
     * 
     */
    create<T extends couponsCreateArgs>(args: SelectSubset<T, couponsCreateArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {couponsCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupons = await prisma.coupons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends couponsCreateManyArgs>(args?: SelectSubset<T, couponsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {couponsCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupons = await prisma.coupons.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponsWithIdOnly = await prisma.coupons.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends couponsCreateManyAndReturnArgs>(args?: SelectSubset<T, couponsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupons.
     * @param {couponsDeleteArgs} args - Arguments to delete one Coupons.
     * @example
     * // Delete one Coupons
     * const Coupons = await prisma.coupons.delete({
     *   where: {
     *     // ... filter to delete one Coupons
     *   }
     * })
     * 
     */
    delete<T extends couponsDeleteArgs>(args: SelectSubset<T, couponsDeleteArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupons.
     * @param {couponsUpdateArgs} args - Arguments to update one Coupons.
     * @example
     * // Update one Coupons
     * const coupons = await prisma.coupons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends couponsUpdateArgs>(args: SelectSubset<T, couponsUpdateArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {couponsDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends couponsDeleteManyArgs>(args?: SelectSubset<T, couponsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupons = await prisma.coupons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends couponsUpdateManyArgs>(args: SelectSubset<T, couponsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {couponsUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupons = await prisma.coupons.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponsWithIdOnly = await prisma.coupons.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends couponsUpdateManyAndReturnArgs>(args: SelectSubset<T, couponsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupons.
     * @param {couponsUpsertArgs} args - Arguments to update or create a Coupons.
     * @example
     * // Update or create a Coupons
     * const coupons = await prisma.coupons.upsert({
     *   create: {
     *     // ... data to create a Coupons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupons we want to update
     *   }
     * })
     */
    upsert<T extends couponsUpsertArgs>(args: SelectSubset<T, couponsUpsertArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupons.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends couponsCountArgs>(
      args?: Subset<T, couponsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponsAggregateArgs>(args: Subset<T, CouponsAggregateArgs>): Prisma.PrismaPromise<GetCouponsAggregateType<T>>

    /**
     * Group by Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends couponsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: couponsGroupByArgs['orderBy'] }
        : { orderBy?: couponsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, couponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coupons model
   */
  readonly fields: couponsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coupons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__couponsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coupon_sales<T extends coupons$coupon_salesArgs<ExtArgs> = {}>(args?: Subset<T, coupons$coupon_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    brands<T extends coupons$brandsArgs<ExtArgs> = {}>(args?: Subset<T, coupons$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coupons model
   */
  interface couponsFieldRefs {
    readonly id: FieldRef<"coupons", 'Int'>
    readonly brand_id: FieldRef<"coupons", 'Int'>
    readonly code: FieldRef<"coupons", 'String'>
    readonly discount_type: FieldRef<"coupons", 'String'>
    readonly discount_value: FieldRef<"coupons", 'Decimal'>
    readonly is_active: FieldRef<"coupons", 'Boolean'>
    readonly valid_from: FieldRef<"coupons", 'DateTime'>
    readonly valid_until: FieldRef<"coupons", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * coupons findUnique
   */
  export type couponsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons findUniqueOrThrow
   */
  export type couponsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons findFirst
   */
  export type couponsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * coupons findFirstOrThrow
   */
  export type couponsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * coupons findMany
   */
  export type couponsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * coupons create
   */
  export type couponsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * The data needed to create a coupons.
     */
    data: XOR<couponsCreateInput, couponsUncheckedCreateInput>
  }

  /**
   * coupons createMany
   */
  export type couponsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coupons.
     */
    data: couponsCreateManyInput | couponsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coupons createManyAndReturn
   */
  export type couponsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * The data used to create many coupons.
     */
    data: couponsCreateManyInput | couponsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * coupons update
   */
  export type couponsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * The data needed to update a coupons.
     */
    data: XOR<couponsUpdateInput, couponsUncheckedUpdateInput>
    /**
     * Choose, which coupons to update.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons updateMany
   */
  export type couponsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coupons.
     */
    data: XOR<couponsUpdateManyMutationInput, couponsUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     */
    where?: couponsWhereInput
    /**
     * Limit how many coupons to update.
     */
    limit?: number
  }

  /**
   * coupons updateManyAndReturn
   */
  export type couponsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * The data used to update coupons.
     */
    data: XOR<couponsUpdateManyMutationInput, couponsUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     */
    where?: couponsWhereInput
    /**
     * Limit how many coupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * coupons upsert
   */
  export type couponsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * The filter to search for the coupons to update in case it exists.
     */
    where: couponsWhereUniqueInput
    /**
     * In case the coupons found by the `where` argument doesn't exist, create a new coupons with this data.
     */
    create: XOR<couponsCreateInput, couponsUncheckedCreateInput>
    /**
     * In case the coupons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<couponsUpdateInput, couponsUncheckedUpdateInput>
  }

  /**
   * coupons delete
   */
  export type couponsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
    /**
     * Filter which coupons to delete.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons deleteMany
   */
  export type couponsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupons to delete
     */
    where?: couponsWhereInput
    /**
     * Limit how many coupons to delete.
     */
    limit?: number
  }

  /**
   * coupons.coupon_sales
   */
  export type coupons$coupon_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    where?: coupon_salesWhereInput
    orderBy?: coupon_salesOrderByWithRelationInput | coupon_salesOrderByWithRelationInput[]
    cursor?: coupon_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Coupon_salesScalarFieldEnum | Coupon_salesScalarFieldEnum[]
  }

  /**
   * coupons.brands
   */
  export type coupons$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * coupons without action
   */
  export type couponsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsInclude<ExtArgs> | null
  }


  /**
   * Model customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    customer_name: string | null
    email: string | null
    phone_number: string | null
    cpf: string | null
    birth_date: Date | null
    gender: string | null
    store_id: number | null
    sub_brand_id: number | null
    registration_origin: string | null
    agree_terms: boolean | null
    receive_promotions_email: boolean | null
    receive_promotions_sms: boolean | null
    created_at: Date | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    customer_name: string | null
    email: string | null
    phone_number: string | null
    cpf: string | null
    birth_date: Date | null
    gender: string | null
    store_id: number | null
    sub_brand_id: number | null
    registration_origin: string | null
    agree_terms: boolean | null
    receive_promotions_email: boolean | null
    receive_promotions_sms: boolean | null
    created_at: Date | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    customer_name: number
    email: number
    phone_number: number
    cpf: number
    birth_date: number
    gender: number
    store_id: number
    sub_brand_id: number
    registration_origin: number
    agree_terms: number
    receive_promotions_email: number
    receive_promotions_sms: number
    created_at: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    customer_name?: true
    email?: true
    phone_number?: true
    cpf?: true
    birth_date?: true
    gender?: true
    store_id?: true
    sub_brand_id?: true
    registration_origin?: true
    agree_terms?: true
    receive_promotions_email?: true
    receive_promotions_sms?: true
    created_at?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    customer_name?: true
    email?: true
    phone_number?: true
    cpf?: true
    birth_date?: true
    gender?: true
    store_id?: true
    sub_brand_id?: true
    registration_origin?: true
    agree_terms?: true
    receive_promotions_email?: true
    receive_promotions_sms?: true
    created_at?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    customer_name?: true
    email?: true
    phone_number?: true
    cpf?: true
    birth_date?: true
    gender?: true
    store_id?: true
    sub_brand_id?: true
    registration_origin?: true
    agree_terms?: true
    receive_promotions_email?: true
    receive_promotions_sms?: true
    created_at?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to aggregate.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type customersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
    orderBy?: customersOrderByWithAggregationInput | customersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: customersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: number
    customer_name: string | null
    email: string | null
    phone_number: string | null
    cpf: string | null
    birth_date: Date | null
    gender: string | null
    store_id: number | null
    sub_brand_id: number | null
    registration_origin: string | null
    agree_terms: boolean | null
    receive_promotions_email: boolean | null
    receive_promotions_sms: boolean | null
    created_at: Date | null
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends customersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type customersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    email?: boolean
    phone_number?: boolean
    cpf?: boolean
    birth_date?: boolean
    gender?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    registration_origin?: boolean
    agree_terms?: boolean
    receive_promotions_email?: boolean
    receive_promotions_sms?: boolean
    created_at?: boolean
    stores?: boolean | customers$storesArgs<ExtArgs>
    sub_brands?: boolean | customers$sub_brandsArgs<ExtArgs>
    sales?: boolean | customers$salesArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    email?: boolean
    phone_number?: boolean
    cpf?: boolean
    birth_date?: boolean
    gender?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    registration_origin?: boolean
    agree_terms?: boolean
    receive_promotions_email?: boolean
    receive_promotions_sms?: boolean
    created_at?: boolean
    stores?: boolean | customers$storesArgs<ExtArgs>
    sub_brands?: boolean | customers$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    email?: boolean
    phone_number?: boolean
    cpf?: boolean
    birth_date?: boolean
    gender?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    registration_origin?: boolean
    agree_terms?: boolean
    receive_promotions_email?: boolean
    receive_promotions_sms?: boolean
    created_at?: boolean
    stores?: boolean | customers$storesArgs<ExtArgs>
    sub_brands?: boolean | customers$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectScalar = {
    id?: boolean
    customer_name?: boolean
    email?: boolean
    phone_number?: boolean
    cpf?: boolean
    birth_date?: boolean
    gender?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    registration_origin?: boolean
    agree_terms?: boolean
    receive_promotions_email?: boolean
    receive_promotions_sms?: boolean
    created_at?: boolean
  }

  export type customersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_name" | "email" | "phone_number" | "cpf" | "birth_date" | "gender" | "store_id" | "sub_brand_id" | "registration_origin" | "agree_terms" | "receive_promotions_email" | "receive_promotions_sms" | "created_at", ExtArgs["result"]["customers"]>
  export type customersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | customers$storesArgs<ExtArgs>
    sub_brands?: boolean | customers$sub_brandsArgs<ExtArgs>
    sales?: boolean | customers$salesArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | customers$storesArgs<ExtArgs>
    sub_brands?: boolean | customers$sub_brandsArgs<ExtArgs>
  }
  export type customersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | customers$storesArgs<ExtArgs>
    sub_brands?: boolean | customers$sub_brandsArgs<ExtArgs>
  }

  export type $customersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customers"
    objects: {
      stores: Prisma.$storesPayload<ExtArgs> | null
      sub_brands: Prisma.$sub_brandsPayload<ExtArgs> | null
      sales: Prisma.$salesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_name: string | null
      email: string | null
      phone_number: string | null
      cpf: string | null
      birth_date: Date | null
      gender: string | null
      store_id: number | null
      sub_brand_id: number | null
      registration_origin: string | null
      agree_terms: boolean | null
      receive_promotions_email: boolean | null
      receive_promotions_sms: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type customersGetPayload<S extends boolean | null | undefined | customersDefaultArgs> = $Result.GetResult<Prisma.$customersPayload, S>

  type customersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface customersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customers'], meta: { name: 'customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {customersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customersFindUniqueArgs>(args: SelectSubset<T, customersFindUniqueArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customersFindUniqueOrThrowArgs>(args: SelectSubset<T, customersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customersFindFirstArgs>(args?: SelectSubset<T, customersFindFirstArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customersFindFirstOrThrowArgs>(args?: SelectSubset<T, customersFindFirstOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customersFindManyArgs>(args?: SelectSubset<T, customersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customers.
     * @param {customersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends customersCreateArgs>(args: SelectSubset<T, customersCreateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customersCreateManyArgs>(args?: SelectSubset<T, customersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customersCreateManyAndReturnArgs>(args?: SelectSubset<T, customersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customers.
     * @param {customersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends customersDeleteArgs>(args: SelectSubset<T, customersDeleteArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customers.
     * @param {customersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customersUpdateArgs>(args: SelectSubset<T, customersUpdateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customersDeleteManyArgs>(args?: SelectSubset<T, customersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customersUpdateManyArgs>(args: SelectSubset<T, customersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customersUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customersUpdateManyAndReturnArgs>(args: SelectSubset<T, customersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customers.
     * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends customersUpsertArgs>(args: SelectSubset<T, customersUpsertArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customersCountArgs>(
      args?: Subset<T, customersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customersGroupByArgs['orderBy'] }
        : { orderBy?: customersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customers model
   */
  readonly fields: customersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends customers$storesArgs<ExtArgs> = {}>(args?: Subset<T, customers$storesArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sub_brands<T extends customers$sub_brandsArgs<ExtArgs> = {}>(args?: Subset<T, customers$sub_brandsArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sales<T extends customers$salesArgs<ExtArgs> = {}>(args?: Subset<T, customers$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customers model
   */
  interface customersFieldRefs {
    readonly id: FieldRef<"customers", 'Int'>
    readonly customer_name: FieldRef<"customers", 'String'>
    readonly email: FieldRef<"customers", 'String'>
    readonly phone_number: FieldRef<"customers", 'String'>
    readonly cpf: FieldRef<"customers", 'String'>
    readonly birth_date: FieldRef<"customers", 'DateTime'>
    readonly gender: FieldRef<"customers", 'String'>
    readonly store_id: FieldRef<"customers", 'Int'>
    readonly sub_brand_id: FieldRef<"customers", 'Int'>
    readonly registration_origin: FieldRef<"customers", 'String'>
    readonly agree_terms: FieldRef<"customers", 'Boolean'>
    readonly receive_promotions_email: FieldRef<"customers", 'Boolean'>
    readonly receive_promotions_sms: FieldRef<"customers", 'Boolean'>
    readonly created_at: FieldRef<"customers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customers findUnique
   */
  export type customersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findUniqueOrThrow
   */
  export type customersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findFirst
   */
  export type customersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findFirstOrThrow
   */
  export type customersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findMany
   */
  export type customersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers create
   */
  export type customersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to create a customers.
     */
    data?: XOR<customersCreateInput, customersUncheckedCreateInput>
  }

  /**
   * customers createMany
   */
  export type customersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customers createManyAndReturn
   */
  export type customersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * customers update
   */
  export type customersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to update a customers.
     */
    data: XOR<customersUpdateInput, customersUncheckedUpdateInput>
    /**
     * Choose, which customers to update.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers updateMany
   */
  export type customersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customers updateManyAndReturn
   */
  export type customersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * customers upsert
   */
  export type customersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The filter to search for the customers to update in case it exists.
     */
    where: customersWhereUniqueInput
    /**
     * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
     */
    create: XOR<customersCreateInput, customersUncheckedCreateInput>
    /**
     * In case the customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customersUpdateInput, customersUncheckedUpdateInput>
  }

  /**
   * customers delete
   */
  export type customersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter which customers to delete.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers deleteMany
   */
  export type customersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customers.stores
   */
  export type customers$storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    where?: storesWhereInput
  }

  /**
   * customers.sub_brands
   */
  export type customers$sub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    where?: sub_brandsWhereInput
  }

  /**
   * customers.sales
   */
  export type customers$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    where?: salesWhereInput
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    cursor?: salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * customers without action
   */
  export type customersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
  }


  /**
   * Model delivery_addresses
   */

  export type AggregateDelivery_addresses = {
    _count: Delivery_addressesCountAggregateOutputType | null
    _avg: Delivery_addressesAvgAggregateOutputType | null
    _sum: Delivery_addressesSumAggregateOutputType | null
    _min: Delivery_addressesMinAggregateOutputType | null
    _max: Delivery_addressesMaxAggregateOutputType | null
  }

  export type Delivery_addressesAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_sale_id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type Delivery_addressesSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_sale_id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type Delivery_addressesMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_sale_id: number | null
    street: string | null
    number: string | null
    complement: string | null
    formatted_address: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    reference: string | null
    latitude: number | null
    longitude: number | null
  }

  export type Delivery_addressesMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_sale_id: number | null
    street: string | null
    number: string | null
    complement: string | null
    formatted_address: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    reference: string | null
    latitude: number | null
    longitude: number | null
  }

  export type Delivery_addressesCountAggregateOutputType = {
    id: number
    sale_id: number
    delivery_sale_id: number
    street: number
    number: number
    complement: number
    formatted_address: number
    neighborhood: number
    city: number
    state: number
    country: number
    postal_code: number
    reference: number
    latitude: number
    longitude: number
    _all: number
  }


  export type Delivery_addressesAvgAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    latitude?: true
    longitude?: true
  }

  export type Delivery_addressesSumAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    latitude?: true
    longitude?: true
  }

  export type Delivery_addressesMinAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    street?: true
    number?: true
    complement?: true
    formatted_address?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    reference?: true
    latitude?: true
    longitude?: true
  }

  export type Delivery_addressesMaxAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    street?: true
    number?: true
    complement?: true
    formatted_address?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    reference?: true
    latitude?: true
    longitude?: true
  }

  export type Delivery_addressesCountAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    street?: true
    number?: true
    complement?: true
    formatted_address?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    reference?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type Delivery_addressesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delivery_addresses to aggregate.
     */
    where?: delivery_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delivery_addresses to fetch.
     */
    orderBy?: delivery_addressesOrderByWithRelationInput | delivery_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: delivery_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delivery_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delivery_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned delivery_addresses
    **/
    _count?: true | Delivery_addressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Delivery_addressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Delivery_addressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Delivery_addressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Delivery_addressesMaxAggregateInputType
  }

  export type GetDelivery_addressesAggregateType<T extends Delivery_addressesAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery_addresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery_addresses[P]>
      : GetScalarType<T[P], AggregateDelivery_addresses[P]>
  }




  export type delivery_addressesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: delivery_addressesWhereInput
    orderBy?: delivery_addressesOrderByWithAggregationInput | delivery_addressesOrderByWithAggregationInput[]
    by: Delivery_addressesScalarFieldEnum[] | Delivery_addressesScalarFieldEnum
    having?: delivery_addressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Delivery_addressesCountAggregateInputType | true
    _avg?: Delivery_addressesAvgAggregateInputType
    _sum?: Delivery_addressesSumAggregateInputType
    _min?: Delivery_addressesMinAggregateInputType
    _max?: Delivery_addressesMaxAggregateInputType
  }

  export type Delivery_addressesGroupByOutputType = {
    id: number
    sale_id: number
    delivery_sale_id: number | null
    street: string | null
    number: string | null
    complement: string | null
    formatted_address: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    reference: string | null
    latitude: number | null
    longitude: number | null
    _count: Delivery_addressesCountAggregateOutputType | null
    _avg: Delivery_addressesAvgAggregateOutputType | null
    _sum: Delivery_addressesSumAggregateOutputType | null
    _min: Delivery_addressesMinAggregateOutputType | null
    _max: Delivery_addressesMaxAggregateOutputType | null
  }

  type GetDelivery_addressesGroupByPayload<T extends delivery_addressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Delivery_addressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Delivery_addressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Delivery_addressesGroupByOutputType[P]>
            : GetScalarType<T[P], Delivery_addressesGroupByOutputType[P]>
        }
      >
    >


  export type delivery_addressesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    delivery_sale_id?: boolean
    street?: boolean
    number?: boolean
    complement?: boolean
    formatted_address?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    reference?: boolean
    latitude?: boolean
    longitude?: boolean
    delivery_sales?: boolean | delivery_addresses$delivery_salesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery_addresses"]>

  export type delivery_addressesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    delivery_sale_id?: boolean
    street?: boolean
    number?: boolean
    complement?: boolean
    formatted_address?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    reference?: boolean
    latitude?: boolean
    longitude?: boolean
    delivery_sales?: boolean | delivery_addresses$delivery_salesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery_addresses"]>

  export type delivery_addressesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    delivery_sale_id?: boolean
    street?: boolean
    number?: boolean
    complement?: boolean
    formatted_address?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    reference?: boolean
    latitude?: boolean
    longitude?: boolean
    delivery_sales?: boolean | delivery_addresses$delivery_salesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery_addresses"]>

  export type delivery_addressesSelectScalar = {
    id?: boolean
    sale_id?: boolean
    delivery_sale_id?: boolean
    street?: boolean
    number?: boolean
    complement?: boolean
    formatted_address?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    reference?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type delivery_addressesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "delivery_sale_id" | "street" | "number" | "complement" | "formatted_address" | "neighborhood" | "city" | "state" | "country" | "postal_code" | "reference" | "latitude" | "longitude", ExtArgs["result"]["delivery_addresses"]>
  export type delivery_addressesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery_sales?: boolean | delivery_addresses$delivery_salesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }
  export type delivery_addressesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery_sales?: boolean | delivery_addresses$delivery_salesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }
  export type delivery_addressesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery_sales?: boolean | delivery_addresses$delivery_salesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }

  export type $delivery_addressesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "delivery_addresses"
    objects: {
      delivery_sales: Prisma.$delivery_salesPayload<ExtArgs> | null
      sales: Prisma.$salesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number
      delivery_sale_id: number | null
      street: string | null
      number: string | null
      complement: string | null
      formatted_address: string | null
      neighborhood: string | null
      city: string | null
      state: string | null
      country: string | null
      postal_code: string | null
      reference: string | null
      latitude: number | null
      longitude: number | null
    }, ExtArgs["result"]["delivery_addresses"]>
    composites: {}
  }

  type delivery_addressesGetPayload<S extends boolean | null | undefined | delivery_addressesDefaultArgs> = $Result.GetResult<Prisma.$delivery_addressesPayload, S>

  type delivery_addressesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<delivery_addressesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Delivery_addressesCountAggregateInputType | true
    }

  export interface delivery_addressesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['delivery_addresses'], meta: { name: 'delivery_addresses' } }
    /**
     * Find zero or one Delivery_addresses that matches the filter.
     * @param {delivery_addressesFindUniqueArgs} args - Arguments to find a Delivery_addresses
     * @example
     * // Get one Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends delivery_addressesFindUniqueArgs>(args: SelectSubset<T, delivery_addressesFindUniqueArgs<ExtArgs>>): Prisma__delivery_addressesClient<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delivery_addresses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {delivery_addressesFindUniqueOrThrowArgs} args - Arguments to find a Delivery_addresses
     * @example
     * // Get one Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends delivery_addressesFindUniqueOrThrowArgs>(args: SelectSubset<T, delivery_addressesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__delivery_addressesClient<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_addressesFindFirstArgs} args - Arguments to find a Delivery_addresses
     * @example
     * // Get one Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends delivery_addressesFindFirstArgs>(args?: SelectSubset<T, delivery_addressesFindFirstArgs<ExtArgs>>): Prisma__delivery_addressesClient<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery_addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_addressesFindFirstOrThrowArgs} args - Arguments to find a Delivery_addresses
     * @example
     * // Get one Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends delivery_addressesFindFirstOrThrowArgs>(args?: SelectSubset<T, delivery_addressesFindFirstOrThrowArgs<ExtArgs>>): Prisma__delivery_addressesClient<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delivery_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_addressesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.findMany()
     * 
     * // Get first 10 Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delivery_addressesWithIdOnly = await prisma.delivery_addresses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends delivery_addressesFindManyArgs>(args?: SelectSubset<T, delivery_addressesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delivery_addresses.
     * @param {delivery_addressesCreateArgs} args - Arguments to create a Delivery_addresses.
     * @example
     * // Create one Delivery_addresses
     * const Delivery_addresses = await prisma.delivery_addresses.create({
     *   data: {
     *     // ... data to create a Delivery_addresses
     *   }
     * })
     * 
     */
    create<T extends delivery_addressesCreateArgs>(args: SelectSubset<T, delivery_addressesCreateArgs<ExtArgs>>): Prisma__delivery_addressesClient<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Delivery_addresses.
     * @param {delivery_addressesCreateManyArgs} args - Arguments to create many Delivery_addresses.
     * @example
     * // Create many Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends delivery_addressesCreateManyArgs>(args?: SelectSubset<T, delivery_addressesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Delivery_addresses and returns the data saved in the database.
     * @param {delivery_addressesCreateManyAndReturnArgs} args - Arguments to create many Delivery_addresses.
     * @example
     * // Create many Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Delivery_addresses and only return the `id`
     * const delivery_addressesWithIdOnly = await prisma.delivery_addresses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends delivery_addressesCreateManyAndReturnArgs>(args?: SelectSubset<T, delivery_addressesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Delivery_addresses.
     * @param {delivery_addressesDeleteArgs} args - Arguments to delete one Delivery_addresses.
     * @example
     * // Delete one Delivery_addresses
     * const Delivery_addresses = await prisma.delivery_addresses.delete({
     *   where: {
     *     // ... filter to delete one Delivery_addresses
     *   }
     * })
     * 
     */
    delete<T extends delivery_addressesDeleteArgs>(args: SelectSubset<T, delivery_addressesDeleteArgs<ExtArgs>>): Prisma__delivery_addressesClient<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delivery_addresses.
     * @param {delivery_addressesUpdateArgs} args - Arguments to update one Delivery_addresses.
     * @example
     * // Update one Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends delivery_addressesUpdateArgs>(args: SelectSubset<T, delivery_addressesUpdateArgs<ExtArgs>>): Prisma__delivery_addressesClient<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Delivery_addresses.
     * @param {delivery_addressesDeleteManyArgs} args - Arguments to filter Delivery_addresses to delete.
     * @example
     * // Delete a few Delivery_addresses
     * const { count } = await prisma.delivery_addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends delivery_addressesDeleteManyArgs>(args?: SelectSubset<T, delivery_addressesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delivery_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_addressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends delivery_addressesUpdateManyArgs>(args: SelectSubset<T, delivery_addressesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delivery_addresses and returns the data updated in the database.
     * @param {delivery_addressesUpdateManyAndReturnArgs} args - Arguments to update many Delivery_addresses.
     * @example
     * // Update many Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Delivery_addresses and only return the `id`
     * const delivery_addressesWithIdOnly = await prisma.delivery_addresses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends delivery_addressesUpdateManyAndReturnArgs>(args: SelectSubset<T, delivery_addressesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Delivery_addresses.
     * @param {delivery_addressesUpsertArgs} args - Arguments to update or create a Delivery_addresses.
     * @example
     * // Update or create a Delivery_addresses
     * const delivery_addresses = await prisma.delivery_addresses.upsert({
     *   create: {
     *     // ... data to create a Delivery_addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery_addresses we want to update
     *   }
     * })
     */
    upsert<T extends delivery_addressesUpsertArgs>(args: SelectSubset<T, delivery_addressesUpsertArgs<ExtArgs>>): Prisma__delivery_addressesClient<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Delivery_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_addressesCountArgs} args - Arguments to filter Delivery_addresses to count.
     * @example
     * // Count the number of Delivery_addresses
     * const count = await prisma.delivery_addresses.count({
     *   where: {
     *     // ... the filter for the Delivery_addresses we want to count
     *   }
     * })
    **/
    count<T extends delivery_addressesCountArgs>(
      args?: Subset<T, delivery_addressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Delivery_addressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Delivery_addressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Delivery_addressesAggregateArgs>(args: Subset<T, Delivery_addressesAggregateArgs>): Prisma.PrismaPromise<GetDelivery_addressesAggregateType<T>>

    /**
     * Group by Delivery_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_addressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends delivery_addressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: delivery_addressesGroupByArgs['orderBy'] }
        : { orderBy?: delivery_addressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, delivery_addressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelivery_addressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the delivery_addresses model
   */
  readonly fields: delivery_addressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for delivery_addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__delivery_addressesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    delivery_sales<T extends delivery_addresses$delivery_salesArgs<ExtArgs> = {}>(args?: Subset<T, delivery_addresses$delivery_salesArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sales<T extends salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, salesDefaultArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the delivery_addresses model
   */
  interface delivery_addressesFieldRefs {
    readonly id: FieldRef<"delivery_addresses", 'Int'>
    readonly sale_id: FieldRef<"delivery_addresses", 'Int'>
    readonly delivery_sale_id: FieldRef<"delivery_addresses", 'Int'>
    readonly street: FieldRef<"delivery_addresses", 'String'>
    readonly number: FieldRef<"delivery_addresses", 'String'>
    readonly complement: FieldRef<"delivery_addresses", 'String'>
    readonly formatted_address: FieldRef<"delivery_addresses", 'String'>
    readonly neighborhood: FieldRef<"delivery_addresses", 'String'>
    readonly city: FieldRef<"delivery_addresses", 'String'>
    readonly state: FieldRef<"delivery_addresses", 'String'>
    readonly country: FieldRef<"delivery_addresses", 'String'>
    readonly postal_code: FieldRef<"delivery_addresses", 'String'>
    readonly reference: FieldRef<"delivery_addresses", 'String'>
    readonly latitude: FieldRef<"delivery_addresses", 'Float'>
    readonly longitude: FieldRef<"delivery_addresses", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * delivery_addresses findUnique
   */
  export type delivery_addressesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_addresses to fetch.
     */
    where: delivery_addressesWhereUniqueInput
  }

  /**
   * delivery_addresses findUniqueOrThrow
   */
  export type delivery_addressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_addresses to fetch.
     */
    where: delivery_addressesWhereUniqueInput
  }

  /**
   * delivery_addresses findFirst
   */
  export type delivery_addressesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_addresses to fetch.
     */
    where?: delivery_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delivery_addresses to fetch.
     */
    orderBy?: delivery_addressesOrderByWithRelationInput | delivery_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delivery_addresses.
     */
    cursor?: delivery_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delivery_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delivery_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delivery_addresses.
     */
    distinct?: Delivery_addressesScalarFieldEnum | Delivery_addressesScalarFieldEnum[]
  }

  /**
   * delivery_addresses findFirstOrThrow
   */
  export type delivery_addressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_addresses to fetch.
     */
    where?: delivery_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delivery_addresses to fetch.
     */
    orderBy?: delivery_addressesOrderByWithRelationInput | delivery_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delivery_addresses.
     */
    cursor?: delivery_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delivery_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delivery_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delivery_addresses.
     */
    distinct?: Delivery_addressesScalarFieldEnum | Delivery_addressesScalarFieldEnum[]
  }

  /**
   * delivery_addresses findMany
   */
  export type delivery_addressesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_addresses to fetch.
     */
    where?: delivery_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delivery_addresses to fetch.
     */
    orderBy?: delivery_addressesOrderByWithRelationInput | delivery_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing delivery_addresses.
     */
    cursor?: delivery_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delivery_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delivery_addresses.
     */
    skip?: number
    distinct?: Delivery_addressesScalarFieldEnum | Delivery_addressesScalarFieldEnum[]
  }

  /**
   * delivery_addresses create
   */
  export type delivery_addressesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * The data needed to create a delivery_addresses.
     */
    data: XOR<delivery_addressesCreateInput, delivery_addressesUncheckedCreateInput>
  }

  /**
   * delivery_addresses createMany
   */
  export type delivery_addressesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many delivery_addresses.
     */
    data: delivery_addressesCreateManyInput | delivery_addressesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * delivery_addresses createManyAndReturn
   */
  export type delivery_addressesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * The data used to create many delivery_addresses.
     */
    data: delivery_addressesCreateManyInput | delivery_addressesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * delivery_addresses update
   */
  export type delivery_addressesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * The data needed to update a delivery_addresses.
     */
    data: XOR<delivery_addressesUpdateInput, delivery_addressesUncheckedUpdateInput>
    /**
     * Choose, which delivery_addresses to update.
     */
    where: delivery_addressesWhereUniqueInput
  }

  /**
   * delivery_addresses updateMany
   */
  export type delivery_addressesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update delivery_addresses.
     */
    data: XOR<delivery_addressesUpdateManyMutationInput, delivery_addressesUncheckedUpdateManyInput>
    /**
     * Filter which delivery_addresses to update
     */
    where?: delivery_addressesWhereInput
    /**
     * Limit how many delivery_addresses to update.
     */
    limit?: number
  }

  /**
   * delivery_addresses updateManyAndReturn
   */
  export type delivery_addressesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * The data used to update delivery_addresses.
     */
    data: XOR<delivery_addressesUpdateManyMutationInput, delivery_addressesUncheckedUpdateManyInput>
    /**
     * Filter which delivery_addresses to update
     */
    where?: delivery_addressesWhereInput
    /**
     * Limit how many delivery_addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * delivery_addresses upsert
   */
  export type delivery_addressesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * The filter to search for the delivery_addresses to update in case it exists.
     */
    where: delivery_addressesWhereUniqueInput
    /**
     * In case the delivery_addresses found by the `where` argument doesn't exist, create a new delivery_addresses with this data.
     */
    create: XOR<delivery_addressesCreateInput, delivery_addressesUncheckedCreateInput>
    /**
     * In case the delivery_addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<delivery_addressesUpdateInput, delivery_addressesUncheckedUpdateInput>
  }

  /**
   * delivery_addresses delete
   */
  export type delivery_addressesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    /**
     * Filter which delivery_addresses to delete.
     */
    where: delivery_addressesWhereUniqueInput
  }

  /**
   * delivery_addresses deleteMany
   */
  export type delivery_addressesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delivery_addresses to delete
     */
    where?: delivery_addressesWhereInput
    /**
     * Limit how many delivery_addresses to delete.
     */
    limit?: number
  }

  /**
   * delivery_addresses.delivery_sales
   */
  export type delivery_addresses$delivery_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    where?: delivery_salesWhereInput
  }

  /**
   * delivery_addresses without action
   */
  export type delivery_addressesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
  }


  /**
   * Model delivery_sales
   */

  export type AggregateDelivery_sales = {
    _count: Delivery_salesCountAggregateOutputType | null
    _avg: Delivery_salesAvgAggregateOutputType | null
    _sum: Delivery_salesSumAggregateOutputType | null
    _min: Delivery_salesMinAggregateOutputType | null
    _max: Delivery_salesMaxAggregateOutputType | null
  }

  export type Delivery_salesAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_fee: number | null
    courier_fee: number | null
  }

  export type Delivery_salesSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_fee: number | null
    courier_fee: number | null
  }

  export type Delivery_salesMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    courier_id: string | null
    courier_name: string | null
    courier_phone: string | null
    courier_type: string | null
    delivered_by: string | null
    delivery_type: string | null
    status: string | null
    delivery_fee: number | null
    courier_fee: number | null
    timing: string | null
    mode: string | null
  }

  export type Delivery_salesMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    courier_id: string | null
    courier_name: string | null
    courier_phone: string | null
    courier_type: string | null
    delivered_by: string | null
    delivery_type: string | null
    status: string | null
    delivery_fee: number | null
    courier_fee: number | null
    timing: string | null
    mode: string | null
  }

  export type Delivery_salesCountAggregateOutputType = {
    id: number
    sale_id: number
    courier_id: number
    courier_name: number
    courier_phone: number
    courier_type: number
    delivered_by: number
    delivery_type: number
    status: number
    delivery_fee: number
    courier_fee: number
    timing: number
    mode: number
    _all: number
  }


  export type Delivery_salesAvgAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_fee?: true
    courier_fee?: true
  }

  export type Delivery_salesSumAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_fee?: true
    courier_fee?: true
  }

  export type Delivery_salesMinAggregateInputType = {
    id?: true
    sale_id?: true
    courier_id?: true
    courier_name?: true
    courier_phone?: true
    courier_type?: true
    delivered_by?: true
    delivery_type?: true
    status?: true
    delivery_fee?: true
    courier_fee?: true
    timing?: true
    mode?: true
  }

  export type Delivery_salesMaxAggregateInputType = {
    id?: true
    sale_id?: true
    courier_id?: true
    courier_name?: true
    courier_phone?: true
    courier_type?: true
    delivered_by?: true
    delivery_type?: true
    status?: true
    delivery_fee?: true
    courier_fee?: true
    timing?: true
    mode?: true
  }

  export type Delivery_salesCountAggregateInputType = {
    id?: true
    sale_id?: true
    courier_id?: true
    courier_name?: true
    courier_phone?: true
    courier_type?: true
    delivered_by?: true
    delivery_type?: true
    status?: true
    delivery_fee?: true
    courier_fee?: true
    timing?: true
    mode?: true
    _all?: true
  }

  export type Delivery_salesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delivery_sales to aggregate.
     */
    where?: delivery_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delivery_sales to fetch.
     */
    orderBy?: delivery_salesOrderByWithRelationInput | delivery_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: delivery_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delivery_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delivery_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned delivery_sales
    **/
    _count?: true | Delivery_salesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Delivery_salesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Delivery_salesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Delivery_salesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Delivery_salesMaxAggregateInputType
  }

  export type GetDelivery_salesAggregateType<T extends Delivery_salesAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery_sales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery_sales[P]>
      : GetScalarType<T[P], AggregateDelivery_sales[P]>
  }




  export type delivery_salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: delivery_salesWhereInput
    orderBy?: delivery_salesOrderByWithAggregationInput | delivery_salesOrderByWithAggregationInput[]
    by: Delivery_salesScalarFieldEnum[] | Delivery_salesScalarFieldEnum
    having?: delivery_salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Delivery_salesCountAggregateInputType | true
    _avg?: Delivery_salesAvgAggregateInputType
    _sum?: Delivery_salesSumAggregateInputType
    _min?: Delivery_salesMinAggregateInputType
    _max?: Delivery_salesMaxAggregateInputType
  }

  export type Delivery_salesGroupByOutputType = {
    id: number
    sale_id: number
    courier_id: string | null
    courier_name: string | null
    courier_phone: string | null
    courier_type: string | null
    delivered_by: string | null
    delivery_type: string | null
    status: string | null
    delivery_fee: number | null
    courier_fee: number | null
    timing: string | null
    mode: string | null
    _count: Delivery_salesCountAggregateOutputType | null
    _avg: Delivery_salesAvgAggregateOutputType | null
    _sum: Delivery_salesSumAggregateOutputType | null
    _min: Delivery_salesMinAggregateOutputType | null
    _max: Delivery_salesMaxAggregateOutputType | null
  }

  type GetDelivery_salesGroupByPayload<T extends delivery_salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Delivery_salesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Delivery_salesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Delivery_salesGroupByOutputType[P]>
            : GetScalarType<T[P], Delivery_salesGroupByOutputType[P]>
        }
      >
    >


  export type delivery_salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    courier_id?: boolean
    courier_name?: boolean
    courier_phone?: boolean
    courier_type?: boolean
    delivered_by?: boolean
    delivery_type?: boolean
    status?: boolean
    delivery_fee?: boolean
    courier_fee?: boolean
    timing?: boolean
    mode?: boolean
    delivery_addresses?: boolean | delivery_sales$delivery_addressesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
    _count?: boolean | Delivery_salesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery_sales"]>

  export type delivery_salesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    courier_id?: boolean
    courier_name?: boolean
    courier_phone?: boolean
    courier_type?: boolean
    delivered_by?: boolean
    delivery_type?: boolean
    status?: boolean
    delivery_fee?: boolean
    courier_fee?: boolean
    timing?: boolean
    mode?: boolean
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery_sales"]>

  export type delivery_salesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    courier_id?: boolean
    courier_name?: boolean
    courier_phone?: boolean
    courier_type?: boolean
    delivered_by?: boolean
    delivery_type?: boolean
    status?: boolean
    delivery_fee?: boolean
    courier_fee?: boolean
    timing?: boolean
    mode?: boolean
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery_sales"]>

  export type delivery_salesSelectScalar = {
    id?: boolean
    sale_id?: boolean
    courier_id?: boolean
    courier_name?: boolean
    courier_phone?: boolean
    courier_type?: boolean
    delivered_by?: boolean
    delivery_type?: boolean
    status?: boolean
    delivery_fee?: boolean
    courier_fee?: boolean
    timing?: boolean
    mode?: boolean
  }

  export type delivery_salesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "courier_id" | "courier_name" | "courier_phone" | "courier_type" | "delivered_by" | "delivery_type" | "status" | "delivery_fee" | "courier_fee" | "timing" | "mode", ExtArgs["result"]["delivery_sales"]>
  export type delivery_salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery_addresses?: boolean | delivery_sales$delivery_addressesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
    _count?: boolean | Delivery_salesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type delivery_salesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }
  export type delivery_salesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }

  export type $delivery_salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "delivery_sales"
    objects: {
      delivery_addresses: Prisma.$delivery_addressesPayload<ExtArgs>[]
      sales: Prisma.$salesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number
      courier_id: string | null
      courier_name: string | null
      courier_phone: string | null
      courier_type: string | null
      delivered_by: string | null
      delivery_type: string | null
      status: string | null
      delivery_fee: number | null
      courier_fee: number | null
      timing: string | null
      mode: string | null
    }, ExtArgs["result"]["delivery_sales"]>
    composites: {}
  }

  type delivery_salesGetPayload<S extends boolean | null | undefined | delivery_salesDefaultArgs> = $Result.GetResult<Prisma.$delivery_salesPayload, S>

  type delivery_salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<delivery_salesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Delivery_salesCountAggregateInputType | true
    }

  export interface delivery_salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['delivery_sales'], meta: { name: 'delivery_sales' } }
    /**
     * Find zero or one Delivery_sales that matches the filter.
     * @param {delivery_salesFindUniqueArgs} args - Arguments to find a Delivery_sales
     * @example
     * // Get one Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends delivery_salesFindUniqueArgs>(args: SelectSubset<T, delivery_salesFindUniqueArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delivery_sales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {delivery_salesFindUniqueOrThrowArgs} args - Arguments to find a Delivery_sales
     * @example
     * // Get one Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends delivery_salesFindUniqueOrThrowArgs>(args: SelectSubset<T, delivery_salesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_salesFindFirstArgs} args - Arguments to find a Delivery_sales
     * @example
     * // Get one Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends delivery_salesFindFirstArgs>(args?: SelectSubset<T, delivery_salesFindFirstArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery_sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_salesFindFirstOrThrowArgs} args - Arguments to find a Delivery_sales
     * @example
     * // Get one Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends delivery_salesFindFirstOrThrowArgs>(args?: SelectSubset<T, delivery_salesFindFirstOrThrowArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delivery_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_salesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.findMany()
     * 
     * // Get first 10 Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delivery_salesWithIdOnly = await prisma.delivery_sales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends delivery_salesFindManyArgs>(args?: SelectSubset<T, delivery_salesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delivery_sales.
     * @param {delivery_salesCreateArgs} args - Arguments to create a Delivery_sales.
     * @example
     * // Create one Delivery_sales
     * const Delivery_sales = await prisma.delivery_sales.create({
     *   data: {
     *     // ... data to create a Delivery_sales
     *   }
     * })
     * 
     */
    create<T extends delivery_salesCreateArgs>(args: SelectSubset<T, delivery_salesCreateArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Delivery_sales.
     * @param {delivery_salesCreateManyArgs} args - Arguments to create many Delivery_sales.
     * @example
     * // Create many Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends delivery_salesCreateManyArgs>(args?: SelectSubset<T, delivery_salesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Delivery_sales and returns the data saved in the database.
     * @param {delivery_salesCreateManyAndReturnArgs} args - Arguments to create many Delivery_sales.
     * @example
     * // Create many Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Delivery_sales and only return the `id`
     * const delivery_salesWithIdOnly = await prisma.delivery_sales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends delivery_salesCreateManyAndReturnArgs>(args?: SelectSubset<T, delivery_salesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Delivery_sales.
     * @param {delivery_salesDeleteArgs} args - Arguments to delete one Delivery_sales.
     * @example
     * // Delete one Delivery_sales
     * const Delivery_sales = await prisma.delivery_sales.delete({
     *   where: {
     *     // ... filter to delete one Delivery_sales
     *   }
     * })
     * 
     */
    delete<T extends delivery_salesDeleteArgs>(args: SelectSubset<T, delivery_salesDeleteArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delivery_sales.
     * @param {delivery_salesUpdateArgs} args - Arguments to update one Delivery_sales.
     * @example
     * // Update one Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends delivery_salesUpdateArgs>(args: SelectSubset<T, delivery_salesUpdateArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Delivery_sales.
     * @param {delivery_salesDeleteManyArgs} args - Arguments to filter Delivery_sales to delete.
     * @example
     * // Delete a few Delivery_sales
     * const { count } = await prisma.delivery_sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends delivery_salesDeleteManyArgs>(args?: SelectSubset<T, delivery_salesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delivery_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends delivery_salesUpdateManyArgs>(args: SelectSubset<T, delivery_salesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delivery_sales and returns the data updated in the database.
     * @param {delivery_salesUpdateManyAndReturnArgs} args - Arguments to update many Delivery_sales.
     * @example
     * // Update many Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Delivery_sales and only return the `id`
     * const delivery_salesWithIdOnly = await prisma.delivery_sales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends delivery_salesUpdateManyAndReturnArgs>(args: SelectSubset<T, delivery_salesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Delivery_sales.
     * @param {delivery_salesUpsertArgs} args - Arguments to update or create a Delivery_sales.
     * @example
     * // Update or create a Delivery_sales
     * const delivery_sales = await prisma.delivery_sales.upsert({
     *   create: {
     *     // ... data to create a Delivery_sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery_sales we want to update
     *   }
     * })
     */
    upsert<T extends delivery_salesUpsertArgs>(args: SelectSubset<T, delivery_salesUpsertArgs<ExtArgs>>): Prisma__delivery_salesClient<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Delivery_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_salesCountArgs} args - Arguments to filter Delivery_sales to count.
     * @example
     * // Count the number of Delivery_sales
     * const count = await prisma.delivery_sales.count({
     *   where: {
     *     // ... the filter for the Delivery_sales we want to count
     *   }
     * })
    **/
    count<T extends delivery_salesCountArgs>(
      args?: Subset<T, delivery_salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Delivery_salesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Delivery_salesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Delivery_salesAggregateArgs>(args: Subset<T, Delivery_salesAggregateArgs>): Prisma.PrismaPromise<GetDelivery_salesAggregateType<T>>

    /**
     * Group by Delivery_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delivery_salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends delivery_salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: delivery_salesGroupByArgs['orderBy'] }
        : { orderBy?: delivery_salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, delivery_salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelivery_salesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the delivery_sales model
   */
  readonly fields: delivery_salesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for delivery_sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__delivery_salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    delivery_addresses<T extends delivery_sales$delivery_addressesArgs<ExtArgs> = {}>(args?: Subset<T, delivery_sales$delivery_addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, salesDefaultArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the delivery_sales model
   */
  interface delivery_salesFieldRefs {
    readonly id: FieldRef<"delivery_sales", 'Int'>
    readonly sale_id: FieldRef<"delivery_sales", 'Int'>
    readonly courier_id: FieldRef<"delivery_sales", 'String'>
    readonly courier_name: FieldRef<"delivery_sales", 'String'>
    readonly courier_phone: FieldRef<"delivery_sales", 'String'>
    readonly courier_type: FieldRef<"delivery_sales", 'String'>
    readonly delivered_by: FieldRef<"delivery_sales", 'String'>
    readonly delivery_type: FieldRef<"delivery_sales", 'String'>
    readonly status: FieldRef<"delivery_sales", 'String'>
    readonly delivery_fee: FieldRef<"delivery_sales", 'Float'>
    readonly courier_fee: FieldRef<"delivery_sales", 'Float'>
    readonly timing: FieldRef<"delivery_sales", 'String'>
    readonly mode: FieldRef<"delivery_sales", 'String'>
  }
    

  // Custom InputTypes
  /**
   * delivery_sales findUnique
   */
  export type delivery_salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_sales to fetch.
     */
    where: delivery_salesWhereUniqueInput
  }

  /**
   * delivery_sales findUniqueOrThrow
   */
  export type delivery_salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_sales to fetch.
     */
    where: delivery_salesWhereUniqueInput
  }

  /**
   * delivery_sales findFirst
   */
  export type delivery_salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_sales to fetch.
     */
    where?: delivery_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delivery_sales to fetch.
     */
    orderBy?: delivery_salesOrderByWithRelationInput | delivery_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delivery_sales.
     */
    cursor?: delivery_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delivery_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delivery_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delivery_sales.
     */
    distinct?: Delivery_salesScalarFieldEnum | Delivery_salesScalarFieldEnum[]
  }

  /**
   * delivery_sales findFirstOrThrow
   */
  export type delivery_salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_sales to fetch.
     */
    where?: delivery_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delivery_sales to fetch.
     */
    orderBy?: delivery_salesOrderByWithRelationInput | delivery_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delivery_sales.
     */
    cursor?: delivery_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delivery_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delivery_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delivery_sales.
     */
    distinct?: Delivery_salesScalarFieldEnum | Delivery_salesScalarFieldEnum[]
  }

  /**
   * delivery_sales findMany
   */
  export type delivery_salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * Filter, which delivery_sales to fetch.
     */
    where?: delivery_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delivery_sales to fetch.
     */
    orderBy?: delivery_salesOrderByWithRelationInput | delivery_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing delivery_sales.
     */
    cursor?: delivery_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delivery_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delivery_sales.
     */
    skip?: number
    distinct?: Delivery_salesScalarFieldEnum | Delivery_salesScalarFieldEnum[]
  }

  /**
   * delivery_sales create
   */
  export type delivery_salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * The data needed to create a delivery_sales.
     */
    data: XOR<delivery_salesCreateInput, delivery_salesUncheckedCreateInput>
  }

  /**
   * delivery_sales createMany
   */
  export type delivery_salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many delivery_sales.
     */
    data: delivery_salesCreateManyInput | delivery_salesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * delivery_sales createManyAndReturn
   */
  export type delivery_salesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * The data used to create many delivery_sales.
     */
    data: delivery_salesCreateManyInput | delivery_salesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * delivery_sales update
   */
  export type delivery_salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * The data needed to update a delivery_sales.
     */
    data: XOR<delivery_salesUpdateInput, delivery_salesUncheckedUpdateInput>
    /**
     * Choose, which delivery_sales to update.
     */
    where: delivery_salesWhereUniqueInput
  }

  /**
   * delivery_sales updateMany
   */
  export type delivery_salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update delivery_sales.
     */
    data: XOR<delivery_salesUpdateManyMutationInput, delivery_salesUncheckedUpdateManyInput>
    /**
     * Filter which delivery_sales to update
     */
    where?: delivery_salesWhereInput
    /**
     * Limit how many delivery_sales to update.
     */
    limit?: number
  }

  /**
   * delivery_sales updateManyAndReturn
   */
  export type delivery_salesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * The data used to update delivery_sales.
     */
    data: XOR<delivery_salesUpdateManyMutationInput, delivery_salesUncheckedUpdateManyInput>
    /**
     * Filter which delivery_sales to update
     */
    where?: delivery_salesWhereInput
    /**
     * Limit how many delivery_sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * delivery_sales upsert
   */
  export type delivery_salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * The filter to search for the delivery_sales to update in case it exists.
     */
    where: delivery_salesWhereUniqueInput
    /**
     * In case the delivery_sales found by the `where` argument doesn't exist, create a new delivery_sales with this data.
     */
    create: XOR<delivery_salesCreateInput, delivery_salesUncheckedCreateInput>
    /**
     * In case the delivery_sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<delivery_salesUpdateInput, delivery_salesUncheckedUpdateInput>
  }

  /**
   * delivery_sales delete
   */
  export type delivery_salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    /**
     * Filter which delivery_sales to delete.
     */
    where: delivery_salesWhereUniqueInput
  }

  /**
   * delivery_sales deleteMany
   */
  export type delivery_salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delivery_sales to delete
     */
    where?: delivery_salesWhereInput
    /**
     * Limit how many delivery_sales to delete.
     */
    limit?: number
  }

  /**
   * delivery_sales.delivery_addresses
   */
  export type delivery_sales$delivery_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    where?: delivery_addressesWhereInput
    orderBy?: delivery_addressesOrderByWithRelationInput | delivery_addressesOrderByWithRelationInput[]
    cursor?: delivery_addressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Delivery_addressesScalarFieldEnum | Delivery_addressesScalarFieldEnum[]
  }

  /**
   * delivery_sales without action
   */
  export type delivery_salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
  }


  /**
   * Model item_item_product_sales
   */

  export type AggregateItem_item_product_sales = {
    _count: Item_item_product_salesCountAggregateOutputType | null
    _avg: Item_item_product_salesAvgAggregateOutputType | null
    _sum: Item_item_product_salesSumAggregateOutputType | null
    _min: Item_item_product_salesMinAggregateOutputType | null
    _max: Item_item_product_salesMaxAggregateOutputType | null
  }

  export type Item_item_product_salesAvgAggregateOutputType = {
    id: number | null
    item_product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type Item_item_product_salesSumAggregateOutputType = {
    id: number | null
    item_product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type Item_item_product_salesMinAggregateOutputType = {
    id: number | null
    item_product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type Item_item_product_salesMaxAggregateOutputType = {
    id: number | null
    item_product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type Item_item_product_salesCountAggregateOutputType = {
    id: number
    item_product_sale_id: number
    item_id: number
    option_group_id: number
    quantity: number
    additional_price: number
    price: number
    amount: number
    _all: number
  }


  export type Item_item_product_salesAvgAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type Item_item_product_salesSumAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type Item_item_product_salesMinAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type Item_item_product_salesMaxAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type Item_item_product_salesCountAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
    _all?: true
  }

  export type Item_item_product_salesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_item_product_sales to aggregate.
     */
    where?: item_item_product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_item_product_sales to fetch.
     */
    orderBy?: item_item_product_salesOrderByWithRelationInput | item_item_product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: item_item_product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_item_product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_item_product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned item_item_product_sales
    **/
    _count?: true | Item_item_product_salesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Item_item_product_salesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Item_item_product_salesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Item_item_product_salesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Item_item_product_salesMaxAggregateInputType
  }

  export type GetItem_item_product_salesAggregateType<T extends Item_item_product_salesAggregateArgs> = {
        [P in keyof T & keyof AggregateItem_item_product_sales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem_item_product_sales[P]>
      : GetScalarType<T[P], AggregateItem_item_product_sales[P]>
  }




  export type item_item_product_salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_item_product_salesWhereInput
    orderBy?: item_item_product_salesOrderByWithAggregationInput | item_item_product_salesOrderByWithAggregationInput[]
    by: Item_item_product_salesScalarFieldEnum[] | Item_item_product_salesScalarFieldEnum
    having?: item_item_product_salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Item_item_product_salesCountAggregateInputType | true
    _avg?: Item_item_product_salesAvgAggregateInputType
    _sum?: Item_item_product_salesSumAggregateInputType
    _min?: Item_item_product_salesMinAggregateInputType
    _max?: Item_item_product_salesMaxAggregateInputType
  }

  export type Item_item_product_salesGroupByOutputType = {
    id: number
    item_product_sale_id: number
    item_id: number
    option_group_id: number | null
    quantity: number
    additional_price: number
    price: number
    amount: number | null
    _count: Item_item_product_salesCountAggregateOutputType | null
    _avg: Item_item_product_salesAvgAggregateOutputType | null
    _sum: Item_item_product_salesSumAggregateOutputType | null
    _min: Item_item_product_salesMinAggregateOutputType | null
    _max: Item_item_product_salesMaxAggregateOutputType | null
  }

  type GetItem_item_product_salesGroupByPayload<T extends item_item_product_salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Item_item_product_salesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Item_item_product_salesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Item_item_product_salesGroupByOutputType[P]>
            : GetScalarType<T[P], Item_item_product_salesGroupByOutputType[P]>
        }
      >
    >


  export type item_item_product_salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    items?: boolean | itemsDefaultArgs<ExtArgs>
    item_product_sales?: boolean | item_product_salesDefaultArgs<ExtArgs>
    option_groups?: boolean | item_item_product_sales$option_groupsArgs<ExtArgs>
  }, ExtArgs["result"]["item_item_product_sales"]>

  export type item_item_product_salesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    items?: boolean | itemsDefaultArgs<ExtArgs>
    item_product_sales?: boolean | item_product_salesDefaultArgs<ExtArgs>
    option_groups?: boolean | item_item_product_sales$option_groupsArgs<ExtArgs>
  }, ExtArgs["result"]["item_item_product_sales"]>

  export type item_item_product_salesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    items?: boolean | itemsDefaultArgs<ExtArgs>
    item_product_sales?: boolean | item_product_salesDefaultArgs<ExtArgs>
    option_groups?: boolean | item_item_product_sales$option_groupsArgs<ExtArgs>
  }, ExtArgs["result"]["item_item_product_sales"]>

  export type item_item_product_salesSelectScalar = {
    id?: boolean
    item_product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
  }

  export type item_item_product_salesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_product_sale_id" | "item_id" | "option_group_id" | "quantity" | "additional_price" | "price" | "amount", ExtArgs["result"]["item_item_product_sales"]>
  export type item_item_product_salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | itemsDefaultArgs<ExtArgs>
    item_product_sales?: boolean | item_product_salesDefaultArgs<ExtArgs>
    option_groups?: boolean | item_item_product_sales$option_groupsArgs<ExtArgs>
  }
  export type item_item_product_salesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | itemsDefaultArgs<ExtArgs>
    item_product_sales?: boolean | item_product_salesDefaultArgs<ExtArgs>
    option_groups?: boolean | item_item_product_sales$option_groupsArgs<ExtArgs>
  }
  export type item_item_product_salesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | itemsDefaultArgs<ExtArgs>
    item_product_sales?: boolean | item_product_salesDefaultArgs<ExtArgs>
    option_groups?: boolean | item_item_product_sales$option_groupsArgs<ExtArgs>
  }

  export type $item_item_product_salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "item_item_product_sales"
    objects: {
      items: Prisma.$itemsPayload<ExtArgs>
      item_product_sales: Prisma.$item_product_salesPayload<ExtArgs>
      option_groups: Prisma.$option_groupsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_product_sale_id: number
      item_id: number
      option_group_id: number | null
      quantity: number
      additional_price: number
      price: number
      amount: number | null
    }, ExtArgs["result"]["item_item_product_sales"]>
    composites: {}
  }

  type item_item_product_salesGetPayload<S extends boolean | null | undefined | item_item_product_salesDefaultArgs> = $Result.GetResult<Prisma.$item_item_product_salesPayload, S>

  type item_item_product_salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<item_item_product_salesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Item_item_product_salesCountAggregateInputType | true
    }

  export interface item_item_product_salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['item_item_product_sales'], meta: { name: 'item_item_product_sales' } }
    /**
     * Find zero or one Item_item_product_sales that matches the filter.
     * @param {item_item_product_salesFindUniqueArgs} args - Arguments to find a Item_item_product_sales
     * @example
     * // Get one Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends item_item_product_salesFindUniqueArgs>(args: SelectSubset<T, item_item_product_salesFindUniqueArgs<ExtArgs>>): Prisma__item_item_product_salesClient<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item_item_product_sales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {item_item_product_salesFindUniqueOrThrowArgs} args - Arguments to find a Item_item_product_sales
     * @example
     * // Get one Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends item_item_product_salesFindUniqueOrThrowArgs>(args: SelectSubset<T, item_item_product_salesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__item_item_product_salesClient<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_item_product_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_item_product_salesFindFirstArgs} args - Arguments to find a Item_item_product_sales
     * @example
     * // Get one Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends item_item_product_salesFindFirstArgs>(args?: SelectSubset<T, item_item_product_salesFindFirstArgs<ExtArgs>>): Prisma__item_item_product_salesClient<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_item_product_sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_item_product_salesFindFirstOrThrowArgs} args - Arguments to find a Item_item_product_sales
     * @example
     * // Get one Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends item_item_product_salesFindFirstOrThrowArgs>(args?: SelectSubset<T, item_item_product_salesFindFirstOrThrowArgs<ExtArgs>>): Prisma__item_item_product_salesClient<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Item_item_product_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_item_product_salesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.findMany()
     * 
     * // Get first 10 Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const item_item_product_salesWithIdOnly = await prisma.item_item_product_sales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends item_item_product_salesFindManyArgs>(args?: SelectSubset<T, item_item_product_salesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item_item_product_sales.
     * @param {item_item_product_salesCreateArgs} args - Arguments to create a Item_item_product_sales.
     * @example
     * // Create one Item_item_product_sales
     * const Item_item_product_sales = await prisma.item_item_product_sales.create({
     *   data: {
     *     // ... data to create a Item_item_product_sales
     *   }
     * })
     * 
     */
    create<T extends item_item_product_salesCreateArgs>(args: SelectSubset<T, item_item_product_salesCreateArgs<ExtArgs>>): Prisma__item_item_product_salesClient<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Item_item_product_sales.
     * @param {item_item_product_salesCreateManyArgs} args - Arguments to create many Item_item_product_sales.
     * @example
     * // Create many Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends item_item_product_salesCreateManyArgs>(args?: SelectSubset<T, item_item_product_salesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Item_item_product_sales and returns the data saved in the database.
     * @param {item_item_product_salesCreateManyAndReturnArgs} args - Arguments to create many Item_item_product_sales.
     * @example
     * // Create many Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Item_item_product_sales and only return the `id`
     * const item_item_product_salesWithIdOnly = await prisma.item_item_product_sales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends item_item_product_salesCreateManyAndReturnArgs>(args?: SelectSubset<T, item_item_product_salesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item_item_product_sales.
     * @param {item_item_product_salesDeleteArgs} args - Arguments to delete one Item_item_product_sales.
     * @example
     * // Delete one Item_item_product_sales
     * const Item_item_product_sales = await prisma.item_item_product_sales.delete({
     *   where: {
     *     // ... filter to delete one Item_item_product_sales
     *   }
     * })
     * 
     */
    delete<T extends item_item_product_salesDeleteArgs>(args: SelectSubset<T, item_item_product_salesDeleteArgs<ExtArgs>>): Prisma__item_item_product_salesClient<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item_item_product_sales.
     * @param {item_item_product_salesUpdateArgs} args - Arguments to update one Item_item_product_sales.
     * @example
     * // Update one Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends item_item_product_salesUpdateArgs>(args: SelectSubset<T, item_item_product_salesUpdateArgs<ExtArgs>>): Prisma__item_item_product_salesClient<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Item_item_product_sales.
     * @param {item_item_product_salesDeleteManyArgs} args - Arguments to filter Item_item_product_sales to delete.
     * @example
     * // Delete a few Item_item_product_sales
     * const { count } = await prisma.item_item_product_sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends item_item_product_salesDeleteManyArgs>(args?: SelectSubset<T, item_item_product_salesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_item_product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_item_product_salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends item_item_product_salesUpdateManyArgs>(args: SelectSubset<T, item_item_product_salesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_item_product_sales and returns the data updated in the database.
     * @param {item_item_product_salesUpdateManyAndReturnArgs} args - Arguments to update many Item_item_product_sales.
     * @example
     * // Update many Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Item_item_product_sales and only return the `id`
     * const item_item_product_salesWithIdOnly = await prisma.item_item_product_sales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends item_item_product_salesUpdateManyAndReturnArgs>(args: SelectSubset<T, item_item_product_salesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item_item_product_sales.
     * @param {item_item_product_salesUpsertArgs} args - Arguments to update or create a Item_item_product_sales.
     * @example
     * // Update or create a Item_item_product_sales
     * const item_item_product_sales = await prisma.item_item_product_sales.upsert({
     *   create: {
     *     // ... data to create a Item_item_product_sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item_item_product_sales we want to update
     *   }
     * })
     */
    upsert<T extends item_item_product_salesUpsertArgs>(args: SelectSubset<T, item_item_product_salesUpsertArgs<ExtArgs>>): Prisma__item_item_product_salesClient<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Item_item_product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_item_product_salesCountArgs} args - Arguments to filter Item_item_product_sales to count.
     * @example
     * // Count the number of Item_item_product_sales
     * const count = await prisma.item_item_product_sales.count({
     *   where: {
     *     // ... the filter for the Item_item_product_sales we want to count
     *   }
     * })
    **/
    count<T extends item_item_product_salesCountArgs>(
      args?: Subset<T, item_item_product_salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Item_item_product_salesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item_item_product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_item_product_salesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Item_item_product_salesAggregateArgs>(args: Subset<T, Item_item_product_salesAggregateArgs>): Prisma.PrismaPromise<GetItem_item_product_salesAggregateType<T>>

    /**
     * Group by Item_item_product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_item_product_salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends item_item_product_salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: item_item_product_salesGroupByArgs['orderBy'] }
        : { orderBy?: item_item_product_salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, item_item_product_salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItem_item_product_salesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the item_item_product_sales model
   */
  readonly fields: item_item_product_salesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for item_item_product_sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__item_item_product_salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends itemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemsDefaultArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item_product_sales<T extends item_product_salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, item_product_salesDefaultArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option_groups<T extends item_item_product_sales$option_groupsArgs<ExtArgs> = {}>(args?: Subset<T, item_item_product_sales$option_groupsArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the item_item_product_sales model
   */
  interface item_item_product_salesFieldRefs {
    readonly id: FieldRef<"item_item_product_sales", 'Int'>
    readonly item_product_sale_id: FieldRef<"item_item_product_sales", 'Int'>
    readonly item_id: FieldRef<"item_item_product_sales", 'Int'>
    readonly option_group_id: FieldRef<"item_item_product_sales", 'Int'>
    readonly quantity: FieldRef<"item_item_product_sales", 'Float'>
    readonly additional_price: FieldRef<"item_item_product_sales", 'Float'>
    readonly price: FieldRef<"item_item_product_sales", 'Float'>
    readonly amount: FieldRef<"item_item_product_sales", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * item_item_product_sales findUnique
   */
  export type item_item_product_salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_item_product_sales to fetch.
     */
    where: item_item_product_salesWhereUniqueInput
  }

  /**
   * item_item_product_sales findUniqueOrThrow
   */
  export type item_item_product_salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_item_product_sales to fetch.
     */
    where: item_item_product_salesWhereUniqueInput
  }

  /**
   * item_item_product_sales findFirst
   */
  export type item_item_product_salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_item_product_sales to fetch.
     */
    where?: item_item_product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_item_product_sales to fetch.
     */
    orderBy?: item_item_product_salesOrderByWithRelationInput | item_item_product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_item_product_sales.
     */
    cursor?: item_item_product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_item_product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_item_product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_item_product_sales.
     */
    distinct?: Item_item_product_salesScalarFieldEnum | Item_item_product_salesScalarFieldEnum[]
  }

  /**
   * item_item_product_sales findFirstOrThrow
   */
  export type item_item_product_salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_item_product_sales to fetch.
     */
    where?: item_item_product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_item_product_sales to fetch.
     */
    orderBy?: item_item_product_salesOrderByWithRelationInput | item_item_product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_item_product_sales.
     */
    cursor?: item_item_product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_item_product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_item_product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_item_product_sales.
     */
    distinct?: Item_item_product_salesScalarFieldEnum | Item_item_product_salesScalarFieldEnum[]
  }

  /**
   * item_item_product_sales findMany
   */
  export type item_item_product_salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_item_product_sales to fetch.
     */
    where?: item_item_product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_item_product_sales to fetch.
     */
    orderBy?: item_item_product_salesOrderByWithRelationInput | item_item_product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing item_item_product_sales.
     */
    cursor?: item_item_product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_item_product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_item_product_sales.
     */
    skip?: number
    distinct?: Item_item_product_salesScalarFieldEnum | Item_item_product_salesScalarFieldEnum[]
  }

  /**
   * item_item_product_sales create
   */
  export type item_item_product_salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * The data needed to create a item_item_product_sales.
     */
    data: XOR<item_item_product_salesCreateInput, item_item_product_salesUncheckedCreateInput>
  }

  /**
   * item_item_product_sales createMany
   */
  export type item_item_product_salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many item_item_product_sales.
     */
    data: item_item_product_salesCreateManyInput | item_item_product_salesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * item_item_product_sales createManyAndReturn
   */
  export type item_item_product_salesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * The data used to create many item_item_product_sales.
     */
    data: item_item_product_salesCreateManyInput | item_item_product_salesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * item_item_product_sales update
   */
  export type item_item_product_salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * The data needed to update a item_item_product_sales.
     */
    data: XOR<item_item_product_salesUpdateInput, item_item_product_salesUncheckedUpdateInput>
    /**
     * Choose, which item_item_product_sales to update.
     */
    where: item_item_product_salesWhereUniqueInput
  }

  /**
   * item_item_product_sales updateMany
   */
  export type item_item_product_salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update item_item_product_sales.
     */
    data: XOR<item_item_product_salesUpdateManyMutationInput, item_item_product_salesUncheckedUpdateManyInput>
    /**
     * Filter which item_item_product_sales to update
     */
    where?: item_item_product_salesWhereInput
    /**
     * Limit how many item_item_product_sales to update.
     */
    limit?: number
  }

  /**
   * item_item_product_sales updateManyAndReturn
   */
  export type item_item_product_salesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * The data used to update item_item_product_sales.
     */
    data: XOR<item_item_product_salesUpdateManyMutationInput, item_item_product_salesUncheckedUpdateManyInput>
    /**
     * Filter which item_item_product_sales to update
     */
    where?: item_item_product_salesWhereInput
    /**
     * Limit how many item_item_product_sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * item_item_product_sales upsert
   */
  export type item_item_product_salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * The filter to search for the item_item_product_sales to update in case it exists.
     */
    where: item_item_product_salesWhereUniqueInput
    /**
     * In case the item_item_product_sales found by the `where` argument doesn't exist, create a new item_item_product_sales with this data.
     */
    create: XOR<item_item_product_salesCreateInput, item_item_product_salesUncheckedCreateInput>
    /**
     * In case the item_item_product_sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<item_item_product_salesUpdateInput, item_item_product_salesUncheckedUpdateInput>
  }

  /**
   * item_item_product_sales delete
   */
  export type item_item_product_salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    /**
     * Filter which item_item_product_sales to delete.
     */
    where: item_item_product_salesWhereUniqueInput
  }

  /**
   * item_item_product_sales deleteMany
   */
  export type item_item_product_salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_item_product_sales to delete
     */
    where?: item_item_product_salesWhereInput
    /**
     * Limit how many item_item_product_sales to delete.
     */
    limit?: number
  }

  /**
   * item_item_product_sales.option_groups
   */
  export type item_item_product_sales$option_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    where?: option_groupsWhereInput
  }

  /**
   * item_item_product_sales without action
   */
  export type item_item_product_salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
  }


  /**
   * Model item_product_sales
   */

  export type AggregateItem_product_sales = {
    _count: Item_product_salesCountAggregateOutputType | null
    _avg: Item_product_salesAvgAggregateOutputType | null
    _sum: Item_product_salesSumAggregateOutputType | null
    _min: Item_product_salesMinAggregateOutputType | null
    _max: Item_product_salesMaxAggregateOutputType | null
  }

  export type Item_product_salesAvgAggregateOutputType = {
    id: number | null
    product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type Item_product_salesSumAggregateOutputType = {
    id: number | null
    product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type Item_product_salesMinAggregateOutputType = {
    id: number | null
    product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
    observations: string | null
  }

  export type Item_product_salesMaxAggregateOutputType = {
    id: number | null
    product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
    observations: string | null
  }

  export type Item_product_salesCountAggregateOutputType = {
    id: number
    product_sale_id: number
    item_id: number
    option_group_id: number
    quantity: number
    additional_price: number
    price: number
    amount: number
    observations: number
    _all: number
  }


  export type Item_product_salesAvgAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type Item_product_salesSumAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type Item_product_salesMinAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
    observations?: true
  }

  export type Item_product_salesMaxAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
    observations?: true
  }

  export type Item_product_salesCountAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
    observations?: true
    _all?: true
  }

  export type Item_product_salesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_product_sales to aggregate.
     */
    where?: item_product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_product_sales to fetch.
     */
    orderBy?: item_product_salesOrderByWithRelationInput | item_product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: item_product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned item_product_sales
    **/
    _count?: true | Item_product_salesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Item_product_salesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Item_product_salesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Item_product_salesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Item_product_salesMaxAggregateInputType
  }

  export type GetItem_product_salesAggregateType<T extends Item_product_salesAggregateArgs> = {
        [P in keyof T & keyof AggregateItem_product_sales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem_product_sales[P]>
      : GetScalarType<T[P], AggregateItem_product_sales[P]>
  }




  export type item_product_salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_product_salesWhereInput
    orderBy?: item_product_salesOrderByWithAggregationInput | item_product_salesOrderByWithAggregationInput[]
    by: Item_product_salesScalarFieldEnum[] | Item_product_salesScalarFieldEnum
    having?: item_product_salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Item_product_salesCountAggregateInputType | true
    _avg?: Item_product_salesAvgAggregateInputType
    _sum?: Item_product_salesSumAggregateInputType
    _min?: Item_product_salesMinAggregateInputType
    _max?: Item_product_salesMaxAggregateInputType
  }

  export type Item_product_salesGroupByOutputType = {
    id: number
    product_sale_id: number
    item_id: number
    option_group_id: number | null
    quantity: number
    additional_price: number
    price: number
    amount: number | null
    observations: string | null
    _count: Item_product_salesCountAggregateOutputType | null
    _avg: Item_product_salesAvgAggregateOutputType | null
    _sum: Item_product_salesSumAggregateOutputType | null
    _min: Item_product_salesMinAggregateOutputType | null
    _max: Item_product_salesMaxAggregateOutputType | null
  }

  type GetItem_product_salesGroupByPayload<T extends item_product_salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Item_product_salesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Item_product_salesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Item_product_salesGroupByOutputType[P]>
            : GetScalarType<T[P], Item_product_salesGroupByOutputType[P]>
        }
      >
    >


  export type item_product_salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    observations?: boolean
    item_item_product_sales?: boolean | item_product_sales$item_item_product_salesArgs<ExtArgs>
    items?: boolean | itemsDefaultArgs<ExtArgs>
    option_groups?: boolean | item_product_sales$option_groupsArgs<ExtArgs>
    product_sales?: boolean | product_salesDefaultArgs<ExtArgs>
    _count?: boolean | Item_product_salesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item_product_sales"]>

  export type item_product_salesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    observations?: boolean
    items?: boolean | itemsDefaultArgs<ExtArgs>
    option_groups?: boolean | item_product_sales$option_groupsArgs<ExtArgs>
    product_sales?: boolean | product_salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item_product_sales"]>

  export type item_product_salesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    observations?: boolean
    items?: boolean | itemsDefaultArgs<ExtArgs>
    option_groups?: boolean | item_product_sales$option_groupsArgs<ExtArgs>
    product_sales?: boolean | product_salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item_product_sales"]>

  export type item_product_salesSelectScalar = {
    id?: boolean
    product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    observations?: boolean
  }

  export type item_product_salesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "product_sale_id" | "item_id" | "option_group_id" | "quantity" | "additional_price" | "price" | "amount" | "observations", ExtArgs["result"]["item_product_sales"]>
  export type item_product_salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_item_product_sales?: boolean | item_product_sales$item_item_product_salesArgs<ExtArgs>
    items?: boolean | itemsDefaultArgs<ExtArgs>
    option_groups?: boolean | item_product_sales$option_groupsArgs<ExtArgs>
    product_sales?: boolean | product_salesDefaultArgs<ExtArgs>
    _count?: boolean | Item_product_salesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type item_product_salesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | itemsDefaultArgs<ExtArgs>
    option_groups?: boolean | item_product_sales$option_groupsArgs<ExtArgs>
    product_sales?: boolean | product_salesDefaultArgs<ExtArgs>
  }
  export type item_product_salesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | itemsDefaultArgs<ExtArgs>
    option_groups?: boolean | item_product_sales$option_groupsArgs<ExtArgs>
    product_sales?: boolean | product_salesDefaultArgs<ExtArgs>
  }

  export type $item_product_salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "item_product_sales"
    objects: {
      item_item_product_sales: Prisma.$item_item_product_salesPayload<ExtArgs>[]
      items: Prisma.$itemsPayload<ExtArgs>
      option_groups: Prisma.$option_groupsPayload<ExtArgs> | null
      product_sales: Prisma.$product_salesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      product_sale_id: number
      item_id: number
      option_group_id: number | null
      quantity: number
      additional_price: number
      price: number
      amount: number | null
      observations: string | null
    }, ExtArgs["result"]["item_product_sales"]>
    composites: {}
  }

  type item_product_salesGetPayload<S extends boolean | null | undefined | item_product_salesDefaultArgs> = $Result.GetResult<Prisma.$item_product_salesPayload, S>

  type item_product_salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<item_product_salesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Item_product_salesCountAggregateInputType | true
    }

  export interface item_product_salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['item_product_sales'], meta: { name: 'item_product_sales' } }
    /**
     * Find zero or one Item_product_sales that matches the filter.
     * @param {item_product_salesFindUniqueArgs} args - Arguments to find a Item_product_sales
     * @example
     * // Get one Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends item_product_salesFindUniqueArgs>(args: SelectSubset<T, item_product_salesFindUniqueArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item_product_sales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {item_product_salesFindUniqueOrThrowArgs} args - Arguments to find a Item_product_sales
     * @example
     * // Get one Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends item_product_salesFindUniqueOrThrowArgs>(args: SelectSubset<T, item_product_salesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_product_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_product_salesFindFirstArgs} args - Arguments to find a Item_product_sales
     * @example
     * // Get one Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends item_product_salesFindFirstArgs>(args?: SelectSubset<T, item_product_salesFindFirstArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_product_sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_product_salesFindFirstOrThrowArgs} args - Arguments to find a Item_product_sales
     * @example
     * // Get one Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends item_product_salesFindFirstOrThrowArgs>(args?: SelectSubset<T, item_product_salesFindFirstOrThrowArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Item_product_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_product_salesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.findMany()
     * 
     * // Get first 10 Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const item_product_salesWithIdOnly = await prisma.item_product_sales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends item_product_salesFindManyArgs>(args?: SelectSubset<T, item_product_salesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item_product_sales.
     * @param {item_product_salesCreateArgs} args - Arguments to create a Item_product_sales.
     * @example
     * // Create one Item_product_sales
     * const Item_product_sales = await prisma.item_product_sales.create({
     *   data: {
     *     // ... data to create a Item_product_sales
     *   }
     * })
     * 
     */
    create<T extends item_product_salesCreateArgs>(args: SelectSubset<T, item_product_salesCreateArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Item_product_sales.
     * @param {item_product_salesCreateManyArgs} args - Arguments to create many Item_product_sales.
     * @example
     * // Create many Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends item_product_salesCreateManyArgs>(args?: SelectSubset<T, item_product_salesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Item_product_sales and returns the data saved in the database.
     * @param {item_product_salesCreateManyAndReturnArgs} args - Arguments to create many Item_product_sales.
     * @example
     * // Create many Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Item_product_sales and only return the `id`
     * const item_product_salesWithIdOnly = await prisma.item_product_sales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends item_product_salesCreateManyAndReturnArgs>(args?: SelectSubset<T, item_product_salesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item_product_sales.
     * @param {item_product_salesDeleteArgs} args - Arguments to delete one Item_product_sales.
     * @example
     * // Delete one Item_product_sales
     * const Item_product_sales = await prisma.item_product_sales.delete({
     *   where: {
     *     // ... filter to delete one Item_product_sales
     *   }
     * })
     * 
     */
    delete<T extends item_product_salesDeleteArgs>(args: SelectSubset<T, item_product_salesDeleteArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item_product_sales.
     * @param {item_product_salesUpdateArgs} args - Arguments to update one Item_product_sales.
     * @example
     * // Update one Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends item_product_salesUpdateArgs>(args: SelectSubset<T, item_product_salesUpdateArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Item_product_sales.
     * @param {item_product_salesDeleteManyArgs} args - Arguments to filter Item_product_sales to delete.
     * @example
     * // Delete a few Item_product_sales
     * const { count } = await prisma.item_product_sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends item_product_salesDeleteManyArgs>(args?: SelectSubset<T, item_product_salesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_product_salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends item_product_salesUpdateManyArgs>(args: SelectSubset<T, item_product_salesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_product_sales and returns the data updated in the database.
     * @param {item_product_salesUpdateManyAndReturnArgs} args - Arguments to update many Item_product_sales.
     * @example
     * // Update many Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Item_product_sales and only return the `id`
     * const item_product_salesWithIdOnly = await prisma.item_product_sales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends item_product_salesUpdateManyAndReturnArgs>(args: SelectSubset<T, item_product_salesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item_product_sales.
     * @param {item_product_salesUpsertArgs} args - Arguments to update or create a Item_product_sales.
     * @example
     * // Update or create a Item_product_sales
     * const item_product_sales = await prisma.item_product_sales.upsert({
     *   create: {
     *     // ... data to create a Item_product_sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item_product_sales we want to update
     *   }
     * })
     */
    upsert<T extends item_product_salesUpsertArgs>(args: SelectSubset<T, item_product_salesUpsertArgs<ExtArgs>>): Prisma__item_product_salesClient<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Item_product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_product_salesCountArgs} args - Arguments to filter Item_product_sales to count.
     * @example
     * // Count the number of Item_product_sales
     * const count = await prisma.item_product_sales.count({
     *   where: {
     *     // ... the filter for the Item_product_sales we want to count
     *   }
     * })
    **/
    count<T extends item_product_salesCountArgs>(
      args?: Subset<T, item_product_salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Item_product_salesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item_product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_product_salesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Item_product_salesAggregateArgs>(args: Subset<T, Item_product_salesAggregateArgs>): Prisma.PrismaPromise<GetItem_product_salesAggregateType<T>>

    /**
     * Group by Item_product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_product_salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends item_product_salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: item_product_salesGroupByArgs['orderBy'] }
        : { orderBy?: item_product_salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, item_product_salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItem_product_salesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the item_product_sales model
   */
  readonly fields: item_product_salesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for item_product_sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__item_product_salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item_item_product_sales<T extends item_product_sales$item_item_product_salesArgs<ExtArgs> = {}>(args?: Subset<T, item_product_sales$item_item_product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends itemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemsDefaultArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option_groups<T extends item_product_sales$option_groupsArgs<ExtArgs> = {}>(args?: Subset<T, item_product_sales$option_groupsArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product_sales<T extends product_salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, product_salesDefaultArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the item_product_sales model
   */
  interface item_product_salesFieldRefs {
    readonly id: FieldRef<"item_product_sales", 'Int'>
    readonly product_sale_id: FieldRef<"item_product_sales", 'Int'>
    readonly item_id: FieldRef<"item_product_sales", 'Int'>
    readonly option_group_id: FieldRef<"item_product_sales", 'Int'>
    readonly quantity: FieldRef<"item_product_sales", 'Float'>
    readonly additional_price: FieldRef<"item_product_sales", 'Float'>
    readonly price: FieldRef<"item_product_sales", 'Float'>
    readonly amount: FieldRef<"item_product_sales", 'Float'>
    readonly observations: FieldRef<"item_product_sales", 'String'>
  }
    

  // Custom InputTypes
  /**
   * item_product_sales findUnique
   */
  export type item_product_salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_product_sales to fetch.
     */
    where: item_product_salesWhereUniqueInput
  }

  /**
   * item_product_sales findUniqueOrThrow
   */
  export type item_product_salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_product_sales to fetch.
     */
    where: item_product_salesWhereUniqueInput
  }

  /**
   * item_product_sales findFirst
   */
  export type item_product_salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_product_sales to fetch.
     */
    where?: item_product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_product_sales to fetch.
     */
    orderBy?: item_product_salesOrderByWithRelationInput | item_product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_product_sales.
     */
    cursor?: item_product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_product_sales.
     */
    distinct?: Item_product_salesScalarFieldEnum | Item_product_salesScalarFieldEnum[]
  }

  /**
   * item_product_sales findFirstOrThrow
   */
  export type item_product_salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_product_sales to fetch.
     */
    where?: item_product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_product_sales to fetch.
     */
    orderBy?: item_product_salesOrderByWithRelationInput | item_product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_product_sales.
     */
    cursor?: item_product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_product_sales.
     */
    distinct?: Item_product_salesScalarFieldEnum | Item_product_salesScalarFieldEnum[]
  }

  /**
   * item_product_sales findMany
   */
  export type item_product_salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * Filter, which item_product_sales to fetch.
     */
    where?: item_product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_product_sales to fetch.
     */
    orderBy?: item_product_salesOrderByWithRelationInput | item_product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing item_product_sales.
     */
    cursor?: item_product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_product_sales.
     */
    skip?: number
    distinct?: Item_product_salesScalarFieldEnum | Item_product_salesScalarFieldEnum[]
  }

  /**
   * item_product_sales create
   */
  export type item_product_salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * The data needed to create a item_product_sales.
     */
    data: XOR<item_product_salesCreateInput, item_product_salesUncheckedCreateInput>
  }

  /**
   * item_product_sales createMany
   */
  export type item_product_salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many item_product_sales.
     */
    data: item_product_salesCreateManyInput | item_product_salesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * item_product_sales createManyAndReturn
   */
  export type item_product_salesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * The data used to create many item_product_sales.
     */
    data: item_product_salesCreateManyInput | item_product_salesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * item_product_sales update
   */
  export type item_product_salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * The data needed to update a item_product_sales.
     */
    data: XOR<item_product_salesUpdateInput, item_product_salesUncheckedUpdateInput>
    /**
     * Choose, which item_product_sales to update.
     */
    where: item_product_salesWhereUniqueInput
  }

  /**
   * item_product_sales updateMany
   */
  export type item_product_salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update item_product_sales.
     */
    data: XOR<item_product_salesUpdateManyMutationInput, item_product_salesUncheckedUpdateManyInput>
    /**
     * Filter which item_product_sales to update
     */
    where?: item_product_salesWhereInput
    /**
     * Limit how many item_product_sales to update.
     */
    limit?: number
  }

  /**
   * item_product_sales updateManyAndReturn
   */
  export type item_product_salesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * The data used to update item_product_sales.
     */
    data: XOR<item_product_salesUpdateManyMutationInput, item_product_salesUncheckedUpdateManyInput>
    /**
     * Filter which item_product_sales to update
     */
    where?: item_product_salesWhereInput
    /**
     * Limit how many item_product_sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * item_product_sales upsert
   */
  export type item_product_salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * The filter to search for the item_product_sales to update in case it exists.
     */
    where: item_product_salesWhereUniqueInput
    /**
     * In case the item_product_sales found by the `where` argument doesn't exist, create a new item_product_sales with this data.
     */
    create: XOR<item_product_salesCreateInput, item_product_salesUncheckedCreateInput>
    /**
     * In case the item_product_sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<item_product_salesUpdateInput, item_product_salesUncheckedUpdateInput>
  }

  /**
   * item_product_sales delete
   */
  export type item_product_salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    /**
     * Filter which item_product_sales to delete.
     */
    where: item_product_salesWhereUniqueInput
  }

  /**
   * item_product_sales deleteMany
   */
  export type item_product_salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_product_sales to delete
     */
    where?: item_product_salesWhereInput
    /**
     * Limit how many item_product_sales to delete.
     */
    limit?: number
  }

  /**
   * item_product_sales.item_item_product_sales
   */
  export type item_product_sales$item_item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    where?: item_item_product_salesWhereInput
    orderBy?: item_item_product_salesOrderByWithRelationInput | item_item_product_salesOrderByWithRelationInput[]
    cursor?: item_item_product_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Item_item_product_salesScalarFieldEnum | Item_item_product_salesScalarFieldEnum[]
  }

  /**
   * item_product_sales.option_groups
   */
  export type item_product_sales$option_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    where?: option_groupsWhereInput
  }

  /**
   * item_product_sales without action
   */
  export type item_product_salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
  }


  /**
   * Model items
   */

  export type AggregateItems = {
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  export type ItemsAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type ItemsSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type ItemsMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type ItemsMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type ItemsCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    category_id: number
    name: number
    pos_uuid: number
    deleted_at: number
    _all: number
  }


  export type ItemsAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type ItemsSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type ItemsMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type ItemsMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type ItemsCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
    _all?: true
  }

  export type ItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to aggregate.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items
    **/
    _count?: true | ItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsMaxAggregateInputType
  }

  export type GetItemsAggregateType<T extends ItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems[P]>
      : GetScalarType<T[P], AggregateItems[P]>
  }




  export type itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithAggregationInput | itemsOrderByWithAggregationInput[]
    by: ItemsScalarFieldEnum[] | ItemsScalarFieldEnum
    having?: itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsCountAggregateInputType | true
    _avg?: ItemsAvgAggregateInputType
    _sum?: ItemsSumAggregateInputType
    _min?: ItemsMinAggregateInputType
    _max?: ItemsMaxAggregateInputType
  }

  export type ItemsGroupByOutputType = {
    id: number
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string
    pos_uuid: string | null
    deleted_at: Date | null
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  type GetItemsGroupByPayload<T extends itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsGroupByOutputType[P]>
        }
      >
    >


  export type itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    item_item_product_sales?: boolean | items$item_item_product_salesArgs<ExtArgs>
    item_product_sales?: boolean | items$item_product_salesArgs<ExtArgs>
    brands?: boolean | items$brandsArgs<ExtArgs>
    categories?: boolean | items$categoriesArgs<ExtArgs>
    sub_brands?: boolean | items$sub_brandsArgs<ExtArgs>
    _count?: boolean | ItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>

  export type itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | items$brandsArgs<ExtArgs>
    categories?: boolean | items$categoriesArgs<ExtArgs>
    sub_brands?: boolean | items$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>

  export type itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | items$brandsArgs<ExtArgs>
    categories?: boolean | items$categoriesArgs<ExtArgs>
    sub_brands?: boolean | items$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>

  export type itemsSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
  }

  export type itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "category_id" | "name" | "pos_uuid" | "deleted_at", ExtArgs["result"]["items"]>
  export type itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_item_product_sales?: boolean | items$item_item_product_salesArgs<ExtArgs>
    item_product_sales?: boolean | items$item_product_salesArgs<ExtArgs>
    brands?: boolean | items$brandsArgs<ExtArgs>
    categories?: boolean | items$categoriesArgs<ExtArgs>
    sub_brands?: boolean | items$sub_brandsArgs<ExtArgs>
    _count?: boolean | ItemsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | items$brandsArgs<ExtArgs>
    categories?: boolean | items$categoriesArgs<ExtArgs>
    sub_brands?: boolean | items$sub_brandsArgs<ExtArgs>
  }
  export type itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | items$brandsArgs<ExtArgs>
    categories?: boolean | items$categoriesArgs<ExtArgs>
    sub_brands?: boolean | items$sub_brandsArgs<ExtArgs>
  }

  export type $itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "items"
    objects: {
      item_item_product_sales: Prisma.$item_item_product_salesPayload<ExtArgs>[]
      item_product_sales: Prisma.$item_product_salesPayload<ExtArgs>[]
      brands: Prisma.$brandsPayload<ExtArgs> | null
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      sub_brands: Prisma.$sub_brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      sub_brand_id: number | null
      category_id: number | null
      name: string
      pos_uuid: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["items"]>
    composites: {}
  }

  type itemsGetPayload<S extends boolean | null | undefined | itemsDefaultArgs> = $Result.GetResult<Prisma.$itemsPayload, S>

  type itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemsCountAggregateInputType | true
    }

  export interface itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['items'], meta: { name: 'items' } }
    /**
     * Find zero or one Items that matches the filter.
     * @param {itemsFindUniqueArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemsFindUniqueArgs>(args: SelectSubset<T, itemsFindUniqueArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itemsFindUniqueOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemsFindFirstArgs>(args?: SelectSubset<T, itemsFindFirstArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.items.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemsWithIdOnly = await prisma.items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemsFindManyArgs>(args?: SelectSubset<T, itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Items.
     * @param {itemsCreateArgs} args - Arguments to create a Items.
     * @example
     * // Create one Items
     * const Items = await prisma.items.create({
     *   data: {
     *     // ... data to create a Items
     *   }
     * })
     * 
     */
    create<T extends itemsCreateArgs>(args: SelectSubset<T, itemsCreateArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {itemsCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const items = await prisma.items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemsCreateManyArgs>(args?: SelectSubset<T, itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {itemsCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const items = await prisma.items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemsWithIdOnly = await prisma.items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Items.
     * @param {itemsDeleteArgs} args - Arguments to delete one Items.
     * @example
     * // Delete one Items
     * const Items = await prisma.items.delete({
     *   where: {
     *     // ... filter to delete one Items
     *   }
     * })
     * 
     */
    delete<T extends itemsDeleteArgs>(args: SelectSubset<T, itemsDeleteArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Items.
     * @param {itemsUpdateArgs} args - Arguments to update one Items.
     * @example
     * // Update one Items
     * const items = await prisma.items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemsUpdateArgs>(args: SelectSubset<T, itemsUpdateArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {itemsDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemsDeleteManyArgs>(args?: SelectSubset<T, itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemsUpdateManyArgs>(args: SelectSubset<T, itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {itemsUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemsWithIdOnly = await prisma.items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Items.
     * @param {itemsUpsertArgs} args - Arguments to update or create a Items.
     * @example
     * // Update or create a Items
     * const items = await prisma.items.upsert({
     *   create: {
     *     // ... data to create a Items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items we want to update
     *   }
     * })
     */
    upsert<T extends itemsUpsertArgs>(args: SelectSubset<T, itemsUpsertArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.items.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends itemsCountArgs>(
      args?: Subset<T, itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsAggregateArgs>(args: Subset<T, ItemsAggregateArgs>): Prisma.PrismaPromise<GetItemsAggregateType<T>>

    /**
     * Group by Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemsGroupByArgs['orderBy'] }
        : { orderBy?: itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the items model
   */
  readonly fields: itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item_item_product_sales<T extends items$item_item_product_salesArgs<ExtArgs> = {}>(args?: Subset<T, items$item_item_product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    item_product_sales<T extends items$item_product_salesArgs<ExtArgs> = {}>(args?: Subset<T, items$item_product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    brands<T extends items$brandsArgs<ExtArgs> = {}>(args?: Subset<T, items$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    categories<T extends items$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, items$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sub_brands<T extends items$sub_brandsArgs<ExtArgs> = {}>(args?: Subset<T, items$sub_brandsArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the items model
   */
  interface itemsFieldRefs {
    readonly id: FieldRef<"items", 'Int'>
    readonly brand_id: FieldRef<"items", 'Int'>
    readonly sub_brand_id: FieldRef<"items", 'Int'>
    readonly category_id: FieldRef<"items", 'Int'>
    readonly name: FieldRef<"items", 'String'>
    readonly pos_uuid: FieldRef<"items", 'String'>
    readonly deleted_at: FieldRef<"items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * items findUnique
   */
  export type itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findUniqueOrThrow
   */
  export type itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findFirst
   */
  export type itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findFirstOrThrow
   */
  export type itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findMany
   */
  export type itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items create
   */
  export type itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a items.
     */
    data: XOR<itemsCreateInput, itemsUncheckedCreateInput>
  }

  /**
   * items createMany
   */
  export type itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many items.
     */
    data: itemsCreateManyInput | itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * items createManyAndReturn
   */
  export type itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * The data used to create many items.
     */
    data: itemsCreateManyInput | itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * items update
   */
  export type itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a items.
     */
    data: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
    /**
     * Choose, which items to update.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items updateMany
   */
  export type itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update items.
     */
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemsWhereInput
    /**
     * Limit how many items to update.
     */
    limit?: number
  }

  /**
   * items updateManyAndReturn
   */
  export type itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * The data used to update items.
     */
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemsWhereInput
    /**
     * Limit how many items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * items upsert
   */
  export type itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the items to update in case it exists.
     */
    where: itemsWhereUniqueInput
    /**
     * In case the items found by the `where` argument doesn't exist, create a new items with this data.
     */
    create: XOR<itemsCreateInput, itemsUncheckedCreateInput>
    /**
     * In case the items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
  }

  /**
   * items delete
   */
  export type itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    /**
     * Filter which items to delete.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items deleteMany
   */
  export type itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to delete
     */
    where?: itemsWhereInput
    /**
     * Limit how many items to delete.
     */
    limit?: number
  }

  /**
   * items.item_item_product_sales
   */
  export type items$item_item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    where?: item_item_product_salesWhereInput
    orderBy?: item_item_product_salesOrderByWithRelationInput | item_item_product_salesOrderByWithRelationInput[]
    cursor?: item_item_product_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Item_item_product_salesScalarFieldEnum | Item_item_product_salesScalarFieldEnum[]
  }

  /**
   * items.item_product_sales
   */
  export type items$item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    where?: item_product_salesWhereInput
    orderBy?: item_product_salesOrderByWithRelationInput | item_product_salesOrderByWithRelationInput[]
    cursor?: item_product_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Item_product_salesScalarFieldEnum | Item_product_salesScalarFieldEnum[]
  }

  /**
   * items.brands
   */
  export type items$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * items.categories
   */
  export type items$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * items.sub_brands
   */
  export type items$sub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    where?: sub_brandsWhereInput
  }

  /**
   * items without action
   */
  export type itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
  }


  /**
   * Model option_groups
   */

  export type AggregateOption_groups = {
    _count: Option_groupsCountAggregateOutputType | null
    _avg: Option_groupsAvgAggregateOutputType | null
    _sum: Option_groupsSumAggregateOutputType | null
    _min: Option_groupsMinAggregateOutputType | null
    _max: Option_groupsMaxAggregateOutputType | null
  }

  export type Option_groupsAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type Option_groupsSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type Option_groupsMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type Option_groupsMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type Option_groupsCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    category_id: number
    name: number
    pos_uuid: number
    deleted_at: number
    _all: number
  }


  export type Option_groupsAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type Option_groupsSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type Option_groupsMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type Option_groupsMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type Option_groupsCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
    _all?: true
  }

  export type Option_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which option_groups to aggregate.
     */
    where?: option_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of option_groups to fetch.
     */
    orderBy?: option_groupsOrderByWithRelationInput | option_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: option_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` option_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` option_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned option_groups
    **/
    _count?: true | Option_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Option_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Option_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Option_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Option_groupsMaxAggregateInputType
  }

  export type GetOption_groupsAggregateType<T extends Option_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateOption_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption_groups[P]>
      : GetScalarType<T[P], AggregateOption_groups[P]>
  }




  export type option_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: option_groupsWhereInput
    orderBy?: option_groupsOrderByWithAggregationInput | option_groupsOrderByWithAggregationInput[]
    by: Option_groupsScalarFieldEnum[] | Option_groupsScalarFieldEnum
    having?: option_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Option_groupsCountAggregateInputType | true
    _avg?: Option_groupsAvgAggregateInputType
    _sum?: Option_groupsSumAggregateInputType
    _min?: Option_groupsMinAggregateInputType
    _max?: Option_groupsMaxAggregateInputType
  }

  export type Option_groupsGroupByOutputType = {
    id: number
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string
    pos_uuid: string | null
    deleted_at: Date | null
    _count: Option_groupsCountAggregateOutputType | null
    _avg: Option_groupsAvgAggregateOutputType | null
    _sum: Option_groupsSumAggregateOutputType | null
    _min: Option_groupsMinAggregateOutputType | null
    _max: Option_groupsMaxAggregateOutputType | null
  }

  type GetOption_groupsGroupByPayload<T extends option_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Option_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Option_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Option_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Option_groupsGroupByOutputType[P]>
        }
      >
    >


  export type option_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    item_item_product_sales?: boolean | option_groups$item_item_product_salesArgs<ExtArgs>
    item_product_sales?: boolean | option_groups$item_product_salesArgs<ExtArgs>
    brands?: boolean | option_groups$brandsArgs<ExtArgs>
    categories?: boolean | option_groups$categoriesArgs<ExtArgs>
    sub_brands?: boolean | option_groups$sub_brandsArgs<ExtArgs>
    _count?: boolean | Option_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option_groups"]>

  export type option_groupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | option_groups$brandsArgs<ExtArgs>
    categories?: boolean | option_groups$categoriesArgs<ExtArgs>
    sub_brands?: boolean | option_groups$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["option_groups"]>

  export type option_groupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | option_groups$brandsArgs<ExtArgs>
    categories?: boolean | option_groups$categoriesArgs<ExtArgs>
    sub_brands?: boolean | option_groups$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["option_groups"]>

  export type option_groupsSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
  }

  export type option_groupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "category_id" | "name" | "pos_uuid" | "deleted_at", ExtArgs["result"]["option_groups"]>
  export type option_groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_item_product_sales?: boolean | option_groups$item_item_product_salesArgs<ExtArgs>
    item_product_sales?: boolean | option_groups$item_product_salesArgs<ExtArgs>
    brands?: boolean | option_groups$brandsArgs<ExtArgs>
    categories?: boolean | option_groups$categoriesArgs<ExtArgs>
    sub_brands?: boolean | option_groups$sub_brandsArgs<ExtArgs>
    _count?: boolean | Option_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type option_groupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | option_groups$brandsArgs<ExtArgs>
    categories?: boolean | option_groups$categoriesArgs<ExtArgs>
    sub_brands?: boolean | option_groups$sub_brandsArgs<ExtArgs>
  }
  export type option_groupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | option_groups$brandsArgs<ExtArgs>
    categories?: boolean | option_groups$categoriesArgs<ExtArgs>
    sub_brands?: boolean | option_groups$sub_brandsArgs<ExtArgs>
  }

  export type $option_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "option_groups"
    objects: {
      item_item_product_sales: Prisma.$item_item_product_salesPayload<ExtArgs>[]
      item_product_sales: Prisma.$item_product_salesPayload<ExtArgs>[]
      brands: Prisma.$brandsPayload<ExtArgs> | null
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      sub_brands: Prisma.$sub_brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      sub_brand_id: number | null
      category_id: number | null
      name: string
      pos_uuid: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["option_groups"]>
    composites: {}
  }

  type option_groupsGetPayload<S extends boolean | null | undefined | option_groupsDefaultArgs> = $Result.GetResult<Prisma.$option_groupsPayload, S>

  type option_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<option_groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Option_groupsCountAggregateInputType | true
    }

  export interface option_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['option_groups'], meta: { name: 'option_groups' } }
    /**
     * Find zero or one Option_groups that matches the filter.
     * @param {option_groupsFindUniqueArgs} args - Arguments to find a Option_groups
     * @example
     * // Get one Option_groups
     * const option_groups = await prisma.option_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends option_groupsFindUniqueArgs>(args: SelectSubset<T, option_groupsFindUniqueArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Option_groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {option_groupsFindUniqueOrThrowArgs} args - Arguments to find a Option_groups
     * @example
     * // Get one Option_groups
     * const option_groups = await prisma.option_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends option_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, option_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_groupsFindFirstArgs} args - Arguments to find a Option_groups
     * @example
     * // Get one Option_groups
     * const option_groups = await prisma.option_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends option_groupsFindFirstArgs>(args?: SelectSubset<T, option_groupsFindFirstArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_groupsFindFirstOrThrowArgs} args - Arguments to find a Option_groups
     * @example
     * // Get one Option_groups
     * const option_groups = await prisma.option_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends option_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, option_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Option_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Option_groups
     * const option_groups = await prisma.option_groups.findMany()
     * 
     * // Get first 10 Option_groups
     * const option_groups = await prisma.option_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const option_groupsWithIdOnly = await prisma.option_groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends option_groupsFindManyArgs>(args?: SelectSubset<T, option_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Option_groups.
     * @param {option_groupsCreateArgs} args - Arguments to create a Option_groups.
     * @example
     * // Create one Option_groups
     * const Option_groups = await prisma.option_groups.create({
     *   data: {
     *     // ... data to create a Option_groups
     *   }
     * })
     * 
     */
    create<T extends option_groupsCreateArgs>(args: SelectSubset<T, option_groupsCreateArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Option_groups.
     * @param {option_groupsCreateManyArgs} args - Arguments to create many Option_groups.
     * @example
     * // Create many Option_groups
     * const option_groups = await prisma.option_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends option_groupsCreateManyArgs>(args?: SelectSubset<T, option_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Option_groups and returns the data saved in the database.
     * @param {option_groupsCreateManyAndReturnArgs} args - Arguments to create many Option_groups.
     * @example
     * // Create many Option_groups
     * const option_groups = await prisma.option_groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Option_groups and only return the `id`
     * const option_groupsWithIdOnly = await prisma.option_groups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends option_groupsCreateManyAndReturnArgs>(args?: SelectSubset<T, option_groupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Option_groups.
     * @param {option_groupsDeleteArgs} args - Arguments to delete one Option_groups.
     * @example
     * // Delete one Option_groups
     * const Option_groups = await prisma.option_groups.delete({
     *   where: {
     *     // ... filter to delete one Option_groups
     *   }
     * })
     * 
     */
    delete<T extends option_groupsDeleteArgs>(args: SelectSubset<T, option_groupsDeleteArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Option_groups.
     * @param {option_groupsUpdateArgs} args - Arguments to update one Option_groups.
     * @example
     * // Update one Option_groups
     * const option_groups = await prisma.option_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends option_groupsUpdateArgs>(args: SelectSubset<T, option_groupsUpdateArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Option_groups.
     * @param {option_groupsDeleteManyArgs} args - Arguments to filter Option_groups to delete.
     * @example
     * // Delete a few Option_groups
     * const { count } = await prisma.option_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends option_groupsDeleteManyArgs>(args?: SelectSubset<T, option_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Option_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Option_groups
     * const option_groups = await prisma.option_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends option_groupsUpdateManyArgs>(args: SelectSubset<T, option_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Option_groups and returns the data updated in the database.
     * @param {option_groupsUpdateManyAndReturnArgs} args - Arguments to update many Option_groups.
     * @example
     * // Update many Option_groups
     * const option_groups = await prisma.option_groups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Option_groups and only return the `id`
     * const option_groupsWithIdOnly = await prisma.option_groups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends option_groupsUpdateManyAndReturnArgs>(args: SelectSubset<T, option_groupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Option_groups.
     * @param {option_groupsUpsertArgs} args - Arguments to update or create a Option_groups.
     * @example
     * // Update or create a Option_groups
     * const option_groups = await prisma.option_groups.upsert({
     *   create: {
     *     // ... data to create a Option_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option_groups we want to update
     *   }
     * })
     */
    upsert<T extends option_groupsUpsertArgs>(args: SelectSubset<T, option_groupsUpsertArgs<ExtArgs>>): Prisma__option_groupsClient<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Option_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_groupsCountArgs} args - Arguments to filter Option_groups to count.
     * @example
     * // Count the number of Option_groups
     * const count = await prisma.option_groups.count({
     *   where: {
     *     // ... the filter for the Option_groups we want to count
     *   }
     * })
    **/
    count<T extends option_groupsCountArgs>(
      args?: Subset<T, option_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Option_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Option_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Option_groupsAggregateArgs>(args: Subset<T, Option_groupsAggregateArgs>): Prisma.PrismaPromise<GetOption_groupsAggregateType<T>>

    /**
     * Group by Option_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends option_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: option_groupsGroupByArgs['orderBy'] }
        : { orderBy?: option_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, option_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOption_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the option_groups model
   */
  readonly fields: option_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for option_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__option_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item_item_product_sales<T extends option_groups$item_item_product_salesArgs<ExtArgs> = {}>(args?: Subset<T, option_groups$item_item_product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_item_product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    item_product_sales<T extends option_groups$item_product_salesArgs<ExtArgs> = {}>(args?: Subset<T, option_groups$item_product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    brands<T extends option_groups$brandsArgs<ExtArgs> = {}>(args?: Subset<T, option_groups$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    categories<T extends option_groups$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, option_groups$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sub_brands<T extends option_groups$sub_brandsArgs<ExtArgs> = {}>(args?: Subset<T, option_groups$sub_brandsArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the option_groups model
   */
  interface option_groupsFieldRefs {
    readonly id: FieldRef<"option_groups", 'Int'>
    readonly brand_id: FieldRef<"option_groups", 'Int'>
    readonly sub_brand_id: FieldRef<"option_groups", 'Int'>
    readonly category_id: FieldRef<"option_groups", 'Int'>
    readonly name: FieldRef<"option_groups", 'String'>
    readonly pos_uuid: FieldRef<"option_groups", 'String'>
    readonly deleted_at: FieldRef<"option_groups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * option_groups findUnique
   */
  export type option_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * Filter, which option_groups to fetch.
     */
    where: option_groupsWhereUniqueInput
  }

  /**
   * option_groups findUniqueOrThrow
   */
  export type option_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * Filter, which option_groups to fetch.
     */
    where: option_groupsWhereUniqueInput
  }

  /**
   * option_groups findFirst
   */
  export type option_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * Filter, which option_groups to fetch.
     */
    where?: option_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of option_groups to fetch.
     */
    orderBy?: option_groupsOrderByWithRelationInput | option_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for option_groups.
     */
    cursor?: option_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` option_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` option_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of option_groups.
     */
    distinct?: Option_groupsScalarFieldEnum | Option_groupsScalarFieldEnum[]
  }

  /**
   * option_groups findFirstOrThrow
   */
  export type option_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * Filter, which option_groups to fetch.
     */
    where?: option_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of option_groups to fetch.
     */
    orderBy?: option_groupsOrderByWithRelationInput | option_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for option_groups.
     */
    cursor?: option_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` option_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` option_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of option_groups.
     */
    distinct?: Option_groupsScalarFieldEnum | Option_groupsScalarFieldEnum[]
  }

  /**
   * option_groups findMany
   */
  export type option_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * Filter, which option_groups to fetch.
     */
    where?: option_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of option_groups to fetch.
     */
    orderBy?: option_groupsOrderByWithRelationInput | option_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing option_groups.
     */
    cursor?: option_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` option_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` option_groups.
     */
    skip?: number
    distinct?: Option_groupsScalarFieldEnum | Option_groupsScalarFieldEnum[]
  }

  /**
   * option_groups create
   */
  export type option_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a option_groups.
     */
    data: XOR<option_groupsCreateInput, option_groupsUncheckedCreateInput>
  }

  /**
   * option_groups createMany
   */
  export type option_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many option_groups.
     */
    data: option_groupsCreateManyInput | option_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * option_groups createManyAndReturn
   */
  export type option_groupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * The data used to create many option_groups.
     */
    data: option_groupsCreateManyInput | option_groupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * option_groups update
   */
  export type option_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a option_groups.
     */
    data: XOR<option_groupsUpdateInput, option_groupsUncheckedUpdateInput>
    /**
     * Choose, which option_groups to update.
     */
    where: option_groupsWhereUniqueInput
  }

  /**
   * option_groups updateMany
   */
  export type option_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update option_groups.
     */
    data: XOR<option_groupsUpdateManyMutationInput, option_groupsUncheckedUpdateManyInput>
    /**
     * Filter which option_groups to update
     */
    where?: option_groupsWhereInput
    /**
     * Limit how many option_groups to update.
     */
    limit?: number
  }

  /**
   * option_groups updateManyAndReturn
   */
  export type option_groupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * The data used to update option_groups.
     */
    data: XOR<option_groupsUpdateManyMutationInput, option_groupsUncheckedUpdateManyInput>
    /**
     * Filter which option_groups to update
     */
    where?: option_groupsWhereInput
    /**
     * Limit how many option_groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * option_groups upsert
   */
  export type option_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the option_groups to update in case it exists.
     */
    where: option_groupsWhereUniqueInput
    /**
     * In case the option_groups found by the `where` argument doesn't exist, create a new option_groups with this data.
     */
    create: XOR<option_groupsCreateInput, option_groupsUncheckedCreateInput>
    /**
     * In case the option_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<option_groupsUpdateInput, option_groupsUncheckedUpdateInput>
  }

  /**
   * option_groups delete
   */
  export type option_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    /**
     * Filter which option_groups to delete.
     */
    where: option_groupsWhereUniqueInput
  }

  /**
   * option_groups deleteMany
   */
  export type option_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which option_groups to delete
     */
    where?: option_groupsWhereInput
    /**
     * Limit how many option_groups to delete.
     */
    limit?: number
  }

  /**
   * option_groups.item_item_product_sales
   */
  export type option_groups$item_item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_item_product_sales
     */
    select?: item_item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_item_product_sales
     */
    omit?: item_item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_item_product_salesInclude<ExtArgs> | null
    where?: item_item_product_salesWhereInput
    orderBy?: item_item_product_salesOrderByWithRelationInput | item_item_product_salesOrderByWithRelationInput[]
    cursor?: item_item_product_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Item_item_product_salesScalarFieldEnum | Item_item_product_salesScalarFieldEnum[]
  }

  /**
   * option_groups.item_product_sales
   */
  export type option_groups$item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    where?: item_product_salesWhereInput
    orderBy?: item_product_salesOrderByWithRelationInput | item_product_salesOrderByWithRelationInput[]
    cursor?: item_product_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Item_product_salesScalarFieldEnum | Item_product_salesScalarFieldEnum[]
  }

  /**
   * option_groups.brands
   */
  export type option_groups$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * option_groups.categories
   */
  export type option_groups$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * option_groups.sub_brands
   */
  export type option_groups$sub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    where?: sub_brandsWhereInput
  }

  /**
   * option_groups without action
   */
  export type option_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
  }


  /**
   * Model payment_types
   */

  export type AggregatePayment_types = {
    _count: Payment_typesCountAggregateOutputType | null
    _avg: Payment_typesAvgAggregateOutputType | null
    _sum: Payment_typesSumAggregateOutputType | null
    _min: Payment_typesMinAggregateOutputType | null
    _max: Payment_typesMaxAggregateOutputType | null
  }

  export type Payment_typesAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type Payment_typesSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type Payment_typesMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    description: string | null
  }

  export type Payment_typesMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    description: string | null
  }

  export type Payment_typesCountAggregateOutputType = {
    id: number
    brand_id: number
    description: number
    _all: number
  }


  export type Payment_typesAvgAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type Payment_typesSumAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type Payment_typesMinAggregateInputType = {
    id?: true
    brand_id?: true
    description?: true
  }

  export type Payment_typesMaxAggregateInputType = {
    id?: true
    brand_id?: true
    description?: true
  }

  export type Payment_typesCountAggregateInputType = {
    id?: true
    brand_id?: true
    description?: true
    _all?: true
  }

  export type Payment_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_types to aggregate.
     */
    where?: payment_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_types to fetch.
     */
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_types
    **/
    _count?: true | Payment_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_typesMaxAggregateInputType
  }

  export type GetPayment_typesAggregateType<T extends Payment_typesAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_types[P]>
      : GetScalarType<T[P], AggregatePayment_types[P]>
  }




  export type payment_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_typesWhereInput
    orderBy?: payment_typesOrderByWithAggregationInput | payment_typesOrderByWithAggregationInput[]
    by: Payment_typesScalarFieldEnum[] | Payment_typesScalarFieldEnum
    having?: payment_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_typesCountAggregateInputType | true
    _avg?: Payment_typesAvgAggregateInputType
    _sum?: Payment_typesSumAggregateInputType
    _min?: Payment_typesMinAggregateInputType
    _max?: Payment_typesMaxAggregateInputType
  }

  export type Payment_typesGroupByOutputType = {
    id: number
    brand_id: number | null
    description: string
    _count: Payment_typesCountAggregateOutputType | null
    _avg: Payment_typesAvgAggregateOutputType | null
    _sum: Payment_typesSumAggregateOutputType | null
    _min: Payment_typesMinAggregateOutputType | null
    _max: Payment_typesMaxAggregateOutputType | null
  }

  type GetPayment_typesGroupByPayload<T extends payment_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_typesGroupByOutputType[P]>
        }
      >
    >


  export type payment_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    description?: boolean
    brands?: boolean | payment_types$brandsArgs<ExtArgs>
    payments?: boolean | payment_types$paymentsArgs<ExtArgs>
    _count?: boolean | Payment_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_types"]>

  export type payment_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    description?: boolean
    brands?: boolean | payment_types$brandsArgs<ExtArgs>
  }, ExtArgs["result"]["payment_types"]>

  export type payment_typesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    description?: boolean
    brands?: boolean | payment_types$brandsArgs<ExtArgs>
  }, ExtArgs["result"]["payment_types"]>

  export type payment_typesSelectScalar = {
    id?: boolean
    brand_id?: boolean
    description?: boolean
  }

  export type payment_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "description", ExtArgs["result"]["payment_types"]>
  export type payment_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | payment_types$brandsArgs<ExtArgs>
    payments?: boolean | payment_types$paymentsArgs<ExtArgs>
    _count?: boolean | Payment_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payment_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | payment_types$brandsArgs<ExtArgs>
  }
  export type payment_typesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | payment_types$brandsArgs<ExtArgs>
  }

  export type $payment_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_types"
    objects: {
      brands: Prisma.$brandsPayload<ExtArgs> | null
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      description: string
    }, ExtArgs["result"]["payment_types"]>
    composites: {}
  }

  type payment_typesGetPayload<S extends boolean | null | undefined | payment_typesDefaultArgs> = $Result.GetResult<Prisma.$payment_typesPayload, S>

  type payment_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_typesCountAggregateInputType | true
    }

  export interface payment_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_types'], meta: { name: 'payment_types' } }
    /**
     * Find zero or one Payment_types that matches the filter.
     * @param {payment_typesFindUniqueArgs} args - Arguments to find a Payment_types
     * @example
     * // Get one Payment_types
     * const payment_types = await prisma.payment_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_typesFindUniqueArgs>(args: SelectSubset<T, payment_typesFindUniqueArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_typesFindUniqueOrThrowArgs} args - Arguments to find a Payment_types
     * @example
     * // Get one Payment_types
     * const payment_types = await prisma.payment_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesFindFirstArgs} args - Arguments to find a Payment_types
     * @example
     * // Get one Payment_types
     * const payment_types = await prisma.payment_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_typesFindFirstArgs>(args?: SelectSubset<T, payment_typesFindFirstArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesFindFirstOrThrowArgs} args - Arguments to find a Payment_types
     * @example
     * // Get one Payment_types
     * const payment_types = await prisma.payment_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_types
     * const payment_types = await prisma.payment_types.findMany()
     * 
     * // Get first 10 Payment_types
     * const payment_types = await prisma.payment_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_typesWithIdOnly = await prisma.payment_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_typesFindManyArgs>(args?: SelectSubset<T, payment_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_types.
     * @param {payment_typesCreateArgs} args - Arguments to create a Payment_types.
     * @example
     * // Create one Payment_types
     * const Payment_types = await prisma.payment_types.create({
     *   data: {
     *     // ... data to create a Payment_types
     *   }
     * })
     * 
     */
    create<T extends payment_typesCreateArgs>(args: SelectSubset<T, payment_typesCreateArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_types.
     * @param {payment_typesCreateManyArgs} args - Arguments to create many Payment_types.
     * @example
     * // Create many Payment_types
     * const payment_types = await prisma.payment_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_typesCreateManyArgs>(args?: SelectSubset<T, payment_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_types and returns the data saved in the database.
     * @param {payment_typesCreateManyAndReturnArgs} args - Arguments to create many Payment_types.
     * @example
     * // Create many Payment_types
     * const payment_types = await prisma.payment_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_types and only return the `id`
     * const payment_typesWithIdOnly = await prisma.payment_types.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_types.
     * @param {payment_typesDeleteArgs} args - Arguments to delete one Payment_types.
     * @example
     * // Delete one Payment_types
     * const Payment_types = await prisma.payment_types.delete({
     *   where: {
     *     // ... filter to delete one Payment_types
     *   }
     * })
     * 
     */
    delete<T extends payment_typesDeleteArgs>(args: SelectSubset<T, payment_typesDeleteArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_types.
     * @param {payment_typesUpdateArgs} args - Arguments to update one Payment_types.
     * @example
     * // Update one Payment_types
     * const payment_types = await prisma.payment_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_typesUpdateArgs>(args: SelectSubset<T, payment_typesUpdateArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_types.
     * @param {payment_typesDeleteManyArgs} args - Arguments to filter Payment_types to delete.
     * @example
     * // Delete a few Payment_types
     * const { count } = await prisma.payment_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_typesDeleteManyArgs>(args?: SelectSubset<T, payment_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_types
     * const payment_types = await prisma.payment_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_typesUpdateManyArgs>(args: SelectSubset<T, payment_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_types and returns the data updated in the database.
     * @param {payment_typesUpdateManyAndReturnArgs} args - Arguments to update many Payment_types.
     * @example
     * // Update many Payment_types
     * const payment_types = await prisma.payment_types.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_types and only return the `id`
     * const payment_typesWithIdOnly = await prisma.payment_types.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_typesUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_typesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_types.
     * @param {payment_typesUpsertArgs} args - Arguments to update or create a Payment_types.
     * @example
     * // Update or create a Payment_types
     * const payment_types = await prisma.payment_types.upsert({
     *   create: {
     *     // ... data to create a Payment_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_types we want to update
     *   }
     * })
     */
    upsert<T extends payment_typesUpsertArgs>(args: SelectSubset<T, payment_typesUpsertArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesCountArgs} args - Arguments to filter Payment_types to count.
     * @example
     * // Count the number of Payment_types
     * const count = await prisma.payment_types.count({
     *   where: {
     *     // ... the filter for the Payment_types we want to count
     *   }
     * })
    **/
    count<T extends payment_typesCountArgs>(
      args?: Subset<T, payment_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_typesAggregateArgs>(args: Subset<T, Payment_typesAggregateArgs>): Prisma.PrismaPromise<GetPayment_typesAggregateType<T>>

    /**
     * Group by Payment_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_typesGroupByArgs['orderBy'] }
        : { orderBy?: payment_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_types model
   */
  readonly fields: payment_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brands<T extends payment_types$brandsArgs<ExtArgs> = {}>(args?: Subset<T, payment_types$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends payment_types$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, payment_types$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_types model
   */
  interface payment_typesFieldRefs {
    readonly id: FieldRef<"payment_types", 'Int'>
    readonly brand_id: FieldRef<"payment_types", 'Int'>
    readonly description: FieldRef<"payment_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment_types findUnique
   */
  export type payment_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where: payment_typesWhereUniqueInput
  }

  /**
   * payment_types findUniqueOrThrow
   */
  export type payment_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where: payment_typesWhereUniqueInput
  }

  /**
   * payment_types findFirst
   */
  export type payment_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where?: payment_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_types to fetch.
     */
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_types.
     */
    cursor?: payment_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_types.
     */
    distinct?: Payment_typesScalarFieldEnum | Payment_typesScalarFieldEnum[]
  }

  /**
   * payment_types findFirstOrThrow
   */
  export type payment_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where?: payment_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_types to fetch.
     */
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_types.
     */
    cursor?: payment_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_types.
     */
    distinct?: Payment_typesScalarFieldEnum | Payment_typesScalarFieldEnum[]
  }

  /**
   * payment_types findMany
   */
  export type payment_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where?: payment_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_types to fetch.
     */
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_types.
     */
    cursor?: payment_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_types.
     */
    skip?: number
    distinct?: Payment_typesScalarFieldEnum | Payment_typesScalarFieldEnum[]
  }

  /**
   * payment_types create
   */
  export type payment_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_types.
     */
    data: XOR<payment_typesCreateInput, payment_typesUncheckedCreateInput>
  }

  /**
   * payment_types createMany
   */
  export type payment_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_types.
     */
    data: payment_typesCreateManyInput | payment_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_types createManyAndReturn
   */
  export type payment_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * The data used to create many payment_types.
     */
    data: payment_typesCreateManyInput | payment_typesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_types update
   */
  export type payment_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_types.
     */
    data: XOR<payment_typesUpdateInput, payment_typesUncheckedUpdateInput>
    /**
     * Choose, which payment_types to update.
     */
    where: payment_typesWhereUniqueInput
  }

  /**
   * payment_types updateMany
   */
  export type payment_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_types.
     */
    data: XOR<payment_typesUpdateManyMutationInput, payment_typesUncheckedUpdateManyInput>
    /**
     * Filter which payment_types to update
     */
    where?: payment_typesWhereInput
    /**
     * Limit how many payment_types to update.
     */
    limit?: number
  }

  /**
   * payment_types updateManyAndReturn
   */
  export type payment_typesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * The data used to update payment_types.
     */
    data: XOR<payment_typesUpdateManyMutationInput, payment_typesUncheckedUpdateManyInput>
    /**
     * Filter which payment_types to update
     */
    where?: payment_typesWhereInput
    /**
     * Limit how many payment_types to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_types upsert
   */
  export type payment_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_types to update in case it exists.
     */
    where: payment_typesWhereUniqueInput
    /**
     * In case the payment_types found by the `where` argument doesn't exist, create a new payment_types with this data.
     */
    create: XOR<payment_typesCreateInput, payment_typesUncheckedCreateInput>
    /**
     * In case the payment_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_typesUpdateInput, payment_typesUncheckedUpdateInput>
  }

  /**
   * payment_types delete
   */
  export type payment_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter which payment_types to delete.
     */
    where: payment_typesWhereUniqueInput
  }

  /**
   * payment_types deleteMany
   */
  export type payment_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_types to delete
     */
    where?: payment_typesWhereInput
    /**
     * Limit how many payment_types to delete.
     */
    limit?: number
  }

  /**
   * payment_types.brands
   */
  export type payment_types$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * payment_types.payments
   */
  export type payment_types$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payment_types without action
   */
  export type payment_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    payment_type_id: number | null
    value: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    payment_type_id: number | null
    value: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    payment_type_id: number | null
    value: Decimal | null
    is_online: boolean | null
    description: string | null
    currency: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    payment_type_id: number | null
    value: Decimal | null
    is_online: boolean | null
    description: string | null
    currency: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    sale_id: number
    payment_type_id: number
    value: number
    is_online: number
    description: number
    currency: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
    is_online?: true
    description?: true
    currency?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
    is_online?: true
    description?: true
    currency?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
    is_online?: true
    description?: true
    currency?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    sale_id: number
    payment_type_id: number | null
    value: Decimal
    is_online: boolean | null
    description: string | null
    currency: string | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    payment_type_id?: boolean
    value?: boolean
    is_online?: boolean
    description?: boolean
    currency?: boolean
    payment_types?: boolean | payments$payment_typesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    payment_type_id?: boolean
    value?: boolean
    is_online?: boolean
    description?: boolean
    currency?: boolean
    payment_types?: boolean | payments$payment_typesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    payment_type_id?: boolean
    value?: boolean
    is_online?: boolean
    description?: boolean
    currency?: boolean
    payment_types?: boolean | payments$payment_typesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    sale_id?: boolean
    payment_type_id?: boolean
    value?: boolean
    is_online?: boolean
    description?: boolean
    currency?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "payment_type_id" | "value" | "is_online" | "description" | "currency", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_types?: boolean | payments$payment_typesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_types?: boolean | payments$payment_typesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_types?: boolean | payments$payment_typesArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      payment_types: Prisma.$payment_typesPayload<ExtArgs> | null
      sales: Prisma.$salesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number
      payment_type_id: number | null
      value: Prisma.Decimal
      is_online: boolean | null
      description: string | null
      currency: string | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment_types<T extends payments$payment_typesArgs<ExtArgs> = {}>(args?: Subset<T, payments$payment_typesArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sales<T extends salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, salesDefaultArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'Int'>
    readonly sale_id: FieldRef<"payments", 'Int'>
    readonly payment_type_id: FieldRef<"payments", 'Int'>
    readonly value: FieldRef<"payments", 'Decimal'>
    readonly is_online: FieldRef<"payments", 'Boolean'>
    readonly description: FieldRef<"payments", 'String'>
    readonly currency: FieldRef<"payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments.payment_types
   */
  export type payments$payment_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    where?: payment_typesWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model product_sales
   */

  export type AggregateProduct_sales = {
    _count: Product_salesCountAggregateOutputType | null
    _avg: Product_salesAvgAggregateOutputType | null
    _sum: Product_salesSumAggregateOutputType | null
    _min: Product_salesMinAggregateOutputType | null
    _max: Product_salesMaxAggregateOutputType | null
  }

  export type Product_salesAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    base_price: number | null
    total_price: number | null
  }

  export type Product_salesSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    base_price: number | null
    total_price: number | null
  }

  export type Product_salesMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    base_price: number | null
    total_price: number | null
    observations: string | null
  }

  export type Product_salesMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    base_price: number | null
    total_price: number | null
    observations: string | null
  }

  export type Product_salesCountAggregateOutputType = {
    id: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations: number
    _all: number
  }


  export type Product_salesAvgAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
  }

  export type Product_salesSumAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
  }

  export type Product_salesMinAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
    observations?: true
  }

  export type Product_salesMaxAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
    observations?: true
  }

  export type Product_salesCountAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
    observations?: true
    _all?: true
  }

  export type Product_salesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_sales to aggregate.
     */
    where?: product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_sales to fetch.
     */
    orderBy?: product_salesOrderByWithRelationInput | product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_sales
    **/
    _count?: true | Product_salesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_salesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_salesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_salesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_salesMaxAggregateInputType
  }

  export type GetProduct_salesAggregateType<T extends Product_salesAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_sales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_sales[P]>
      : GetScalarType<T[P], AggregateProduct_sales[P]>
  }




  export type product_salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_salesWhereInput
    orderBy?: product_salesOrderByWithAggregationInput | product_salesOrderByWithAggregationInput[]
    by: Product_salesScalarFieldEnum[] | Product_salesScalarFieldEnum
    having?: product_salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_salesCountAggregateInputType | true
    _avg?: Product_salesAvgAggregateInputType
    _sum?: Product_salesSumAggregateInputType
    _min?: Product_salesMinAggregateInputType
    _max?: Product_salesMaxAggregateInputType
  }

  export type Product_salesGroupByOutputType = {
    id: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations: string | null
    _count: Product_salesCountAggregateOutputType | null
    _avg: Product_salesAvgAggregateOutputType | null
    _sum: Product_salesSumAggregateOutputType | null
    _min: Product_salesMinAggregateOutputType | null
    _max: Product_salesMaxAggregateOutputType | null
  }

  type GetProduct_salesGroupByPayload<T extends product_salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_salesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_salesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_salesGroupByOutputType[P]>
            : GetScalarType<T[P], Product_salesGroupByOutputType[P]>
        }
      >
    >


  export type product_salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    base_price?: boolean
    total_price?: boolean
    observations?: boolean
    item_product_sales?: boolean | product_sales$item_product_salesArgs<ExtArgs>
    products?: boolean | productsDefaultArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
    _count?: boolean | Product_salesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_sales"]>

  export type product_salesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    base_price?: boolean
    total_price?: boolean
    observations?: boolean
    products?: boolean | productsDefaultArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_sales"]>

  export type product_salesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    base_price?: boolean
    total_price?: boolean
    observations?: boolean
    products?: boolean | productsDefaultArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_sales"]>

  export type product_salesSelectScalar = {
    id?: boolean
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    base_price?: boolean
    total_price?: boolean
    observations?: boolean
  }

  export type product_salesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "product_id" | "quantity" | "base_price" | "total_price" | "observations", ExtArgs["result"]["product_sales"]>
  export type product_salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_product_sales?: boolean | product_sales$item_product_salesArgs<ExtArgs>
    products?: boolean | productsDefaultArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
    _count?: boolean | Product_salesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type product_salesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | productsDefaultArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }
  export type product_salesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | productsDefaultArgs<ExtArgs>
    sales?: boolean | salesDefaultArgs<ExtArgs>
  }

  export type $product_salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_sales"
    objects: {
      item_product_sales: Prisma.$item_product_salesPayload<ExtArgs>[]
      products: Prisma.$productsPayload<ExtArgs>
      sales: Prisma.$salesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number
      product_id: number
      quantity: number
      base_price: number
      total_price: number
      observations: string | null
    }, ExtArgs["result"]["product_sales"]>
    composites: {}
  }

  type product_salesGetPayload<S extends boolean | null | undefined | product_salesDefaultArgs> = $Result.GetResult<Prisma.$product_salesPayload, S>

  type product_salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<product_salesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Product_salesCountAggregateInputType | true
    }

  export interface product_salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_sales'], meta: { name: 'product_sales' } }
    /**
     * Find zero or one Product_sales that matches the filter.
     * @param {product_salesFindUniqueArgs} args - Arguments to find a Product_sales
     * @example
     * // Get one Product_sales
     * const product_sales = await prisma.product_sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends product_salesFindUniqueArgs>(args: SelectSubset<T, product_salesFindUniqueArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product_sales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {product_salesFindUniqueOrThrowArgs} args - Arguments to find a Product_sales
     * @example
     * // Get one Product_sales
     * const product_sales = await prisma.product_sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends product_salesFindUniqueOrThrowArgs>(args: SelectSubset<T, product_salesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_salesFindFirstArgs} args - Arguments to find a Product_sales
     * @example
     * // Get one Product_sales
     * const product_sales = await prisma.product_sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends product_salesFindFirstArgs>(args?: SelectSubset<T, product_salesFindFirstArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_salesFindFirstOrThrowArgs} args - Arguments to find a Product_sales
     * @example
     * // Get one Product_sales
     * const product_sales = await prisma.product_sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends product_salesFindFirstOrThrowArgs>(args?: SelectSubset<T, product_salesFindFirstOrThrowArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Product_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_salesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_sales
     * const product_sales = await prisma.product_sales.findMany()
     * 
     * // Get first 10 Product_sales
     * const product_sales = await prisma.product_sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_salesWithIdOnly = await prisma.product_sales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends product_salesFindManyArgs>(args?: SelectSubset<T, product_salesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product_sales.
     * @param {product_salesCreateArgs} args - Arguments to create a Product_sales.
     * @example
     * // Create one Product_sales
     * const Product_sales = await prisma.product_sales.create({
     *   data: {
     *     // ... data to create a Product_sales
     *   }
     * })
     * 
     */
    create<T extends product_salesCreateArgs>(args: SelectSubset<T, product_salesCreateArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Product_sales.
     * @param {product_salesCreateManyArgs} args - Arguments to create many Product_sales.
     * @example
     * // Create many Product_sales
     * const product_sales = await prisma.product_sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends product_salesCreateManyArgs>(args?: SelectSubset<T, product_salesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Product_sales and returns the data saved in the database.
     * @param {product_salesCreateManyAndReturnArgs} args - Arguments to create many Product_sales.
     * @example
     * // Create many Product_sales
     * const product_sales = await prisma.product_sales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Product_sales and only return the `id`
     * const product_salesWithIdOnly = await prisma.product_sales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends product_salesCreateManyAndReturnArgs>(args?: SelectSubset<T, product_salesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product_sales.
     * @param {product_salesDeleteArgs} args - Arguments to delete one Product_sales.
     * @example
     * // Delete one Product_sales
     * const Product_sales = await prisma.product_sales.delete({
     *   where: {
     *     // ... filter to delete one Product_sales
     *   }
     * })
     * 
     */
    delete<T extends product_salesDeleteArgs>(args: SelectSubset<T, product_salesDeleteArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product_sales.
     * @param {product_salesUpdateArgs} args - Arguments to update one Product_sales.
     * @example
     * // Update one Product_sales
     * const product_sales = await prisma.product_sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends product_salesUpdateArgs>(args: SelectSubset<T, product_salesUpdateArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Product_sales.
     * @param {product_salesDeleteManyArgs} args - Arguments to filter Product_sales to delete.
     * @example
     * // Delete a few Product_sales
     * const { count } = await prisma.product_sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends product_salesDeleteManyArgs>(args?: SelectSubset<T, product_salesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_sales
     * const product_sales = await prisma.product_sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends product_salesUpdateManyArgs>(args: SelectSubset<T, product_salesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_sales and returns the data updated in the database.
     * @param {product_salesUpdateManyAndReturnArgs} args - Arguments to update many Product_sales.
     * @example
     * // Update many Product_sales
     * const product_sales = await prisma.product_sales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Product_sales and only return the `id`
     * const product_salesWithIdOnly = await prisma.product_sales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends product_salesUpdateManyAndReturnArgs>(args: SelectSubset<T, product_salesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product_sales.
     * @param {product_salesUpsertArgs} args - Arguments to update or create a Product_sales.
     * @example
     * // Update or create a Product_sales
     * const product_sales = await prisma.product_sales.upsert({
     *   create: {
     *     // ... data to create a Product_sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_sales we want to update
     *   }
     * })
     */
    upsert<T extends product_salesUpsertArgs>(args: SelectSubset<T, product_salesUpsertArgs<ExtArgs>>): Prisma__product_salesClient<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_salesCountArgs} args - Arguments to filter Product_sales to count.
     * @example
     * // Count the number of Product_sales
     * const count = await prisma.product_sales.count({
     *   where: {
     *     // ... the filter for the Product_sales we want to count
     *   }
     * })
    **/
    count<T extends product_salesCountArgs>(
      args?: Subset<T, product_salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_salesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_salesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_salesAggregateArgs>(args: Subset<T, Product_salesAggregateArgs>): Prisma.PrismaPromise<GetProduct_salesAggregateType<T>>

    /**
     * Group by Product_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_salesGroupByArgs['orderBy'] }
        : { orderBy?: product_salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_salesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_sales model
   */
  readonly fields: product_salesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item_product_sales<T extends product_sales$item_product_salesArgs<ExtArgs> = {}>(args?: Subset<T, product_sales$item_product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productsDefaultArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sales<T extends salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, salesDefaultArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product_sales model
   */
  interface product_salesFieldRefs {
    readonly id: FieldRef<"product_sales", 'Int'>
    readonly sale_id: FieldRef<"product_sales", 'Int'>
    readonly product_id: FieldRef<"product_sales", 'Int'>
    readonly quantity: FieldRef<"product_sales", 'Float'>
    readonly base_price: FieldRef<"product_sales", 'Float'>
    readonly total_price: FieldRef<"product_sales", 'Float'>
    readonly observations: FieldRef<"product_sales", 'String'>
  }
    

  // Custom InputTypes
  /**
   * product_sales findUnique
   */
  export type product_salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * Filter, which product_sales to fetch.
     */
    where: product_salesWhereUniqueInput
  }

  /**
   * product_sales findUniqueOrThrow
   */
  export type product_salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * Filter, which product_sales to fetch.
     */
    where: product_salesWhereUniqueInput
  }

  /**
   * product_sales findFirst
   */
  export type product_salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * Filter, which product_sales to fetch.
     */
    where?: product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_sales to fetch.
     */
    orderBy?: product_salesOrderByWithRelationInput | product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_sales.
     */
    cursor?: product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_sales.
     */
    distinct?: Product_salesScalarFieldEnum | Product_salesScalarFieldEnum[]
  }

  /**
   * product_sales findFirstOrThrow
   */
  export type product_salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * Filter, which product_sales to fetch.
     */
    where?: product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_sales to fetch.
     */
    orderBy?: product_salesOrderByWithRelationInput | product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_sales.
     */
    cursor?: product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_sales.
     */
    distinct?: Product_salesScalarFieldEnum | Product_salesScalarFieldEnum[]
  }

  /**
   * product_sales findMany
   */
  export type product_salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * Filter, which product_sales to fetch.
     */
    where?: product_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_sales to fetch.
     */
    orderBy?: product_salesOrderByWithRelationInput | product_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_sales.
     */
    cursor?: product_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_sales.
     */
    skip?: number
    distinct?: Product_salesScalarFieldEnum | Product_salesScalarFieldEnum[]
  }

  /**
   * product_sales create
   */
  export type product_salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * The data needed to create a product_sales.
     */
    data: XOR<product_salesCreateInput, product_salesUncheckedCreateInput>
  }

  /**
   * product_sales createMany
   */
  export type product_salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_sales.
     */
    data: product_salesCreateManyInput | product_salesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product_sales createManyAndReturn
   */
  export type product_salesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * The data used to create many product_sales.
     */
    data: product_salesCreateManyInput | product_salesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * product_sales update
   */
  export type product_salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * The data needed to update a product_sales.
     */
    data: XOR<product_salesUpdateInput, product_salesUncheckedUpdateInput>
    /**
     * Choose, which product_sales to update.
     */
    where: product_salesWhereUniqueInput
  }

  /**
   * product_sales updateMany
   */
  export type product_salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_sales.
     */
    data: XOR<product_salesUpdateManyMutationInput, product_salesUncheckedUpdateManyInput>
    /**
     * Filter which product_sales to update
     */
    where?: product_salesWhereInput
    /**
     * Limit how many product_sales to update.
     */
    limit?: number
  }

  /**
   * product_sales updateManyAndReturn
   */
  export type product_salesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * The data used to update product_sales.
     */
    data: XOR<product_salesUpdateManyMutationInput, product_salesUncheckedUpdateManyInput>
    /**
     * Filter which product_sales to update
     */
    where?: product_salesWhereInput
    /**
     * Limit how many product_sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * product_sales upsert
   */
  export type product_salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * The filter to search for the product_sales to update in case it exists.
     */
    where: product_salesWhereUniqueInput
    /**
     * In case the product_sales found by the `where` argument doesn't exist, create a new product_sales with this data.
     */
    create: XOR<product_salesCreateInput, product_salesUncheckedCreateInput>
    /**
     * In case the product_sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_salesUpdateInput, product_salesUncheckedUpdateInput>
  }

  /**
   * product_sales delete
   */
  export type product_salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    /**
     * Filter which product_sales to delete.
     */
    where: product_salesWhereUniqueInput
  }

  /**
   * product_sales deleteMany
   */
  export type product_salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_sales to delete
     */
    where?: product_salesWhereInput
    /**
     * Limit how many product_sales to delete.
     */
    limit?: number
  }

  /**
   * product_sales.item_product_sales
   */
  export type product_sales$item_product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_product_sales
     */
    select?: item_product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_product_sales
     */
    omit?: item_product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: item_product_salesInclude<ExtArgs> | null
    where?: item_product_salesWhereInput
    orderBy?: item_product_salesOrderByWithRelationInput | item_product_salesOrderByWithRelationInput[]
    cursor?: item_product_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Item_product_salesScalarFieldEnum | Item_product_salesScalarFieldEnum[]
  }

  /**
   * product_sales without action
   */
  export type product_salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    category_id: number
    name: number
    pos_uuid: number
    deleted_at: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: number
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string
    pos_uuid: string | null
    deleted_at: Date | null
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    product_sales?: boolean | products$product_salesArgs<ExtArgs>
    brands?: boolean | products$brandsArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
    sub_brands?: boolean | products$sub_brandsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | products$brandsArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
    sub_brands?: boolean | products$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brands?: boolean | products$brandsArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
    sub_brands?: boolean | products$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
  }

  export type productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "category_id" | "name" | "pos_uuid" | "deleted_at", ExtArgs["result"]["products"]>
  export type productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_sales?: boolean | products$product_salesArgs<ExtArgs>
    brands?: boolean | products$brandsArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
    sub_brands?: boolean | products$sub_brandsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | products$brandsArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
    sub_brands?: boolean | products$sub_brandsArgs<ExtArgs>
  }
  export type productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | products$brandsArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
    sub_brands?: boolean | products$sub_brandsArgs<ExtArgs>
  }

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {
      product_sales: Prisma.$product_salesPayload<ExtArgs>[]
      brands: Prisma.$brandsPayload<ExtArgs> | null
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      sub_brands: Prisma.$sub_brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      sub_brand_id: number | null
      category_id: number | null
      name: string
      pos_uuid: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productsCreateManyAndReturnArgs>(args?: SelectSubset<T, productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productsUpdateManyAndReturnArgs>(args: SelectSubset<T, productsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product_sales<T extends products$product_salesArgs<ExtArgs> = {}>(args?: Subset<T, products$product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    brands<T extends products$brandsArgs<ExtArgs> = {}>(args?: Subset<T, products$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    categories<T extends products$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, products$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sub_brands<T extends products$sub_brandsArgs<ExtArgs> = {}>(args?: Subset<T, products$sub_brandsArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */
  interface productsFieldRefs {
    readonly id: FieldRef<"products", 'Int'>
    readonly brand_id: FieldRef<"products", 'Int'>
    readonly sub_brand_id: FieldRef<"products", 'Int'>
    readonly category_id: FieldRef<"products", 'Int'>
    readonly name: FieldRef<"products", 'String'>
    readonly pos_uuid: FieldRef<"products", 'String'>
    readonly deleted_at: FieldRef<"products", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products createManyAndReturn
   */
  export type productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * products updateManyAndReturn
   */
  export type productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * products.product_sales
   */
  export type products$product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    where?: product_salesWhereInput
    orderBy?: product_salesOrderByWithRelationInput | product_salesOrderByWithRelationInput[]
    cursor?: product_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_salesScalarFieldEnum | Product_salesScalarFieldEnum[]
  }

  /**
   * products.brands
   */
  export type products$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * products.categories
   */
  export type products$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * products.sub_brands
   */
  export type products$sub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    where?: sub_brandsWhereInput
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
  }


  /**
   * Model sales
   */

  export type AggregateSales = {
    _count: SalesCountAggregateOutputType | null
    _avg: SalesAvgAggregateOutputType | null
    _sum: SalesSumAggregateOutputType | null
    _min: SalesMinAggregateOutputType | null
    _max: SalesMaxAggregateOutputType | null
  }

  export type SalesAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number | null
    total_amount_items: Decimal | null
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal | null
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
  }

  export type SalesSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number | null
    total_amount_items: Decimal | null
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal | null
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
  }

  export type SalesMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number | null
    cod_sale1: string | null
    cod_sale2: string | null
    created_at: Date | null
    customer_name: string | null
    sale_status_desc: string | null
    total_amount_items: Decimal | null
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal | null
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
    discount_reason: string | null
    increase_reason: string | null
    origin: string | null
  }

  export type SalesMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number | null
    cod_sale1: string | null
    cod_sale2: string | null
    created_at: Date | null
    customer_name: string | null
    sale_status_desc: string | null
    total_amount_items: Decimal | null
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal | null
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
    discount_reason: string | null
    increase_reason: string | null
    origin: string | null
  }

  export type SalesCountAggregateOutputType = {
    id: number
    store_id: number
    sub_brand_id: number
    customer_id: number
    channel_id: number
    cod_sale1: number
    cod_sale2: number
    created_at: number
    customer_name: number
    sale_status_desc: number
    total_amount_items: number
    total_discount: number
    total_increase: number
    delivery_fee: number
    service_tax_fee: number
    total_amount: number
    value_paid: number
    production_seconds: number
    delivery_seconds: number
    people_quantity: number
    discount_reason: number
    increase_reason: number
    origin: number
    _all: number
  }


  export type SalesAvgAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
  }

  export type SalesSumAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
  }

  export type SalesMinAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    cod_sale1?: true
    cod_sale2?: true
    created_at?: true
    customer_name?: true
    sale_status_desc?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
    discount_reason?: true
    increase_reason?: true
    origin?: true
  }

  export type SalesMaxAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    cod_sale1?: true
    cod_sale2?: true
    created_at?: true
    customer_name?: true
    sale_status_desc?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
    discount_reason?: true
    increase_reason?: true
    origin?: true
  }

  export type SalesCountAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    cod_sale1?: true
    cod_sale2?: true
    created_at?: true
    customer_name?: true
    sale_status_desc?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
    discount_reason?: true
    increase_reason?: true
    origin?: true
    _all?: true
  }

  export type SalesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales to aggregate.
     */
    where?: salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sales
    **/
    _count?: true | SalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesMaxAggregateInputType
  }

  export type GetSalesAggregateType<T extends SalesAggregateArgs> = {
        [P in keyof T & keyof AggregateSales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSales[P]>
      : GetScalarType<T[P], AggregateSales[P]>
  }




  export type salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salesWhereInput
    orderBy?: salesOrderByWithAggregationInput | salesOrderByWithAggregationInput[]
    by: SalesScalarFieldEnum[] | SalesScalarFieldEnum
    having?: salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesCountAggregateInputType | true
    _avg?: SalesAvgAggregateInputType
    _sum?: SalesSumAggregateInputType
    _min?: SalesMinAggregateInputType
    _max?: SalesMaxAggregateInputType
  }

  export type SalesGroupByOutputType = {
    id: number
    store_id: number
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number
    cod_sale1: string | null
    cod_sale2: string | null
    created_at: Date
    customer_name: string | null
    sale_status_desc: string
    total_amount_items: Decimal
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
    discount_reason: string | null
    increase_reason: string | null
    origin: string | null
    _count: SalesCountAggregateOutputType | null
    _avg: SalesAvgAggregateOutputType | null
    _sum: SalesSumAggregateOutputType | null
    _min: SalesMinAggregateOutputType | null
    _max: SalesMaxAggregateOutputType | null
  }

  type GetSalesGroupByPayload<T extends salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesGroupByOutputType[P]>
            : GetScalarType<T[P], SalesGroupByOutputType[P]>
        }
      >
    >


  export type salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    customer_id?: boolean
    channel_id?: boolean
    cod_sale1?: boolean
    cod_sale2?: boolean
    created_at?: boolean
    customer_name?: boolean
    sale_status_desc?: boolean
    total_amount_items?: boolean
    total_discount?: boolean
    total_increase?: boolean
    delivery_fee?: boolean
    service_tax_fee?: boolean
    total_amount?: boolean
    value_paid?: boolean
    production_seconds?: boolean
    delivery_seconds?: boolean
    people_quantity?: boolean
    discount_reason?: boolean
    increase_reason?: boolean
    origin?: boolean
    coupon_sales?: boolean | sales$coupon_salesArgs<ExtArgs>
    delivery_addresses?: boolean | sales$delivery_addressesArgs<ExtArgs>
    delivery_sales?: boolean | sales$delivery_salesArgs<ExtArgs>
    payments?: boolean | sales$paymentsArgs<ExtArgs>
    product_sales?: boolean | sales$product_salesArgs<ExtArgs>
    channels?: boolean | channelsDefaultArgs<ExtArgs>
    customers?: boolean | sales$customersArgs<ExtArgs>
    stores?: boolean | storesDefaultArgs<ExtArgs>
    sub_brands?: boolean | sales$sub_brandsArgs<ExtArgs>
    _count?: boolean | SalesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sales"]>

  export type salesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    customer_id?: boolean
    channel_id?: boolean
    cod_sale1?: boolean
    cod_sale2?: boolean
    created_at?: boolean
    customer_name?: boolean
    sale_status_desc?: boolean
    total_amount_items?: boolean
    total_discount?: boolean
    total_increase?: boolean
    delivery_fee?: boolean
    service_tax_fee?: boolean
    total_amount?: boolean
    value_paid?: boolean
    production_seconds?: boolean
    delivery_seconds?: boolean
    people_quantity?: boolean
    discount_reason?: boolean
    increase_reason?: boolean
    origin?: boolean
    channels?: boolean | channelsDefaultArgs<ExtArgs>
    customers?: boolean | sales$customersArgs<ExtArgs>
    stores?: boolean | storesDefaultArgs<ExtArgs>
    sub_brands?: boolean | sales$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["sales"]>

  export type salesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    customer_id?: boolean
    channel_id?: boolean
    cod_sale1?: boolean
    cod_sale2?: boolean
    created_at?: boolean
    customer_name?: boolean
    sale_status_desc?: boolean
    total_amount_items?: boolean
    total_discount?: boolean
    total_increase?: boolean
    delivery_fee?: boolean
    service_tax_fee?: boolean
    total_amount?: boolean
    value_paid?: boolean
    production_seconds?: boolean
    delivery_seconds?: boolean
    people_quantity?: boolean
    discount_reason?: boolean
    increase_reason?: boolean
    origin?: boolean
    channels?: boolean | channelsDefaultArgs<ExtArgs>
    customers?: boolean | sales$customersArgs<ExtArgs>
    stores?: boolean | storesDefaultArgs<ExtArgs>
    sub_brands?: boolean | sales$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["sales"]>

  export type salesSelectScalar = {
    id?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    customer_id?: boolean
    channel_id?: boolean
    cod_sale1?: boolean
    cod_sale2?: boolean
    created_at?: boolean
    customer_name?: boolean
    sale_status_desc?: boolean
    total_amount_items?: boolean
    total_discount?: boolean
    total_increase?: boolean
    delivery_fee?: boolean
    service_tax_fee?: boolean
    total_amount?: boolean
    value_paid?: boolean
    production_seconds?: boolean
    delivery_seconds?: boolean
    people_quantity?: boolean
    discount_reason?: boolean
    increase_reason?: boolean
    origin?: boolean
  }

  export type salesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "store_id" | "sub_brand_id" | "customer_id" | "channel_id" | "cod_sale1" | "cod_sale2" | "created_at" | "customer_name" | "sale_status_desc" | "total_amount_items" | "total_discount" | "total_increase" | "delivery_fee" | "service_tax_fee" | "total_amount" | "value_paid" | "production_seconds" | "delivery_seconds" | "people_quantity" | "discount_reason" | "increase_reason" | "origin", ExtArgs["result"]["sales"]>
  export type salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon_sales?: boolean | sales$coupon_salesArgs<ExtArgs>
    delivery_addresses?: boolean | sales$delivery_addressesArgs<ExtArgs>
    delivery_sales?: boolean | sales$delivery_salesArgs<ExtArgs>
    payments?: boolean | sales$paymentsArgs<ExtArgs>
    product_sales?: boolean | sales$product_salesArgs<ExtArgs>
    channels?: boolean | channelsDefaultArgs<ExtArgs>
    customers?: boolean | sales$customersArgs<ExtArgs>
    stores?: boolean | storesDefaultArgs<ExtArgs>
    sub_brands?: boolean | sales$sub_brandsArgs<ExtArgs>
    _count?: boolean | SalesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type salesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channels?: boolean | channelsDefaultArgs<ExtArgs>
    customers?: boolean | sales$customersArgs<ExtArgs>
    stores?: boolean | storesDefaultArgs<ExtArgs>
    sub_brands?: boolean | sales$sub_brandsArgs<ExtArgs>
  }
  export type salesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channels?: boolean | channelsDefaultArgs<ExtArgs>
    customers?: boolean | sales$customersArgs<ExtArgs>
    stores?: boolean | storesDefaultArgs<ExtArgs>
    sub_brands?: boolean | sales$sub_brandsArgs<ExtArgs>
  }

  export type $salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sales"
    objects: {
      coupon_sales: Prisma.$coupon_salesPayload<ExtArgs>[]
      delivery_addresses: Prisma.$delivery_addressesPayload<ExtArgs>[]
      delivery_sales: Prisma.$delivery_salesPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      product_sales: Prisma.$product_salesPayload<ExtArgs>[]
      channels: Prisma.$channelsPayload<ExtArgs>
      customers: Prisma.$customersPayload<ExtArgs> | null
      stores: Prisma.$storesPayload<ExtArgs>
      sub_brands: Prisma.$sub_brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      sub_brand_id: number | null
      customer_id: number | null
      channel_id: number
      cod_sale1: string | null
      cod_sale2: string | null
      created_at: Date
      customer_name: string | null
      sale_status_desc: string
      total_amount_items: Prisma.Decimal
      total_discount: Prisma.Decimal | null
      total_increase: Prisma.Decimal | null
      delivery_fee: Prisma.Decimal | null
      service_tax_fee: Prisma.Decimal | null
      total_amount: Prisma.Decimal
      value_paid: Prisma.Decimal | null
      production_seconds: number | null
      delivery_seconds: number | null
      people_quantity: number | null
      discount_reason: string | null
      increase_reason: string | null
      origin: string | null
    }, ExtArgs["result"]["sales"]>
    composites: {}
  }

  type salesGetPayload<S extends boolean | null | undefined | salesDefaultArgs> = $Result.GetResult<Prisma.$salesPayload, S>

  type salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<salesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesCountAggregateInputType | true
    }

  export interface salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sales'], meta: { name: 'sales' } }
    /**
     * Find zero or one Sales that matches the filter.
     * @param {salesFindUniqueArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends salesFindUniqueArgs>(args: SelectSubset<T, salesFindUniqueArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {salesFindUniqueOrThrowArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends salesFindUniqueOrThrowArgs>(args: SelectSubset<T, salesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesFindFirstArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends salesFindFirstArgs>(args?: SelectSubset<T, salesFindFirstArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesFindFirstOrThrowArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends salesFindFirstOrThrowArgs>(args?: SelectSubset<T, salesFindFirstOrThrowArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sales.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesWithIdOnly = await prisma.sales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends salesFindManyArgs>(args?: SelectSubset<T, salesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sales.
     * @param {salesCreateArgs} args - Arguments to create a Sales.
     * @example
     * // Create one Sales
     * const Sales = await prisma.sales.create({
     *   data: {
     *     // ... data to create a Sales
     *   }
     * })
     * 
     */
    create<T extends salesCreateArgs>(args: SelectSubset<T, salesCreateArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {salesCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sales = await prisma.sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends salesCreateManyArgs>(args?: SelectSubset<T, salesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {salesCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sales = await prisma.sales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const salesWithIdOnly = await prisma.sales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends salesCreateManyAndReturnArgs>(args?: SelectSubset<T, salesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sales.
     * @param {salesDeleteArgs} args - Arguments to delete one Sales.
     * @example
     * // Delete one Sales
     * const Sales = await prisma.sales.delete({
     *   where: {
     *     // ... filter to delete one Sales
     *   }
     * })
     * 
     */
    delete<T extends salesDeleteArgs>(args: SelectSubset<T, salesDeleteArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sales.
     * @param {salesUpdateArgs} args - Arguments to update one Sales.
     * @example
     * // Update one Sales
     * const sales = await prisma.sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends salesUpdateArgs>(args: SelectSubset<T, salesUpdateArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {salesDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends salesDeleteManyArgs>(args?: SelectSubset<T, salesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sales = await prisma.sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends salesUpdateManyArgs>(args: SelectSubset<T, salesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {salesUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sales = await prisma.sales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const salesWithIdOnly = await prisma.sales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends salesUpdateManyAndReturnArgs>(args: SelectSubset<T, salesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sales.
     * @param {salesUpsertArgs} args - Arguments to update or create a Sales.
     * @example
     * // Update or create a Sales
     * const sales = await prisma.sales.upsert({
     *   create: {
     *     // ... data to create a Sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sales we want to update
     *   }
     * })
     */
    upsert<T extends salesUpsertArgs>(args: SelectSubset<T, salesUpsertArgs<ExtArgs>>): Prisma__salesClient<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sales.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends salesCountArgs>(
      args?: Subset<T, salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesAggregateArgs>(args: Subset<T, SalesAggregateArgs>): Prisma.PrismaPromise<GetSalesAggregateType<T>>

    /**
     * Group by Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: salesGroupByArgs['orderBy'] }
        : { orderBy?: salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sales model
   */
  readonly fields: salesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coupon_sales<T extends sales$coupon_salesArgs<ExtArgs> = {}>(args?: Subset<T, sales$coupon_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coupon_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    delivery_addresses<T extends sales$delivery_addressesArgs<ExtArgs> = {}>(args?: Subset<T, sales$delivery_addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_addressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    delivery_sales<T extends sales$delivery_salesArgs<ExtArgs> = {}>(args?: Subset<T, sales$delivery_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delivery_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends sales$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, sales$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product_sales<T extends sales$product_salesArgs<ExtArgs> = {}>(args?: Subset<T, sales$product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    channels<T extends channelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, channelsDefaultArgs<ExtArgs>>): Prisma__channelsClient<$Result.GetResult<Prisma.$channelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customers<T extends sales$customersArgs<ExtArgs> = {}>(args?: Subset<T, sales$customersArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stores<T extends storesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, storesDefaultArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sub_brands<T extends sales$sub_brandsArgs<ExtArgs> = {}>(args?: Subset<T, sales$sub_brandsArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sales model
   */
  interface salesFieldRefs {
    readonly id: FieldRef<"sales", 'Int'>
    readonly store_id: FieldRef<"sales", 'Int'>
    readonly sub_brand_id: FieldRef<"sales", 'Int'>
    readonly customer_id: FieldRef<"sales", 'Int'>
    readonly channel_id: FieldRef<"sales", 'Int'>
    readonly cod_sale1: FieldRef<"sales", 'String'>
    readonly cod_sale2: FieldRef<"sales", 'String'>
    readonly created_at: FieldRef<"sales", 'DateTime'>
    readonly customer_name: FieldRef<"sales", 'String'>
    readonly sale_status_desc: FieldRef<"sales", 'String'>
    readonly total_amount_items: FieldRef<"sales", 'Decimal'>
    readonly total_discount: FieldRef<"sales", 'Decimal'>
    readonly total_increase: FieldRef<"sales", 'Decimal'>
    readonly delivery_fee: FieldRef<"sales", 'Decimal'>
    readonly service_tax_fee: FieldRef<"sales", 'Decimal'>
    readonly total_amount: FieldRef<"sales", 'Decimal'>
    readonly value_paid: FieldRef<"sales", 'Decimal'>
    readonly production_seconds: FieldRef<"sales", 'Int'>
    readonly delivery_seconds: FieldRef<"sales", 'Int'>
    readonly people_quantity: FieldRef<"sales", 'Int'>
    readonly discount_reason: FieldRef<"sales", 'String'>
    readonly increase_reason: FieldRef<"sales", 'String'>
    readonly origin: FieldRef<"sales", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sales findUnique
   */
  export type salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where: salesWhereUniqueInput
  }

  /**
   * sales findUniqueOrThrow
   */
  export type salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where: salesWhereUniqueInput
  }

  /**
   * sales findFirst
   */
  export type salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where?: salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales.
     */
    cursor?: salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales.
     */
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * sales findFirstOrThrow
   */
  export type salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where?: salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales.
     */
    cursor?: salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales.
     */
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * sales findMany
   */
  export type salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where?: salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sales.
     */
    cursor?: salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * sales create
   */
  export type salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * The data needed to create a sales.
     */
    data: XOR<salesCreateInput, salesUncheckedCreateInput>
  }

  /**
   * sales createMany
   */
  export type salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sales.
     */
    data: salesCreateManyInput | salesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sales createManyAndReturn
   */
  export type salesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * The data used to create many sales.
     */
    data: salesCreateManyInput | salesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sales update
   */
  export type salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * The data needed to update a sales.
     */
    data: XOR<salesUpdateInput, salesUncheckedUpdateInput>
    /**
     * Choose, which sales to update.
     */
    where: salesWhereUniqueInput
  }

  /**
   * sales updateMany
   */
  export type salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sales.
     */
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyInput>
    /**
     * Filter which sales to update
     */
    where?: salesWhereInput
    /**
     * Limit how many sales to update.
     */
    limit?: number
  }

  /**
   * sales updateManyAndReturn
   */
  export type salesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * The data used to update sales.
     */
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyInput>
    /**
     * Filter which sales to update
     */
    where?: salesWhereInput
    /**
     * Limit how many sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sales upsert
   */
  export type salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * The filter to search for the sales to update in case it exists.
     */
    where: salesWhereUniqueInput
    /**
     * In case the sales found by the `where` argument doesn't exist, create a new sales with this data.
     */
    create: XOR<salesCreateInput, salesUncheckedCreateInput>
    /**
     * In case the sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<salesUpdateInput, salesUncheckedUpdateInput>
  }

  /**
   * sales delete
   */
  export type salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    /**
     * Filter which sales to delete.
     */
    where: salesWhereUniqueInput
  }

  /**
   * sales deleteMany
   */
  export type salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales to delete
     */
    where?: salesWhereInput
    /**
     * Limit how many sales to delete.
     */
    limit?: number
  }

  /**
   * sales.coupon_sales
   */
  export type sales$coupon_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon_sales
     */
    select?: coupon_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon_sales
     */
    omit?: coupon_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coupon_salesInclude<ExtArgs> | null
    where?: coupon_salesWhereInput
    orderBy?: coupon_salesOrderByWithRelationInput | coupon_salesOrderByWithRelationInput[]
    cursor?: coupon_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Coupon_salesScalarFieldEnum | Coupon_salesScalarFieldEnum[]
  }

  /**
   * sales.delivery_addresses
   */
  export type sales$delivery_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_addresses
     */
    select?: delivery_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_addresses
     */
    omit?: delivery_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_addressesInclude<ExtArgs> | null
    where?: delivery_addressesWhereInput
    orderBy?: delivery_addressesOrderByWithRelationInput | delivery_addressesOrderByWithRelationInput[]
    cursor?: delivery_addressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Delivery_addressesScalarFieldEnum | Delivery_addressesScalarFieldEnum[]
  }

  /**
   * sales.delivery_sales
   */
  export type sales$delivery_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delivery_sales
     */
    select?: delivery_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delivery_sales
     */
    omit?: delivery_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: delivery_salesInclude<ExtArgs> | null
    where?: delivery_salesWhereInput
    orderBy?: delivery_salesOrderByWithRelationInput | delivery_salesOrderByWithRelationInput[]
    cursor?: delivery_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Delivery_salesScalarFieldEnum | Delivery_salesScalarFieldEnum[]
  }

  /**
   * sales.payments
   */
  export type sales$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * sales.product_sales
   */
  export type sales$product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_sales
     */
    select?: product_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_sales
     */
    omit?: product_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_salesInclude<ExtArgs> | null
    where?: product_salesWhereInput
    orderBy?: product_salesOrderByWithRelationInput | product_salesOrderByWithRelationInput[]
    cursor?: product_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_salesScalarFieldEnum | Product_salesScalarFieldEnum[]
  }

  /**
   * sales.customers
   */
  export type sales$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    where?: customersWhereInput
  }

  /**
   * sales.sub_brands
   */
  export type sales$sub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    where?: sub_brandsWhereInput
  }

  /**
   * sales without action
   */
  export type salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
  }


  /**
   * Model stores
   */

  export type AggregateStores = {
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  export type StoresAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    address_number: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type StoresSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    address_number: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type StoresMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    name: string | null
    city: string | null
    state: string | null
    district: string | null
    address_street: string | null
    address_number: number | null
    zipcode: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    is_active: boolean | null
    is_own: boolean | null
    is_holding: boolean | null
    creation_date: Date | null
    created_at: Date | null
  }

  export type StoresMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    name: string | null
    city: string | null
    state: string | null
    district: string | null
    address_street: string | null
    address_number: number | null
    zipcode: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    is_active: boolean | null
    is_own: boolean | null
    is_holding: boolean | null
    creation_date: Date | null
    created_at: Date | null
  }

  export type StoresCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    name: number
    city: number
    state: number
    district: number
    address_street: number
    address_number: number
    zipcode: number
    latitude: number
    longitude: number
    is_active: number
    is_own: number
    is_holding: number
    creation_date: number
    created_at: number
    _all: number
  }


  export type StoresAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    address_number?: true
    latitude?: true
    longitude?: true
  }

  export type StoresSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    address_number?: true
    latitude?: true
    longitude?: true
  }

  export type StoresMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    city?: true
    state?: true
    district?: true
    address_street?: true
    address_number?: true
    zipcode?: true
    latitude?: true
    longitude?: true
    is_active?: true
    is_own?: true
    is_holding?: true
    creation_date?: true
    created_at?: true
  }

  export type StoresMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    city?: true
    state?: true
    district?: true
    address_street?: true
    address_number?: true
    zipcode?: true
    latitude?: true
    longitude?: true
    is_active?: true
    is_own?: true
    is_holding?: true
    creation_date?: true
    created_at?: true
  }

  export type StoresCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    city?: true
    state?: true
    district?: true
    address_street?: true
    address_number?: true
    zipcode?: true
    latitude?: true
    longitude?: true
    is_active?: true
    is_own?: true
    is_holding?: true
    creation_date?: true
    created_at?: true
    _all?: true
  }

  export type StoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stores to aggregate.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stores
    **/
    _count?: true | StoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoresMaxAggregateInputType
  }

  export type GetStoresAggregateType<T extends StoresAggregateArgs> = {
        [P in keyof T & keyof AggregateStores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStores[P]>
      : GetScalarType<T[P], AggregateStores[P]>
  }




  export type storesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storesWhereInput
    orderBy?: storesOrderByWithAggregationInput | storesOrderByWithAggregationInput[]
    by: StoresScalarFieldEnum[] | StoresScalarFieldEnum
    having?: storesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoresCountAggregateInputType | true
    _avg?: StoresAvgAggregateInputType
    _sum?: StoresSumAggregateInputType
    _min?: StoresMinAggregateInputType
    _max?: StoresMaxAggregateInputType
  }

  export type StoresGroupByOutputType = {
    id: number
    brand_id: number | null
    sub_brand_id: number | null
    name: string
    city: string | null
    state: string | null
    district: string | null
    address_street: string | null
    address_number: number | null
    zipcode: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    is_active: boolean | null
    is_own: boolean | null
    is_holding: boolean | null
    creation_date: Date | null
    created_at: Date | null
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  type GetStoresGroupByPayload<T extends storesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoresGroupByOutputType[P]>
            : GetScalarType<T[P], StoresGroupByOutputType[P]>
        }
      >
    >


  export type storesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    district?: boolean
    address_street?: boolean
    address_number?: boolean
    zipcode?: boolean
    latitude?: boolean
    longitude?: boolean
    is_active?: boolean
    is_own?: boolean
    is_holding?: boolean
    creation_date?: boolean
    created_at?: boolean
    customers?: boolean | stores$customersArgs<ExtArgs>
    sales?: boolean | stores$salesArgs<ExtArgs>
    brands?: boolean | stores$brandsArgs<ExtArgs>
    sub_brands?: boolean | stores$sub_brandsArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores"]>

  export type storesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    district?: boolean
    address_street?: boolean
    address_number?: boolean
    zipcode?: boolean
    latitude?: boolean
    longitude?: boolean
    is_active?: boolean
    is_own?: boolean
    is_holding?: boolean
    creation_date?: boolean
    created_at?: boolean
    brands?: boolean | stores$brandsArgs<ExtArgs>
    sub_brands?: boolean | stores$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["stores"]>

  export type storesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    district?: boolean
    address_street?: boolean
    address_number?: boolean
    zipcode?: boolean
    latitude?: boolean
    longitude?: boolean
    is_active?: boolean
    is_own?: boolean
    is_holding?: boolean
    creation_date?: boolean
    created_at?: boolean
    brands?: boolean | stores$brandsArgs<ExtArgs>
    sub_brands?: boolean | stores$sub_brandsArgs<ExtArgs>
  }, ExtArgs["result"]["stores"]>

  export type storesSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    district?: boolean
    address_street?: boolean
    address_number?: boolean
    zipcode?: boolean
    latitude?: boolean
    longitude?: boolean
    is_active?: boolean
    is_own?: boolean
    is_holding?: boolean
    creation_date?: boolean
    created_at?: boolean
  }

  export type storesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "name" | "city" | "state" | "district" | "address_street" | "address_number" | "zipcode" | "latitude" | "longitude" | "is_active" | "is_own" | "is_holding" | "creation_date" | "created_at", ExtArgs["result"]["stores"]>
  export type storesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | stores$customersArgs<ExtArgs>
    sales?: boolean | stores$salesArgs<ExtArgs>
    brands?: boolean | stores$brandsArgs<ExtArgs>
    sub_brands?: boolean | stores$sub_brandsArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type storesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | stores$brandsArgs<ExtArgs>
    sub_brands?: boolean | stores$sub_brandsArgs<ExtArgs>
  }
  export type storesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | stores$brandsArgs<ExtArgs>
    sub_brands?: boolean | stores$sub_brandsArgs<ExtArgs>
  }

  export type $storesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stores"
    objects: {
      customers: Prisma.$customersPayload<ExtArgs>[]
      sales: Prisma.$salesPayload<ExtArgs>[]
      brands: Prisma.$brandsPayload<ExtArgs> | null
      sub_brands: Prisma.$sub_brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      sub_brand_id: number | null
      name: string
      city: string | null
      state: string | null
      district: string | null
      address_street: string | null
      address_number: number | null
      zipcode: string | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      is_active: boolean | null
      is_own: boolean | null
      is_holding: boolean | null
      creation_date: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["stores"]>
    composites: {}
  }

  type storesGetPayload<S extends boolean | null | undefined | storesDefaultArgs> = $Result.GetResult<Prisma.$storesPayload, S>

  type storesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<storesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoresCountAggregateInputType | true
    }

  export interface storesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stores'], meta: { name: 'stores' } }
    /**
     * Find zero or one Stores that matches the filter.
     * @param {storesFindUniqueArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends storesFindUniqueArgs>(args: SelectSubset<T, storesFindUniqueArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {storesFindUniqueOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends storesFindUniqueOrThrowArgs>(args: SelectSubset<T, storesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindFirstArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends storesFindFirstArgs>(args?: SelectSubset<T, storesFindFirstArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindFirstOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends storesFindFirstOrThrowArgs>(args?: SelectSubset<T, storesFindFirstOrThrowArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.stores.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.stores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storesWithIdOnly = await prisma.stores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends storesFindManyArgs>(args?: SelectSubset<T, storesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stores.
     * @param {storesCreateArgs} args - Arguments to create a Stores.
     * @example
     * // Create one Stores
     * const Stores = await prisma.stores.create({
     *   data: {
     *     // ... data to create a Stores
     *   }
     * })
     * 
     */
    create<T extends storesCreateArgs>(args: SelectSubset<T, storesCreateArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {storesCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends storesCreateManyArgs>(args?: SelectSubset<T, storesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {storesCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storesWithIdOnly = await prisma.stores.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends storesCreateManyAndReturnArgs>(args?: SelectSubset<T, storesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stores.
     * @param {storesDeleteArgs} args - Arguments to delete one Stores.
     * @example
     * // Delete one Stores
     * const Stores = await prisma.stores.delete({
     *   where: {
     *     // ... filter to delete one Stores
     *   }
     * })
     * 
     */
    delete<T extends storesDeleteArgs>(args: SelectSubset<T, storesDeleteArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stores.
     * @param {storesUpdateArgs} args - Arguments to update one Stores.
     * @example
     * // Update one Stores
     * const stores = await prisma.stores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends storesUpdateArgs>(args: SelectSubset<T, storesUpdateArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {storesDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.stores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends storesDeleteManyArgs>(args?: SelectSubset<T, storesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends storesUpdateManyArgs>(args: SelectSubset<T, storesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {storesUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storesWithIdOnly = await prisma.stores.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends storesUpdateManyAndReturnArgs>(args: SelectSubset<T, storesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stores.
     * @param {storesUpsertArgs} args - Arguments to update or create a Stores.
     * @example
     * // Update or create a Stores
     * const stores = await prisma.stores.upsert({
     *   create: {
     *     // ... data to create a Stores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stores we want to update
     *   }
     * })
     */
    upsert<T extends storesUpsertArgs>(args: SelectSubset<T, storesUpsertArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.stores.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends storesCountArgs>(
      args?: Subset<T, storesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoresAggregateArgs>(args: Subset<T, StoresAggregateArgs>): Prisma.PrismaPromise<GetStoresAggregateType<T>>

    /**
     * Group by Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends storesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: storesGroupByArgs['orderBy'] }
        : { orderBy?: storesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, storesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stores model
   */
  readonly fields: storesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__storesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends stores$customersArgs<ExtArgs> = {}>(args?: Subset<T, stores$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends stores$salesArgs<ExtArgs> = {}>(args?: Subset<T, stores$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    brands<T extends stores$brandsArgs<ExtArgs> = {}>(args?: Subset<T, stores$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sub_brands<T extends stores$sub_brandsArgs<ExtArgs> = {}>(args?: Subset<T, stores$sub_brandsArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stores model
   */
  interface storesFieldRefs {
    readonly id: FieldRef<"stores", 'Int'>
    readonly brand_id: FieldRef<"stores", 'Int'>
    readonly sub_brand_id: FieldRef<"stores", 'Int'>
    readonly name: FieldRef<"stores", 'String'>
    readonly city: FieldRef<"stores", 'String'>
    readonly state: FieldRef<"stores", 'String'>
    readonly district: FieldRef<"stores", 'String'>
    readonly address_street: FieldRef<"stores", 'String'>
    readonly address_number: FieldRef<"stores", 'Int'>
    readonly zipcode: FieldRef<"stores", 'String'>
    readonly latitude: FieldRef<"stores", 'Decimal'>
    readonly longitude: FieldRef<"stores", 'Decimal'>
    readonly is_active: FieldRef<"stores", 'Boolean'>
    readonly is_own: FieldRef<"stores", 'Boolean'>
    readonly is_holding: FieldRef<"stores", 'Boolean'>
    readonly creation_date: FieldRef<"stores", 'DateTime'>
    readonly created_at: FieldRef<"stores", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * stores findUnique
   */
  export type storesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores findUniqueOrThrow
   */
  export type storesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores findFirst
   */
  export type storesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * stores findFirstOrThrow
   */
  export type storesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * stores findMany
   */
  export type storesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * stores create
   */
  export type storesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * The data needed to create a stores.
     */
    data: XOR<storesCreateInput, storesUncheckedCreateInput>
  }

  /**
   * stores createMany
   */
  export type storesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stores.
     */
    data: storesCreateManyInput | storesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stores createManyAndReturn
   */
  export type storesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * The data used to create many stores.
     */
    data: storesCreateManyInput | storesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * stores update
   */
  export type storesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * The data needed to update a stores.
     */
    data: XOR<storesUpdateInput, storesUncheckedUpdateInput>
    /**
     * Choose, which stores to update.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores updateMany
   */
  export type storesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stores.
     */
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyInput>
    /**
     * Filter which stores to update
     */
    where?: storesWhereInput
    /**
     * Limit how many stores to update.
     */
    limit?: number
  }

  /**
   * stores updateManyAndReturn
   */
  export type storesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * The data used to update stores.
     */
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyInput>
    /**
     * Filter which stores to update
     */
    where?: storesWhereInput
    /**
     * Limit how many stores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * stores upsert
   */
  export type storesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * The filter to search for the stores to update in case it exists.
     */
    where: storesWhereUniqueInput
    /**
     * In case the stores found by the `where` argument doesn't exist, create a new stores with this data.
     */
    create: XOR<storesCreateInput, storesUncheckedCreateInput>
    /**
     * In case the stores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<storesUpdateInput, storesUncheckedUpdateInput>
  }

  /**
   * stores delete
   */
  export type storesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter which stores to delete.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores deleteMany
   */
  export type storesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stores to delete
     */
    where?: storesWhereInput
    /**
     * Limit how many stores to delete.
     */
    limit?: number
  }

  /**
   * stores.customers
   */
  export type stores$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    where?: customersWhereInput
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    cursor?: customersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * stores.sales
   */
  export type stores$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    where?: salesWhereInput
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    cursor?: salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * stores.brands
   */
  export type stores$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * stores.sub_brands
   */
  export type stores$sub_brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    where?: sub_brandsWhereInput
  }

  /**
   * stores without action
   */
  export type storesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
  }


  /**
   * Model sub_brands
   */

  export type AggregateSub_brands = {
    _count: Sub_brandsCountAggregateOutputType | null
    _avg: Sub_brandsAvgAggregateOutputType | null
    _sum: Sub_brandsSumAggregateOutputType | null
    _min: Sub_brandsMinAggregateOutputType | null
    _max: Sub_brandsMaxAggregateOutputType | null
  }

  export type Sub_brandsAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type Sub_brandsSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type Sub_brandsMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type Sub_brandsMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type Sub_brandsCountAggregateOutputType = {
    id: number
    brand_id: number
    name: number
    created_at: number
    _all: number
  }


  export type Sub_brandsAvgAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type Sub_brandsSumAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type Sub_brandsMinAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    created_at?: true
  }

  export type Sub_brandsMaxAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    created_at?: true
  }

  export type Sub_brandsCountAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type Sub_brandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sub_brands to aggregate.
     */
    where?: sub_brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_brands to fetch.
     */
    orderBy?: sub_brandsOrderByWithRelationInput | sub_brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sub_brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sub_brands
    **/
    _count?: true | Sub_brandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sub_brandsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sub_brandsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sub_brandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sub_brandsMaxAggregateInputType
  }

  export type GetSub_brandsAggregateType<T extends Sub_brandsAggregateArgs> = {
        [P in keyof T & keyof AggregateSub_brands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSub_brands[P]>
      : GetScalarType<T[P], AggregateSub_brands[P]>
  }




  export type sub_brandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sub_brandsWhereInput
    orderBy?: sub_brandsOrderByWithAggregationInput | sub_brandsOrderByWithAggregationInput[]
    by: Sub_brandsScalarFieldEnum[] | Sub_brandsScalarFieldEnum
    having?: sub_brandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sub_brandsCountAggregateInputType | true
    _avg?: Sub_brandsAvgAggregateInputType
    _sum?: Sub_brandsSumAggregateInputType
    _min?: Sub_brandsMinAggregateInputType
    _max?: Sub_brandsMaxAggregateInputType
  }

  export type Sub_brandsGroupByOutputType = {
    id: number
    brand_id: number | null
    name: string
    created_at: Date | null
    _count: Sub_brandsCountAggregateOutputType | null
    _avg: Sub_brandsAvgAggregateOutputType | null
    _sum: Sub_brandsSumAggregateOutputType | null
    _min: Sub_brandsMinAggregateOutputType | null
    _max: Sub_brandsMaxAggregateOutputType | null
  }

  type GetSub_brandsGroupByPayload<T extends sub_brandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sub_brandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sub_brandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sub_brandsGroupByOutputType[P]>
            : GetScalarType<T[P], Sub_brandsGroupByOutputType[P]>
        }
      >
    >


  export type sub_brandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    created_at?: boolean
    categories?: boolean | sub_brands$categoriesArgs<ExtArgs>
    customers?: boolean | sub_brands$customersArgs<ExtArgs>
    items?: boolean | sub_brands$itemsArgs<ExtArgs>
    option_groups?: boolean | sub_brands$option_groupsArgs<ExtArgs>
    products?: boolean | sub_brands$productsArgs<ExtArgs>
    sales?: boolean | sub_brands$salesArgs<ExtArgs>
    stores?: boolean | sub_brands$storesArgs<ExtArgs>
    brands?: boolean | sub_brands$brandsArgs<ExtArgs>
    _count?: boolean | Sub_brandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sub_brands"]>

  export type sub_brandsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    created_at?: boolean
    brands?: boolean | sub_brands$brandsArgs<ExtArgs>
  }, ExtArgs["result"]["sub_brands"]>

  export type sub_brandsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    created_at?: boolean
    brands?: boolean | sub_brands$brandsArgs<ExtArgs>
  }, ExtArgs["result"]["sub_brands"]>

  export type sub_brandsSelectScalar = {
    id?: boolean
    brand_id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type sub_brandsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "name" | "created_at", ExtArgs["result"]["sub_brands"]>
  export type sub_brandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | sub_brands$categoriesArgs<ExtArgs>
    customers?: boolean | sub_brands$customersArgs<ExtArgs>
    items?: boolean | sub_brands$itemsArgs<ExtArgs>
    option_groups?: boolean | sub_brands$option_groupsArgs<ExtArgs>
    products?: boolean | sub_brands$productsArgs<ExtArgs>
    sales?: boolean | sub_brands$salesArgs<ExtArgs>
    stores?: boolean | sub_brands$storesArgs<ExtArgs>
    brands?: boolean | sub_brands$brandsArgs<ExtArgs>
    _count?: boolean | Sub_brandsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sub_brandsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | sub_brands$brandsArgs<ExtArgs>
  }
  export type sub_brandsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | sub_brands$brandsArgs<ExtArgs>
  }

  export type $sub_brandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sub_brands"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs>[]
      customers: Prisma.$customersPayload<ExtArgs>[]
      items: Prisma.$itemsPayload<ExtArgs>[]
      option_groups: Prisma.$option_groupsPayload<ExtArgs>[]
      products: Prisma.$productsPayload<ExtArgs>[]
      sales: Prisma.$salesPayload<ExtArgs>[]
      stores: Prisma.$storesPayload<ExtArgs>[]
      brands: Prisma.$brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      name: string
      created_at: Date | null
    }, ExtArgs["result"]["sub_brands"]>
    composites: {}
  }

  type sub_brandsGetPayload<S extends boolean | null | undefined | sub_brandsDefaultArgs> = $Result.GetResult<Prisma.$sub_brandsPayload, S>

  type sub_brandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sub_brandsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sub_brandsCountAggregateInputType | true
    }

  export interface sub_brandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sub_brands'], meta: { name: 'sub_brands' } }
    /**
     * Find zero or one Sub_brands that matches the filter.
     * @param {sub_brandsFindUniqueArgs} args - Arguments to find a Sub_brands
     * @example
     * // Get one Sub_brands
     * const sub_brands = await prisma.sub_brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sub_brandsFindUniqueArgs>(args: SelectSubset<T, sub_brandsFindUniqueArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sub_brands that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sub_brandsFindUniqueOrThrowArgs} args - Arguments to find a Sub_brands
     * @example
     * // Get one Sub_brands
     * const sub_brands = await prisma.sub_brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sub_brandsFindUniqueOrThrowArgs>(args: SelectSubset<T, sub_brandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sub_brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_brandsFindFirstArgs} args - Arguments to find a Sub_brands
     * @example
     * // Get one Sub_brands
     * const sub_brands = await prisma.sub_brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sub_brandsFindFirstArgs>(args?: SelectSubset<T, sub_brandsFindFirstArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sub_brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_brandsFindFirstOrThrowArgs} args - Arguments to find a Sub_brands
     * @example
     * // Get one Sub_brands
     * const sub_brands = await prisma.sub_brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sub_brandsFindFirstOrThrowArgs>(args?: SelectSubset<T, sub_brandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sub_brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_brandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sub_brands
     * const sub_brands = await prisma.sub_brands.findMany()
     * 
     * // Get first 10 Sub_brands
     * const sub_brands = await prisma.sub_brands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sub_brandsWithIdOnly = await prisma.sub_brands.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sub_brandsFindManyArgs>(args?: SelectSubset<T, sub_brandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sub_brands.
     * @param {sub_brandsCreateArgs} args - Arguments to create a Sub_brands.
     * @example
     * // Create one Sub_brands
     * const Sub_brands = await prisma.sub_brands.create({
     *   data: {
     *     // ... data to create a Sub_brands
     *   }
     * })
     * 
     */
    create<T extends sub_brandsCreateArgs>(args: SelectSubset<T, sub_brandsCreateArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sub_brands.
     * @param {sub_brandsCreateManyArgs} args - Arguments to create many Sub_brands.
     * @example
     * // Create many Sub_brands
     * const sub_brands = await prisma.sub_brands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sub_brandsCreateManyArgs>(args?: SelectSubset<T, sub_brandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sub_brands and returns the data saved in the database.
     * @param {sub_brandsCreateManyAndReturnArgs} args - Arguments to create many Sub_brands.
     * @example
     * // Create many Sub_brands
     * const sub_brands = await prisma.sub_brands.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sub_brands and only return the `id`
     * const sub_brandsWithIdOnly = await prisma.sub_brands.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sub_brandsCreateManyAndReturnArgs>(args?: SelectSubset<T, sub_brandsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sub_brands.
     * @param {sub_brandsDeleteArgs} args - Arguments to delete one Sub_brands.
     * @example
     * // Delete one Sub_brands
     * const Sub_brands = await prisma.sub_brands.delete({
     *   where: {
     *     // ... filter to delete one Sub_brands
     *   }
     * })
     * 
     */
    delete<T extends sub_brandsDeleteArgs>(args: SelectSubset<T, sub_brandsDeleteArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sub_brands.
     * @param {sub_brandsUpdateArgs} args - Arguments to update one Sub_brands.
     * @example
     * // Update one Sub_brands
     * const sub_brands = await prisma.sub_brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sub_brandsUpdateArgs>(args: SelectSubset<T, sub_brandsUpdateArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sub_brands.
     * @param {sub_brandsDeleteManyArgs} args - Arguments to filter Sub_brands to delete.
     * @example
     * // Delete a few Sub_brands
     * const { count } = await prisma.sub_brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sub_brandsDeleteManyArgs>(args?: SelectSubset<T, sub_brandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sub_brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_brandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sub_brands
     * const sub_brands = await prisma.sub_brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sub_brandsUpdateManyArgs>(args: SelectSubset<T, sub_brandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sub_brands and returns the data updated in the database.
     * @param {sub_brandsUpdateManyAndReturnArgs} args - Arguments to update many Sub_brands.
     * @example
     * // Update many Sub_brands
     * const sub_brands = await prisma.sub_brands.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sub_brands and only return the `id`
     * const sub_brandsWithIdOnly = await prisma.sub_brands.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sub_brandsUpdateManyAndReturnArgs>(args: SelectSubset<T, sub_brandsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sub_brands.
     * @param {sub_brandsUpsertArgs} args - Arguments to update or create a Sub_brands.
     * @example
     * // Update or create a Sub_brands
     * const sub_brands = await prisma.sub_brands.upsert({
     *   create: {
     *     // ... data to create a Sub_brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sub_brands we want to update
     *   }
     * })
     */
    upsert<T extends sub_brandsUpsertArgs>(args: SelectSubset<T, sub_brandsUpsertArgs<ExtArgs>>): Prisma__sub_brandsClient<$Result.GetResult<Prisma.$sub_brandsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sub_brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_brandsCountArgs} args - Arguments to filter Sub_brands to count.
     * @example
     * // Count the number of Sub_brands
     * const count = await prisma.sub_brands.count({
     *   where: {
     *     // ... the filter for the Sub_brands we want to count
     *   }
     * })
    **/
    count<T extends sub_brandsCountArgs>(
      args?: Subset<T, sub_brandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sub_brandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sub_brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_brandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sub_brandsAggregateArgs>(args: Subset<T, Sub_brandsAggregateArgs>): Prisma.PrismaPromise<GetSub_brandsAggregateType<T>>

    /**
     * Group by Sub_brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_brandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sub_brandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sub_brandsGroupByArgs['orderBy'] }
        : { orderBy?: sub_brandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sub_brandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSub_brandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sub_brands model
   */
  readonly fields: sub_brandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sub_brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sub_brandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends sub_brands$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, sub_brands$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends sub_brands$customersArgs<ExtArgs> = {}>(args?: Subset<T, sub_brands$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends sub_brands$itemsArgs<ExtArgs> = {}>(args?: Subset<T, sub_brands$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    option_groups<T extends sub_brands$option_groupsArgs<ExtArgs> = {}>(args?: Subset<T, sub_brands$option_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends sub_brands$productsArgs<ExtArgs> = {}>(args?: Subset<T, sub_brands$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends sub_brands$salesArgs<ExtArgs> = {}>(args?: Subset<T, sub_brands$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stores<T extends sub_brands$storesArgs<ExtArgs> = {}>(args?: Subset<T, sub_brands$storesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    brands<T extends sub_brands$brandsArgs<ExtArgs> = {}>(args?: Subset<T, sub_brands$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sub_brands model
   */
  interface sub_brandsFieldRefs {
    readonly id: FieldRef<"sub_brands", 'Int'>
    readonly brand_id: FieldRef<"sub_brands", 'Int'>
    readonly name: FieldRef<"sub_brands", 'String'>
    readonly created_at: FieldRef<"sub_brands", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sub_brands findUnique
   */
  export type sub_brandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * Filter, which sub_brands to fetch.
     */
    where: sub_brandsWhereUniqueInput
  }

  /**
   * sub_brands findUniqueOrThrow
   */
  export type sub_brandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * Filter, which sub_brands to fetch.
     */
    where: sub_brandsWhereUniqueInput
  }

  /**
   * sub_brands findFirst
   */
  export type sub_brandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * Filter, which sub_brands to fetch.
     */
    where?: sub_brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_brands to fetch.
     */
    orderBy?: sub_brandsOrderByWithRelationInput | sub_brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_brands.
     */
    cursor?: sub_brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_brands.
     */
    distinct?: Sub_brandsScalarFieldEnum | Sub_brandsScalarFieldEnum[]
  }

  /**
   * sub_brands findFirstOrThrow
   */
  export type sub_brandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * Filter, which sub_brands to fetch.
     */
    where?: sub_brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_brands to fetch.
     */
    orderBy?: sub_brandsOrderByWithRelationInput | sub_brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_brands.
     */
    cursor?: sub_brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_brands.
     */
    distinct?: Sub_brandsScalarFieldEnum | Sub_brandsScalarFieldEnum[]
  }

  /**
   * sub_brands findMany
   */
  export type sub_brandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * Filter, which sub_brands to fetch.
     */
    where?: sub_brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_brands to fetch.
     */
    orderBy?: sub_brandsOrderByWithRelationInput | sub_brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sub_brands.
     */
    cursor?: sub_brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_brands.
     */
    skip?: number
    distinct?: Sub_brandsScalarFieldEnum | Sub_brandsScalarFieldEnum[]
  }

  /**
   * sub_brands create
   */
  export type sub_brandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * The data needed to create a sub_brands.
     */
    data: XOR<sub_brandsCreateInput, sub_brandsUncheckedCreateInput>
  }

  /**
   * sub_brands createMany
   */
  export type sub_brandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sub_brands.
     */
    data: sub_brandsCreateManyInput | sub_brandsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sub_brands createManyAndReturn
   */
  export type sub_brandsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * The data used to create many sub_brands.
     */
    data: sub_brandsCreateManyInput | sub_brandsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sub_brands update
   */
  export type sub_brandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * The data needed to update a sub_brands.
     */
    data: XOR<sub_brandsUpdateInput, sub_brandsUncheckedUpdateInput>
    /**
     * Choose, which sub_brands to update.
     */
    where: sub_brandsWhereUniqueInput
  }

  /**
   * sub_brands updateMany
   */
  export type sub_brandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sub_brands.
     */
    data: XOR<sub_brandsUpdateManyMutationInput, sub_brandsUncheckedUpdateManyInput>
    /**
     * Filter which sub_brands to update
     */
    where?: sub_brandsWhereInput
    /**
     * Limit how many sub_brands to update.
     */
    limit?: number
  }

  /**
   * sub_brands updateManyAndReturn
   */
  export type sub_brandsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * The data used to update sub_brands.
     */
    data: XOR<sub_brandsUpdateManyMutationInput, sub_brandsUncheckedUpdateManyInput>
    /**
     * Filter which sub_brands to update
     */
    where?: sub_brandsWhereInput
    /**
     * Limit how many sub_brands to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sub_brands upsert
   */
  export type sub_brandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * The filter to search for the sub_brands to update in case it exists.
     */
    where: sub_brandsWhereUniqueInput
    /**
     * In case the sub_brands found by the `where` argument doesn't exist, create a new sub_brands with this data.
     */
    create: XOR<sub_brandsCreateInput, sub_brandsUncheckedCreateInput>
    /**
     * In case the sub_brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sub_brandsUpdateInput, sub_brandsUncheckedUpdateInput>
  }

  /**
   * sub_brands delete
   */
  export type sub_brandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
    /**
     * Filter which sub_brands to delete.
     */
    where: sub_brandsWhereUniqueInput
  }

  /**
   * sub_brands deleteMany
   */
  export type sub_brandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sub_brands to delete
     */
    where?: sub_brandsWhereInput
    /**
     * Limit how many sub_brands to delete.
     */
    limit?: number
  }

  /**
   * sub_brands.categories
   */
  export type sub_brands$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    cursor?: categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * sub_brands.customers
   */
  export type sub_brands$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    where?: customersWhereInput
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    cursor?: customersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * sub_brands.items
   */
  export type sub_brands$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemsInclude<ExtArgs> | null
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * sub_brands.option_groups
   */
  export type sub_brands$option_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_groups
     */
    select?: option_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_groups
     */
    omit?: option_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_groupsInclude<ExtArgs> | null
    where?: option_groupsWhereInput
    orderBy?: option_groupsOrderByWithRelationInput | option_groupsOrderByWithRelationInput[]
    cursor?: option_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Option_groupsScalarFieldEnum | Option_groupsScalarFieldEnum[]
  }

  /**
   * sub_brands.products
   */
  export type sub_brands$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * sub_brands.sales
   */
  export type sub_brands$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales
     */
    select?: salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales
     */
    omit?: salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salesInclude<ExtArgs> | null
    where?: salesWhereInput
    orderBy?: salesOrderByWithRelationInput | salesOrderByWithRelationInput[]
    cursor?: salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * sub_brands.stores
   */
  export type sub_brands$storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    where?: storesWhereInput
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    cursor?: storesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * sub_brands.brands
   */
  export type sub_brands$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * sub_brands without action
   */
  export type sub_brandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_brands
     */
    select?: sub_brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_brands
     */
    omit?: sub_brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_brandsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BrandsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at'
  };

  export type BrandsScalarFieldEnum = (typeof BrandsScalarFieldEnum)[keyof typeof BrandsScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    name: 'name',
    type: 'type',
    pos_uuid: 'pos_uuid',
    deleted_at: 'deleted_at'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const ChannelsScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    name: 'name',
    description: 'description',
    type: 'type',
    created_at: 'created_at'
  };

  export type ChannelsScalarFieldEnum = (typeof ChannelsScalarFieldEnum)[keyof typeof ChannelsScalarFieldEnum]


  export const Coupon_salesScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    coupon_id: 'coupon_id',
    value: 'value',
    target: 'target',
    sponsorship: 'sponsorship'
  };

  export type Coupon_salesScalarFieldEnum = (typeof Coupon_salesScalarFieldEnum)[keyof typeof Coupon_salesScalarFieldEnum]


  export const CouponsScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    code: 'code',
    discount_type: 'discount_type',
    discount_value: 'discount_value',
    is_active: 'is_active',
    valid_from: 'valid_from',
    valid_until: 'valid_until'
  };

  export type CouponsScalarFieldEnum = (typeof CouponsScalarFieldEnum)[keyof typeof CouponsScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    customer_name: 'customer_name',
    email: 'email',
    phone_number: 'phone_number',
    cpf: 'cpf',
    birth_date: 'birth_date',
    gender: 'gender',
    store_id: 'store_id',
    sub_brand_id: 'sub_brand_id',
    registration_origin: 'registration_origin',
    agree_terms: 'agree_terms',
    receive_promotions_email: 'receive_promotions_email',
    receive_promotions_sms: 'receive_promotions_sms',
    created_at: 'created_at'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const Delivery_addressesScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    delivery_sale_id: 'delivery_sale_id',
    street: 'street',
    number: 'number',
    complement: 'complement',
    formatted_address: 'formatted_address',
    neighborhood: 'neighborhood',
    city: 'city',
    state: 'state',
    country: 'country',
    postal_code: 'postal_code',
    reference: 'reference',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type Delivery_addressesScalarFieldEnum = (typeof Delivery_addressesScalarFieldEnum)[keyof typeof Delivery_addressesScalarFieldEnum]


  export const Delivery_salesScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    courier_id: 'courier_id',
    courier_name: 'courier_name',
    courier_phone: 'courier_phone',
    courier_type: 'courier_type',
    delivered_by: 'delivered_by',
    delivery_type: 'delivery_type',
    status: 'status',
    delivery_fee: 'delivery_fee',
    courier_fee: 'courier_fee',
    timing: 'timing',
    mode: 'mode'
  };

  export type Delivery_salesScalarFieldEnum = (typeof Delivery_salesScalarFieldEnum)[keyof typeof Delivery_salesScalarFieldEnum]


  export const Item_item_product_salesScalarFieldEnum: {
    id: 'id',
    item_product_sale_id: 'item_product_sale_id',
    item_id: 'item_id',
    option_group_id: 'option_group_id',
    quantity: 'quantity',
    additional_price: 'additional_price',
    price: 'price',
    amount: 'amount'
  };

  export type Item_item_product_salesScalarFieldEnum = (typeof Item_item_product_salesScalarFieldEnum)[keyof typeof Item_item_product_salesScalarFieldEnum]


  export const Item_product_salesScalarFieldEnum: {
    id: 'id',
    product_sale_id: 'product_sale_id',
    item_id: 'item_id',
    option_group_id: 'option_group_id',
    quantity: 'quantity',
    additional_price: 'additional_price',
    price: 'price',
    amount: 'amount',
    observations: 'observations'
  };

  export type Item_product_salesScalarFieldEnum = (typeof Item_product_salesScalarFieldEnum)[keyof typeof Item_product_salesScalarFieldEnum]


  export const ItemsScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    category_id: 'category_id',
    name: 'name',
    pos_uuid: 'pos_uuid',
    deleted_at: 'deleted_at'
  };

  export type ItemsScalarFieldEnum = (typeof ItemsScalarFieldEnum)[keyof typeof ItemsScalarFieldEnum]


  export const Option_groupsScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    category_id: 'category_id',
    name: 'name',
    pos_uuid: 'pos_uuid',
    deleted_at: 'deleted_at'
  };

  export type Option_groupsScalarFieldEnum = (typeof Option_groupsScalarFieldEnum)[keyof typeof Option_groupsScalarFieldEnum]


  export const Payment_typesScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    description: 'description'
  };

  export type Payment_typesScalarFieldEnum = (typeof Payment_typesScalarFieldEnum)[keyof typeof Payment_typesScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    payment_type_id: 'payment_type_id',
    value: 'value',
    is_online: 'is_online',
    description: 'description',
    currency: 'currency'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const Product_salesScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    product_id: 'product_id',
    quantity: 'quantity',
    base_price: 'base_price',
    total_price: 'total_price',
    observations: 'observations'
  };

  export type Product_salesScalarFieldEnum = (typeof Product_salesScalarFieldEnum)[keyof typeof Product_salesScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    category_id: 'category_id',
    name: 'name',
    pos_uuid: 'pos_uuid',
    deleted_at: 'deleted_at'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const SalesScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    sub_brand_id: 'sub_brand_id',
    customer_id: 'customer_id',
    channel_id: 'channel_id',
    cod_sale1: 'cod_sale1',
    cod_sale2: 'cod_sale2',
    created_at: 'created_at',
    customer_name: 'customer_name',
    sale_status_desc: 'sale_status_desc',
    total_amount_items: 'total_amount_items',
    total_discount: 'total_discount',
    total_increase: 'total_increase',
    delivery_fee: 'delivery_fee',
    service_tax_fee: 'service_tax_fee',
    total_amount: 'total_amount',
    value_paid: 'value_paid',
    production_seconds: 'production_seconds',
    delivery_seconds: 'delivery_seconds',
    people_quantity: 'people_quantity',
    discount_reason: 'discount_reason',
    increase_reason: 'increase_reason',
    origin: 'origin'
  };

  export type SalesScalarFieldEnum = (typeof SalesScalarFieldEnum)[keyof typeof SalesScalarFieldEnum]


  export const StoresScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    name: 'name',
    city: 'city',
    state: 'state',
    district: 'district',
    address_street: 'address_street',
    address_number: 'address_number',
    zipcode: 'zipcode',
    latitude: 'latitude',
    longitude: 'longitude',
    is_active: 'is_active',
    is_own: 'is_own',
    is_holding: 'is_holding',
    creation_date: 'creation_date',
    created_at: 'created_at'
  };

  export type StoresScalarFieldEnum = (typeof StoresScalarFieldEnum)[keyof typeof StoresScalarFieldEnum]


  export const Sub_brandsScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    name: 'name',
    created_at: 'created_at'
  };

  export type Sub_brandsScalarFieldEnum = (typeof Sub_brandsScalarFieldEnum)[keyof typeof Sub_brandsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type brandsWhereInput = {
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    id?: IntFilter<"brands"> | number
    name?: StringFilter<"brands"> | string
    created_at?: DateTimeNullableFilter<"brands"> | Date | string | null
    categories?: CategoriesListRelationFilter
    channels?: ChannelsListRelationFilter
    coupons?: CouponsListRelationFilter
    items?: ItemsListRelationFilter
    option_groups?: Option_groupsListRelationFilter
    payment_types?: Payment_typesListRelationFilter
    products?: ProductsListRelationFilter
    stores?: StoresListRelationFilter
    sub_brands?: Sub_brandsListRelationFilter
  }

  export type brandsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    categories?: categoriesOrderByRelationAggregateInput
    channels?: channelsOrderByRelationAggregateInput
    coupons?: couponsOrderByRelationAggregateInput
    items?: itemsOrderByRelationAggregateInput
    option_groups?: option_groupsOrderByRelationAggregateInput
    payment_types?: payment_typesOrderByRelationAggregateInput
    products?: productsOrderByRelationAggregateInput
    stores?: storesOrderByRelationAggregateInput
    sub_brands?: sub_brandsOrderByRelationAggregateInput
  }

  export type brandsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    name?: StringFilter<"brands"> | string
    created_at?: DateTimeNullableFilter<"brands"> | Date | string | null
    categories?: CategoriesListRelationFilter
    channels?: ChannelsListRelationFilter
    coupons?: CouponsListRelationFilter
    items?: ItemsListRelationFilter
    option_groups?: Option_groupsListRelationFilter
    payment_types?: Payment_typesListRelationFilter
    products?: ProductsListRelationFilter
    stores?: StoresListRelationFilter
    sub_brands?: Sub_brandsListRelationFilter
  }, "id">

  export type brandsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: brandsCountOrderByAggregateInput
    _avg?: brandsAvgOrderByAggregateInput
    _max?: brandsMaxOrderByAggregateInput
    _min?: brandsMinOrderByAggregateInput
    _sum?: brandsSumOrderByAggregateInput
  }

  export type brandsScalarWhereWithAggregatesInput = {
    AND?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    OR?: brandsScalarWhereWithAggregatesInput[]
    NOT?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"brands"> | number
    name?: StringWithAggregatesFilter<"brands"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"brands"> | Date | string | null
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: IntFilter<"categories"> | number
    brand_id?: IntNullableFilter<"categories"> | number | null
    sub_brand_id?: IntNullableFilter<"categories"> | number | null
    name?: StringFilter<"categories"> | string
    type?: StringNullableFilter<"categories"> | string | null
    pos_uuid?: StringNullableFilter<"categories"> | string | null
    deleted_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
    items?: ItemsListRelationFilter
    option_groups?: Option_groupsListRelationFilter
    products?: ProductsListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    brands?: brandsOrderByWithRelationInput
    sub_brands?: sub_brandsOrderByWithRelationInput
    items?: itemsOrderByRelationAggregateInput
    option_groups?: option_groupsOrderByRelationAggregateInput
    products?: productsOrderByRelationAggregateInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    brand_id?: IntNullableFilter<"categories"> | number | null
    sub_brand_id?: IntNullableFilter<"categories"> | number | null
    name?: StringFilter<"categories"> | string
    type?: StringNullableFilter<"categories"> | string | null
    pos_uuid?: StringNullableFilter<"categories"> | string | null
    deleted_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
    items?: ItemsListRelationFilter
    option_groups?: Option_groupsListRelationFilter
    products?: ProductsListRelationFilter
  }, "id">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _avg?: categoriesAvgOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
    _sum?: categoriesSumOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"categories"> | number
    brand_id?: IntNullableWithAggregatesFilter<"categories"> | number | null
    sub_brand_id?: IntNullableWithAggregatesFilter<"categories"> | number | null
    name?: StringWithAggregatesFilter<"categories"> | string
    type?: StringNullableWithAggregatesFilter<"categories"> | string | null
    pos_uuid?: StringNullableWithAggregatesFilter<"categories"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"categories"> | Date | string | null
  }

  export type channelsWhereInput = {
    AND?: channelsWhereInput | channelsWhereInput[]
    OR?: channelsWhereInput[]
    NOT?: channelsWhereInput | channelsWhereInput[]
    id?: IntFilter<"channels"> | number
    brand_id?: IntNullableFilter<"channels"> | number | null
    name?: StringFilter<"channels"> | string
    description?: StringNullableFilter<"channels"> | string | null
    type?: StringNullableFilter<"channels"> | string | null
    created_at?: DateTimeNullableFilter<"channels"> | Date | string | null
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    sales?: SalesListRelationFilter
  }

  export type channelsOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    brands?: brandsOrderByWithRelationInput
    sales?: salesOrderByRelationAggregateInput
  }

  export type channelsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: channelsWhereInput | channelsWhereInput[]
    OR?: channelsWhereInput[]
    NOT?: channelsWhereInput | channelsWhereInput[]
    brand_id?: IntNullableFilter<"channels"> | number | null
    name?: StringFilter<"channels"> | string
    description?: StringNullableFilter<"channels"> | string | null
    type?: StringNullableFilter<"channels"> | string | null
    created_at?: DateTimeNullableFilter<"channels"> | Date | string | null
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    sales?: SalesListRelationFilter
  }, "id">

  export type channelsOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: channelsCountOrderByAggregateInput
    _avg?: channelsAvgOrderByAggregateInput
    _max?: channelsMaxOrderByAggregateInput
    _min?: channelsMinOrderByAggregateInput
    _sum?: channelsSumOrderByAggregateInput
  }

  export type channelsScalarWhereWithAggregatesInput = {
    AND?: channelsScalarWhereWithAggregatesInput | channelsScalarWhereWithAggregatesInput[]
    OR?: channelsScalarWhereWithAggregatesInput[]
    NOT?: channelsScalarWhereWithAggregatesInput | channelsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"channels"> | number
    brand_id?: IntNullableWithAggregatesFilter<"channels"> | number | null
    name?: StringWithAggregatesFilter<"channels"> | string
    description?: StringNullableWithAggregatesFilter<"channels"> | string | null
    type?: StringNullableWithAggregatesFilter<"channels"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"channels"> | Date | string | null
  }

  export type coupon_salesWhereInput = {
    AND?: coupon_salesWhereInput | coupon_salesWhereInput[]
    OR?: coupon_salesWhereInput[]
    NOT?: coupon_salesWhereInput | coupon_salesWhereInput[]
    id?: IntFilter<"coupon_sales"> | number
    sale_id?: IntNullableFilter<"coupon_sales"> | number | null
    coupon_id?: IntNullableFilter<"coupon_sales"> | number | null
    value?: FloatNullableFilter<"coupon_sales"> | number | null
    target?: StringNullableFilter<"coupon_sales"> | string | null
    sponsorship?: StringNullableFilter<"coupon_sales"> | string | null
    coupons?: XOR<CouponsNullableScalarRelationFilter, couponsWhereInput> | null
    sales?: XOR<SalesNullableScalarRelationFilter, salesWhereInput> | null
  }

  export type coupon_salesOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrderInput | SortOrder
    coupon_id?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    sponsorship?: SortOrderInput | SortOrder
    coupons?: couponsOrderByWithRelationInput
    sales?: salesOrderByWithRelationInput
  }

  export type coupon_salesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: coupon_salesWhereInput | coupon_salesWhereInput[]
    OR?: coupon_salesWhereInput[]
    NOT?: coupon_salesWhereInput | coupon_salesWhereInput[]
    sale_id?: IntNullableFilter<"coupon_sales"> | number | null
    coupon_id?: IntNullableFilter<"coupon_sales"> | number | null
    value?: FloatNullableFilter<"coupon_sales"> | number | null
    target?: StringNullableFilter<"coupon_sales"> | string | null
    sponsorship?: StringNullableFilter<"coupon_sales"> | string | null
    coupons?: XOR<CouponsNullableScalarRelationFilter, couponsWhereInput> | null
    sales?: XOR<SalesNullableScalarRelationFilter, salesWhereInput> | null
  }, "id">

  export type coupon_salesOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrderInput | SortOrder
    coupon_id?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    sponsorship?: SortOrderInput | SortOrder
    _count?: coupon_salesCountOrderByAggregateInput
    _avg?: coupon_salesAvgOrderByAggregateInput
    _max?: coupon_salesMaxOrderByAggregateInput
    _min?: coupon_salesMinOrderByAggregateInput
    _sum?: coupon_salesSumOrderByAggregateInput
  }

  export type coupon_salesScalarWhereWithAggregatesInput = {
    AND?: coupon_salesScalarWhereWithAggregatesInput | coupon_salesScalarWhereWithAggregatesInput[]
    OR?: coupon_salesScalarWhereWithAggregatesInput[]
    NOT?: coupon_salesScalarWhereWithAggregatesInput | coupon_salesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"coupon_sales"> | number
    sale_id?: IntNullableWithAggregatesFilter<"coupon_sales"> | number | null
    coupon_id?: IntNullableWithAggregatesFilter<"coupon_sales"> | number | null
    value?: FloatNullableWithAggregatesFilter<"coupon_sales"> | number | null
    target?: StringNullableWithAggregatesFilter<"coupon_sales"> | string | null
    sponsorship?: StringNullableWithAggregatesFilter<"coupon_sales"> | string | null
  }

  export type couponsWhereInput = {
    AND?: couponsWhereInput | couponsWhereInput[]
    OR?: couponsWhereInput[]
    NOT?: couponsWhereInput | couponsWhereInput[]
    id?: IntFilter<"coupons"> | number
    brand_id?: IntNullableFilter<"coupons"> | number | null
    code?: StringFilter<"coupons"> | string
    discount_type?: StringNullableFilter<"coupons"> | string | null
    discount_value?: DecimalNullableFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"coupons"> | boolean | null
    valid_from?: DateTimeNullableFilter<"coupons"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"coupons"> | Date | string | null
    coupon_sales?: Coupon_salesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
  }

  export type couponsOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    code?: SortOrder
    discount_type?: SortOrderInput | SortOrder
    discount_value?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    valid_from?: SortOrderInput | SortOrder
    valid_until?: SortOrderInput | SortOrder
    coupon_sales?: coupon_salesOrderByRelationAggregateInput
    brands?: brandsOrderByWithRelationInput
  }

  export type couponsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: couponsWhereInput | couponsWhereInput[]
    OR?: couponsWhereInput[]
    NOT?: couponsWhereInput | couponsWhereInput[]
    brand_id?: IntNullableFilter<"coupons"> | number | null
    code?: StringFilter<"coupons"> | string
    discount_type?: StringNullableFilter<"coupons"> | string | null
    discount_value?: DecimalNullableFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"coupons"> | boolean | null
    valid_from?: DateTimeNullableFilter<"coupons"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"coupons"> | Date | string | null
    coupon_sales?: Coupon_salesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
  }, "id">

  export type couponsOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    code?: SortOrder
    discount_type?: SortOrderInput | SortOrder
    discount_value?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    valid_from?: SortOrderInput | SortOrder
    valid_until?: SortOrderInput | SortOrder
    _count?: couponsCountOrderByAggregateInput
    _avg?: couponsAvgOrderByAggregateInput
    _max?: couponsMaxOrderByAggregateInput
    _min?: couponsMinOrderByAggregateInput
    _sum?: couponsSumOrderByAggregateInput
  }

  export type couponsScalarWhereWithAggregatesInput = {
    AND?: couponsScalarWhereWithAggregatesInput | couponsScalarWhereWithAggregatesInput[]
    OR?: couponsScalarWhereWithAggregatesInput[]
    NOT?: couponsScalarWhereWithAggregatesInput | couponsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"coupons"> | number
    brand_id?: IntNullableWithAggregatesFilter<"coupons"> | number | null
    code?: StringWithAggregatesFilter<"coupons"> | string
    discount_type?: StringNullableWithAggregatesFilter<"coupons"> | string | null
    discount_value?: DecimalNullableWithAggregatesFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableWithAggregatesFilter<"coupons"> | boolean | null
    valid_from?: DateTimeNullableWithAggregatesFilter<"coupons"> | Date | string | null
    valid_until?: DateTimeNullableWithAggregatesFilter<"coupons"> | Date | string | null
  }

  export type customersWhereInput = {
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    id?: IntFilter<"customers"> | number
    customer_name?: StringNullableFilter<"customers"> | string | null
    email?: StringNullableFilter<"customers"> | string | null
    phone_number?: StringNullableFilter<"customers"> | string | null
    cpf?: StringNullableFilter<"customers"> | string | null
    birth_date?: DateTimeNullableFilter<"customers"> | Date | string | null
    gender?: StringNullableFilter<"customers"> | string | null
    store_id?: IntNullableFilter<"customers"> | number | null
    sub_brand_id?: IntNullableFilter<"customers"> | number | null
    registration_origin?: StringNullableFilter<"customers"> | string | null
    agree_terms?: BoolNullableFilter<"customers"> | boolean | null
    receive_promotions_email?: BoolNullableFilter<"customers"> | boolean | null
    receive_promotions_sms?: BoolNullableFilter<"customers"> | boolean | null
    created_at?: DateTimeNullableFilter<"customers"> | Date | string | null
    stores?: XOR<StoresNullableScalarRelationFilter, storesWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
    sales?: SalesListRelationFilter
  }

  export type customersOrderByWithRelationInput = {
    id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    store_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    registration_origin?: SortOrderInput | SortOrder
    agree_terms?: SortOrderInput | SortOrder
    receive_promotions_email?: SortOrderInput | SortOrder
    receive_promotions_sms?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    stores?: storesOrderByWithRelationInput
    sub_brands?: sub_brandsOrderByWithRelationInput
    sales?: salesOrderByRelationAggregateInput
  }

  export type customersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    customer_name?: StringNullableFilter<"customers"> | string | null
    email?: StringNullableFilter<"customers"> | string | null
    phone_number?: StringNullableFilter<"customers"> | string | null
    cpf?: StringNullableFilter<"customers"> | string | null
    birth_date?: DateTimeNullableFilter<"customers"> | Date | string | null
    gender?: StringNullableFilter<"customers"> | string | null
    store_id?: IntNullableFilter<"customers"> | number | null
    sub_brand_id?: IntNullableFilter<"customers"> | number | null
    registration_origin?: StringNullableFilter<"customers"> | string | null
    agree_terms?: BoolNullableFilter<"customers"> | boolean | null
    receive_promotions_email?: BoolNullableFilter<"customers"> | boolean | null
    receive_promotions_sms?: BoolNullableFilter<"customers"> | boolean | null
    created_at?: DateTimeNullableFilter<"customers"> | Date | string | null
    stores?: XOR<StoresNullableScalarRelationFilter, storesWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
    sales?: SalesListRelationFilter
  }, "id">

  export type customersOrderByWithAggregationInput = {
    id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    store_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    registration_origin?: SortOrderInput | SortOrder
    agree_terms?: SortOrderInput | SortOrder
    receive_promotions_email?: SortOrderInput | SortOrder
    receive_promotions_sms?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: customersCountOrderByAggregateInput
    _avg?: customersAvgOrderByAggregateInput
    _max?: customersMaxOrderByAggregateInput
    _min?: customersMinOrderByAggregateInput
    _sum?: customersSumOrderByAggregateInput
  }

  export type customersScalarWhereWithAggregatesInput = {
    AND?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    OR?: customersScalarWhereWithAggregatesInput[]
    NOT?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customers"> | number
    customer_name?: StringNullableWithAggregatesFilter<"customers"> | string | null
    email?: StringNullableWithAggregatesFilter<"customers"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"customers"> | string | null
    cpf?: StringNullableWithAggregatesFilter<"customers"> | string | null
    birth_date?: DateTimeNullableWithAggregatesFilter<"customers"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"customers"> | string | null
    store_id?: IntNullableWithAggregatesFilter<"customers"> | number | null
    sub_brand_id?: IntNullableWithAggregatesFilter<"customers"> | number | null
    registration_origin?: StringNullableWithAggregatesFilter<"customers"> | string | null
    agree_terms?: BoolNullableWithAggregatesFilter<"customers"> | boolean | null
    receive_promotions_email?: BoolNullableWithAggregatesFilter<"customers"> | boolean | null
    receive_promotions_sms?: BoolNullableWithAggregatesFilter<"customers"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"customers"> | Date | string | null
  }

  export type delivery_addressesWhereInput = {
    AND?: delivery_addressesWhereInput | delivery_addressesWhereInput[]
    OR?: delivery_addressesWhereInput[]
    NOT?: delivery_addressesWhereInput | delivery_addressesWhereInput[]
    id?: IntFilter<"delivery_addresses"> | number
    sale_id?: IntFilter<"delivery_addresses"> | number
    delivery_sale_id?: IntNullableFilter<"delivery_addresses"> | number | null
    street?: StringNullableFilter<"delivery_addresses"> | string | null
    number?: StringNullableFilter<"delivery_addresses"> | string | null
    complement?: StringNullableFilter<"delivery_addresses"> | string | null
    formatted_address?: StringNullableFilter<"delivery_addresses"> | string | null
    neighborhood?: StringNullableFilter<"delivery_addresses"> | string | null
    city?: StringNullableFilter<"delivery_addresses"> | string | null
    state?: StringNullableFilter<"delivery_addresses"> | string | null
    country?: StringNullableFilter<"delivery_addresses"> | string | null
    postal_code?: StringNullableFilter<"delivery_addresses"> | string | null
    reference?: StringNullableFilter<"delivery_addresses"> | string | null
    latitude?: FloatNullableFilter<"delivery_addresses"> | number | null
    longitude?: FloatNullableFilter<"delivery_addresses"> | number | null
    delivery_sales?: XOR<Delivery_salesNullableScalarRelationFilter, delivery_salesWhereInput> | null
    sales?: XOR<SalesScalarRelationFilter, salesWhereInput>
  }

  export type delivery_addressesOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    complement?: SortOrderInput | SortOrder
    formatted_address?: SortOrderInput | SortOrder
    neighborhood?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    delivery_sales?: delivery_salesOrderByWithRelationInput
    sales?: salesOrderByWithRelationInput
  }

  export type delivery_addressesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: delivery_addressesWhereInput | delivery_addressesWhereInput[]
    OR?: delivery_addressesWhereInput[]
    NOT?: delivery_addressesWhereInput | delivery_addressesWhereInput[]
    sale_id?: IntFilter<"delivery_addresses"> | number
    delivery_sale_id?: IntNullableFilter<"delivery_addresses"> | number | null
    street?: StringNullableFilter<"delivery_addresses"> | string | null
    number?: StringNullableFilter<"delivery_addresses"> | string | null
    complement?: StringNullableFilter<"delivery_addresses"> | string | null
    formatted_address?: StringNullableFilter<"delivery_addresses"> | string | null
    neighborhood?: StringNullableFilter<"delivery_addresses"> | string | null
    city?: StringNullableFilter<"delivery_addresses"> | string | null
    state?: StringNullableFilter<"delivery_addresses"> | string | null
    country?: StringNullableFilter<"delivery_addresses"> | string | null
    postal_code?: StringNullableFilter<"delivery_addresses"> | string | null
    reference?: StringNullableFilter<"delivery_addresses"> | string | null
    latitude?: FloatNullableFilter<"delivery_addresses"> | number | null
    longitude?: FloatNullableFilter<"delivery_addresses"> | number | null
    delivery_sales?: XOR<Delivery_salesNullableScalarRelationFilter, delivery_salesWhereInput> | null
    sales?: XOR<SalesScalarRelationFilter, salesWhereInput>
  }, "id">

  export type delivery_addressesOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    complement?: SortOrderInput | SortOrder
    formatted_address?: SortOrderInput | SortOrder
    neighborhood?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    _count?: delivery_addressesCountOrderByAggregateInput
    _avg?: delivery_addressesAvgOrderByAggregateInput
    _max?: delivery_addressesMaxOrderByAggregateInput
    _min?: delivery_addressesMinOrderByAggregateInput
    _sum?: delivery_addressesSumOrderByAggregateInput
  }

  export type delivery_addressesScalarWhereWithAggregatesInput = {
    AND?: delivery_addressesScalarWhereWithAggregatesInput | delivery_addressesScalarWhereWithAggregatesInput[]
    OR?: delivery_addressesScalarWhereWithAggregatesInput[]
    NOT?: delivery_addressesScalarWhereWithAggregatesInput | delivery_addressesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"delivery_addresses"> | number
    sale_id?: IntWithAggregatesFilter<"delivery_addresses"> | number
    delivery_sale_id?: IntNullableWithAggregatesFilter<"delivery_addresses"> | number | null
    street?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    number?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    complement?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    formatted_address?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    neighborhood?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    city?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    state?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    country?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    reference?: StringNullableWithAggregatesFilter<"delivery_addresses"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"delivery_addresses"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"delivery_addresses"> | number | null
  }

  export type delivery_salesWhereInput = {
    AND?: delivery_salesWhereInput | delivery_salesWhereInput[]
    OR?: delivery_salesWhereInput[]
    NOT?: delivery_salesWhereInput | delivery_salesWhereInput[]
    id?: IntFilter<"delivery_sales"> | number
    sale_id?: IntFilter<"delivery_sales"> | number
    courier_id?: StringNullableFilter<"delivery_sales"> | string | null
    courier_name?: StringNullableFilter<"delivery_sales"> | string | null
    courier_phone?: StringNullableFilter<"delivery_sales"> | string | null
    courier_type?: StringNullableFilter<"delivery_sales"> | string | null
    delivered_by?: StringNullableFilter<"delivery_sales"> | string | null
    delivery_type?: StringNullableFilter<"delivery_sales"> | string | null
    status?: StringNullableFilter<"delivery_sales"> | string | null
    delivery_fee?: FloatNullableFilter<"delivery_sales"> | number | null
    courier_fee?: FloatNullableFilter<"delivery_sales"> | number | null
    timing?: StringNullableFilter<"delivery_sales"> | string | null
    mode?: StringNullableFilter<"delivery_sales"> | string | null
    delivery_addresses?: Delivery_addressesListRelationFilter
    sales?: XOR<SalesScalarRelationFilter, salesWhereInput>
  }

  export type delivery_salesOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrderInput | SortOrder
    courier_name?: SortOrderInput | SortOrder
    courier_phone?: SortOrderInput | SortOrder
    courier_type?: SortOrderInput | SortOrder
    delivered_by?: SortOrderInput | SortOrder
    delivery_type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    courier_fee?: SortOrderInput | SortOrder
    timing?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    delivery_addresses?: delivery_addressesOrderByRelationAggregateInput
    sales?: salesOrderByWithRelationInput
  }

  export type delivery_salesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: delivery_salesWhereInput | delivery_salesWhereInput[]
    OR?: delivery_salesWhereInput[]
    NOT?: delivery_salesWhereInput | delivery_salesWhereInput[]
    sale_id?: IntFilter<"delivery_sales"> | number
    courier_id?: StringNullableFilter<"delivery_sales"> | string | null
    courier_name?: StringNullableFilter<"delivery_sales"> | string | null
    courier_phone?: StringNullableFilter<"delivery_sales"> | string | null
    courier_type?: StringNullableFilter<"delivery_sales"> | string | null
    delivered_by?: StringNullableFilter<"delivery_sales"> | string | null
    delivery_type?: StringNullableFilter<"delivery_sales"> | string | null
    status?: StringNullableFilter<"delivery_sales"> | string | null
    delivery_fee?: FloatNullableFilter<"delivery_sales"> | number | null
    courier_fee?: FloatNullableFilter<"delivery_sales"> | number | null
    timing?: StringNullableFilter<"delivery_sales"> | string | null
    mode?: StringNullableFilter<"delivery_sales"> | string | null
    delivery_addresses?: Delivery_addressesListRelationFilter
    sales?: XOR<SalesScalarRelationFilter, salesWhereInput>
  }, "id">

  export type delivery_salesOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrderInput | SortOrder
    courier_name?: SortOrderInput | SortOrder
    courier_phone?: SortOrderInput | SortOrder
    courier_type?: SortOrderInput | SortOrder
    delivered_by?: SortOrderInput | SortOrder
    delivery_type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    courier_fee?: SortOrderInput | SortOrder
    timing?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    _count?: delivery_salesCountOrderByAggregateInput
    _avg?: delivery_salesAvgOrderByAggregateInput
    _max?: delivery_salesMaxOrderByAggregateInput
    _min?: delivery_salesMinOrderByAggregateInput
    _sum?: delivery_salesSumOrderByAggregateInput
  }

  export type delivery_salesScalarWhereWithAggregatesInput = {
    AND?: delivery_salesScalarWhereWithAggregatesInput | delivery_salesScalarWhereWithAggregatesInput[]
    OR?: delivery_salesScalarWhereWithAggregatesInput[]
    NOT?: delivery_salesScalarWhereWithAggregatesInput | delivery_salesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"delivery_sales"> | number
    sale_id?: IntWithAggregatesFilter<"delivery_sales"> | number
    courier_id?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
    courier_name?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
    courier_phone?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
    courier_type?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
    delivered_by?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
    delivery_type?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
    status?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
    delivery_fee?: FloatNullableWithAggregatesFilter<"delivery_sales"> | number | null
    courier_fee?: FloatNullableWithAggregatesFilter<"delivery_sales"> | number | null
    timing?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
    mode?: StringNullableWithAggregatesFilter<"delivery_sales"> | string | null
  }

  export type item_item_product_salesWhereInput = {
    AND?: item_item_product_salesWhereInput | item_item_product_salesWhereInput[]
    OR?: item_item_product_salesWhereInput[]
    NOT?: item_item_product_salesWhereInput | item_item_product_salesWhereInput[]
    id?: IntFilter<"item_item_product_sales"> | number
    item_product_sale_id?: IntFilter<"item_item_product_sales"> | number
    item_id?: IntFilter<"item_item_product_sales"> | number
    option_group_id?: IntNullableFilter<"item_item_product_sales"> | number | null
    quantity?: FloatFilter<"item_item_product_sales"> | number
    additional_price?: FloatFilter<"item_item_product_sales"> | number
    price?: FloatFilter<"item_item_product_sales"> | number
    amount?: FloatNullableFilter<"item_item_product_sales"> | number | null
    items?: XOR<ItemsScalarRelationFilter, itemsWhereInput>
    item_product_sales?: XOR<Item_product_salesScalarRelationFilter, item_product_salesWhereInput>
    option_groups?: XOR<Option_groupsNullableScalarRelationFilter, option_groupsWhereInput> | null
  }

  export type item_item_product_salesOrderByWithRelationInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrderInput | SortOrder
    items?: itemsOrderByWithRelationInput
    item_product_sales?: item_product_salesOrderByWithRelationInput
    option_groups?: option_groupsOrderByWithRelationInput
  }

  export type item_item_product_salesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: item_item_product_salesWhereInput | item_item_product_salesWhereInput[]
    OR?: item_item_product_salesWhereInput[]
    NOT?: item_item_product_salesWhereInput | item_item_product_salesWhereInput[]
    item_product_sale_id?: IntFilter<"item_item_product_sales"> | number
    item_id?: IntFilter<"item_item_product_sales"> | number
    option_group_id?: IntNullableFilter<"item_item_product_sales"> | number | null
    quantity?: FloatFilter<"item_item_product_sales"> | number
    additional_price?: FloatFilter<"item_item_product_sales"> | number
    price?: FloatFilter<"item_item_product_sales"> | number
    amount?: FloatNullableFilter<"item_item_product_sales"> | number | null
    items?: XOR<ItemsScalarRelationFilter, itemsWhereInput>
    item_product_sales?: XOR<Item_product_salesScalarRelationFilter, item_product_salesWhereInput>
    option_groups?: XOR<Option_groupsNullableScalarRelationFilter, option_groupsWhereInput> | null
  }, "id">

  export type item_item_product_salesOrderByWithAggregationInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrderInput | SortOrder
    _count?: item_item_product_salesCountOrderByAggregateInput
    _avg?: item_item_product_salesAvgOrderByAggregateInput
    _max?: item_item_product_salesMaxOrderByAggregateInput
    _min?: item_item_product_salesMinOrderByAggregateInput
    _sum?: item_item_product_salesSumOrderByAggregateInput
  }

  export type item_item_product_salesScalarWhereWithAggregatesInput = {
    AND?: item_item_product_salesScalarWhereWithAggregatesInput | item_item_product_salesScalarWhereWithAggregatesInput[]
    OR?: item_item_product_salesScalarWhereWithAggregatesInput[]
    NOT?: item_item_product_salesScalarWhereWithAggregatesInput | item_item_product_salesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"item_item_product_sales"> | number
    item_product_sale_id?: IntWithAggregatesFilter<"item_item_product_sales"> | number
    item_id?: IntWithAggregatesFilter<"item_item_product_sales"> | number
    option_group_id?: IntNullableWithAggregatesFilter<"item_item_product_sales"> | number | null
    quantity?: FloatWithAggregatesFilter<"item_item_product_sales"> | number
    additional_price?: FloatWithAggregatesFilter<"item_item_product_sales"> | number
    price?: FloatWithAggregatesFilter<"item_item_product_sales"> | number
    amount?: FloatNullableWithAggregatesFilter<"item_item_product_sales"> | number | null
  }

  export type item_product_salesWhereInput = {
    AND?: item_product_salesWhereInput | item_product_salesWhereInput[]
    OR?: item_product_salesWhereInput[]
    NOT?: item_product_salesWhereInput | item_product_salesWhereInput[]
    id?: IntFilter<"item_product_sales"> | number
    product_sale_id?: IntFilter<"item_product_sales"> | number
    item_id?: IntFilter<"item_product_sales"> | number
    option_group_id?: IntNullableFilter<"item_product_sales"> | number | null
    quantity?: FloatFilter<"item_product_sales"> | number
    additional_price?: FloatFilter<"item_product_sales"> | number
    price?: FloatFilter<"item_product_sales"> | number
    amount?: FloatNullableFilter<"item_product_sales"> | number | null
    observations?: StringNullableFilter<"item_product_sales"> | string | null
    item_item_product_sales?: Item_item_product_salesListRelationFilter
    items?: XOR<ItemsScalarRelationFilter, itemsWhereInput>
    option_groups?: XOR<Option_groupsNullableScalarRelationFilter, option_groupsWhereInput> | null
    product_sales?: XOR<Product_salesScalarRelationFilter, product_salesWhereInput>
  }

  export type item_product_salesOrderByWithRelationInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    item_item_product_sales?: item_item_product_salesOrderByRelationAggregateInput
    items?: itemsOrderByWithRelationInput
    option_groups?: option_groupsOrderByWithRelationInput
    product_sales?: product_salesOrderByWithRelationInput
  }

  export type item_product_salesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: item_product_salesWhereInput | item_product_salesWhereInput[]
    OR?: item_product_salesWhereInput[]
    NOT?: item_product_salesWhereInput | item_product_salesWhereInput[]
    product_sale_id?: IntFilter<"item_product_sales"> | number
    item_id?: IntFilter<"item_product_sales"> | number
    option_group_id?: IntNullableFilter<"item_product_sales"> | number | null
    quantity?: FloatFilter<"item_product_sales"> | number
    additional_price?: FloatFilter<"item_product_sales"> | number
    price?: FloatFilter<"item_product_sales"> | number
    amount?: FloatNullableFilter<"item_product_sales"> | number | null
    observations?: StringNullableFilter<"item_product_sales"> | string | null
    item_item_product_sales?: Item_item_product_salesListRelationFilter
    items?: XOR<ItemsScalarRelationFilter, itemsWhereInput>
    option_groups?: XOR<Option_groupsNullableScalarRelationFilter, option_groupsWhereInput> | null
    product_sales?: XOR<Product_salesScalarRelationFilter, product_salesWhereInput>
  }, "id">

  export type item_product_salesOrderByWithAggregationInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    _count?: item_product_salesCountOrderByAggregateInput
    _avg?: item_product_salesAvgOrderByAggregateInput
    _max?: item_product_salesMaxOrderByAggregateInput
    _min?: item_product_salesMinOrderByAggregateInput
    _sum?: item_product_salesSumOrderByAggregateInput
  }

  export type item_product_salesScalarWhereWithAggregatesInput = {
    AND?: item_product_salesScalarWhereWithAggregatesInput | item_product_salesScalarWhereWithAggregatesInput[]
    OR?: item_product_salesScalarWhereWithAggregatesInput[]
    NOT?: item_product_salesScalarWhereWithAggregatesInput | item_product_salesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"item_product_sales"> | number
    product_sale_id?: IntWithAggregatesFilter<"item_product_sales"> | number
    item_id?: IntWithAggregatesFilter<"item_product_sales"> | number
    option_group_id?: IntNullableWithAggregatesFilter<"item_product_sales"> | number | null
    quantity?: FloatWithAggregatesFilter<"item_product_sales"> | number
    additional_price?: FloatWithAggregatesFilter<"item_product_sales"> | number
    price?: FloatWithAggregatesFilter<"item_product_sales"> | number
    amount?: FloatNullableWithAggregatesFilter<"item_product_sales"> | number | null
    observations?: StringNullableWithAggregatesFilter<"item_product_sales"> | string | null
  }

  export type itemsWhereInput = {
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    id?: IntFilter<"items"> | number
    brand_id?: IntNullableFilter<"items"> | number | null
    sub_brand_id?: IntNullableFilter<"items"> | number | null
    category_id?: IntNullableFilter<"items"> | number | null
    name?: StringFilter<"items"> | string
    pos_uuid?: StringNullableFilter<"items"> | string | null
    deleted_at?: DateTimeNullableFilter<"items"> | Date | string | null
    item_item_product_sales?: Item_item_product_salesListRelationFilter
    item_product_sales?: Item_product_salesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }

  export type itemsOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    item_item_product_sales?: item_item_product_salesOrderByRelationAggregateInput
    item_product_sales?: item_product_salesOrderByRelationAggregateInput
    brands?: brandsOrderByWithRelationInput
    categories?: categoriesOrderByWithRelationInput
    sub_brands?: sub_brandsOrderByWithRelationInput
  }

  export type itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    brand_id?: IntNullableFilter<"items"> | number | null
    sub_brand_id?: IntNullableFilter<"items"> | number | null
    category_id?: IntNullableFilter<"items"> | number | null
    name?: StringFilter<"items"> | string
    pos_uuid?: StringNullableFilter<"items"> | string | null
    deleted_at?: DateTimeNullableFilter<"items"> | Date | string | null
    item_item_product_sales?: Item_item_product_salesListRelationFilter
    item_product_sales?: Item_product_salesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }, "id">

  export type itemsOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: itemsCountOrderByAggregateInput
    _avg?: itemsAvgOrderByAggregateInput
    _max?: itemsMaxOrderByAggregateInput
    _min?: itemsMinOrderByAggregateInput
    _sum?: itemsSumOrderByAggregateInput
  }

  export type itemsScalarWhereWithAggregatesInput = {
    AND?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    OR?: itemsScalarWhereWithAggregatesInput[]
    NOT?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"items"> | number
    brand_id?: IntNullableWithAggregatesFilter<"items"> | number | null
    sub_brand_id?: IntNullableWithAggregatesFilter<"items"> | number | null
    category_id?: IntNullableWithAggregatesFilter<"items"> | number | null
    name?: StringWithAggregatesFilter<"items"> | string
    pos_uuid?: StringNullableWithAggregatesFilter<"items"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"items"> | Date | string | null
  }

  export type option_groupsWhereInput = {
    AND?: option_groupsWhereInput | option_groupsWhereInput[]
    OR?: option_groupsWhereInput[]
    NOT?: option_groupsWhereInput | option_groupsWhereInput[]
    id?: IntFilter<"option_groups"> | number
    brand_id?: IntNullableFilter<"option_groups"> | number | null
    sub_brand_id?: IntNullableFilter<"option_groups"> | number | null
    category_id?: IntNullableFilter<"option_groups"> | number | null
    name?: StringFilter<"option_groups"> | string
    pos_uuid?: StringNullableFilter<"option_groups"> | string | null
    deleted_at?: DateTimeNullableFilter<"option_groups"> | Date | string | null
    item_item_product_sales?: Item_item_product_salesListRelationFilter
    item_product_sales?: Item_product_salesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }

  export type option_groupsOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    item_item_product_sales?: item_item_product_salesOrderByRelationAggregateInput
    item_product_sales?: item_product_salesOrderByRelationAggregateInput
    brands?: brandsOrderByWithRelationInput
    categories?: categoriesOrderByWithRelationInput
    sub_brands?: sub_brandsOrderByWithRelationInput
  }

  export type option_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: option_groupsWhereInput | option_groupsWhereInput[]
    OR?: option_groupsWhereInput[]
    NOT?: option_groupsWhereInput | option_groupsWhereInput[]
    brand_id?: IntNullableFilter<"option_groups"> | number | null
    sub_brand_id?: IntNullableFilter<"option_groups"> | number | null
    category_id?: IntNullableFilter<"option_groups"> | number | null
    name?: StringFilter<"option_groups"> | string
    pos_uuid?: StringNullableFilter<"option_groups"> | string | null
    deleted_at?: DateTimeNullableFilter<"option_groups"> | Date | string | null
    item_item_product_sales?: Item_item_product_salesListRelationFilter
    item_product_sales?: Item_product_salesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }, "id">

  export type option_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: option_groupsCountOrderByAggregateInput
    _avg?: option_groupsAvgOrderByAggregateInput
    _max?: option_groupsMaxOrderByAggregateInput
    _min?: option_groupsMinOrderByAggregateInput
    _sum?: option_groupsSumOrderByAggregateInput
  }

  export type option_groupsScalarWhereWithAggregatesInput = {
    AND?: option_groupsScalarWhereWithAggregatesInput | option_groupsScalarWhereWithAggregatesInput[]
    OR?: option_groupsScalarWhereWithAggregatesInput[]
    NOT?: option_groupsScalarWhereWithAggregatesInput | option_groupsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"option_groups"> | number
    brand_id?: IntNullableWithAggregatesFilter<"option_groups"> | number | null
    sub_brand_id?: IntNullableWithAggregatesFilter<"option_groups"> | number | null
    category_id?: IntNullableWithAggregatesFilter<"option_groups"> | number | null
    name?: StringWithAggregatesFilter<"option_groups"> | string
    pos_uuid?: StringNullableWithAggregatesFilter<"option_groups"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"option_groups"> | Date | string | null
  }

  export type payment_typesWhereInput = {
    AND?: payment_typesWhereInput | payment_typesWhereInput[]
    OR?: payment_typesWhereInput[]
    NOT?: payment_typesWhereInput | payment_typesWhereInput[]
    id?: IntFilter<"payment_types"> | number
    brand_id?: IntNullableFilter<"payment_types"> | number | null
    description?: StringFilter<"payment_types"> | string
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    payments?: PaymentsListRelationFilter
  }

  export type payment_typesOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    description?: SortOrder
    brands?: brandsOrderByWithRelationInput
    payments?: paymentsOrderByRelationAggregateInput
  }

  export type payment_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: payment_typesWhereInput | payment_typesWhereInput[]
    OR?: payment_typesWhereInput[]
    NOT?: payment_typesWhereInput | payment_typesWhereInput[]
    brand_id?: IntNullableFilter<"payment_types"> | number | null
    description?: StringFilter<"payment_types"> | string
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    payments?: PaymentsListRelationFilter
  }, "id">

  export type payment_typesOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    description?: SortOrder
    _count?: payment_typesCountOrderByAggregateInput
    _avg?: payment_typesAvgOrderByAggregateInput
    _max?: payment_typesMaxOrderByAggregateInput
    _min?: payment_typesMinOrderByAggregateInput
    _sum?: payment_typesSumOrderByAggregateInput
  }

  export type payment_typesScalarWhereWithAggregatesInput = {
    AND?: payment_typesScalarWhereWithAggregatesInput | payment_typesScalarWhereWithAggregatesInput[]
    OR?: payment_typesScalarWhereWithAggregatesInput[]
    NOT?: payment_typesScalarWhereWithAggregatesInput | payment_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payment_types"> | number
    brand_id?: IntNullableWithAggregatesFilter<"payment_types"> | number | null
    description?: StringWithAggregatesFilter<"payment_types"> | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: IntFilter<"payments"> | number
    sale_id?: IntFilter<"payments"> | number
    payment_type_id?: IntNullableFilter<"payments"> | number | null
    value?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    is_online?: BoolNullableFilter<"payments"> | boolean | null
    description?: StringNullableFilter<"payments"> | string | null
    currency?: StringNullableFilter<"payments"> | string | null
    payment_types?: XOR<Payment_typesNullableScalarRelationFilter, payment_typesWhereInput> | null
    sales?: XOR<SalesScalarRelationFilter, salesWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrderInput | SortOrder
    value?: SortOrder
    is_online?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    payment_types?: payment_typesOrderByWithRelationInput
    sales?: salesOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    sale_id?: IntFilter<"payments"> | number
    payment_type_id?: IntNullableFilter<"payments"> | number | null
    value?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    is_online?: BoolNullableFilter<"payments"> | boolean | null
    description?: StringNullableFilter<"payments"> | string | null
    currency?: StringNullableFilter<"payments"> | string | null
    payment_types?: XOR<Payment_typesNullableScalarRelationFilter, payment_typesWhereInput> | null
    sales?: XOR<SalesScalarRelationFilter, salesWhereInput>
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrderInput | SortOrder
    value?: SortOrder
    is_online?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payments"> | number
    sale_id?: IntWithAggregatesFilter<"payments"> | number
    payment_type_id?: IntNullableWithAggregatesFilter<"payments"> | number | null
    value?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    is_online?: BoolNullableWithAggregatesFilter<"payments"> | boolean | null
    description?: StringNullableWithAggregatesFilter<"payments"> | string | null
    currency?: StringNullableWithAggregatesFilter<"payments"> | string | null
  }

  export type product_salesWhereInput = {
    AND?: product_salesWhereInput | product_salesWhereInput[]
    OR?: product_salesWhereInput[]
    NOT?: product_salesWhereInput | product_salesWhereInput[]
    id?: IntFilter<"product_sales"> | number
    sale_id?: IntFilter<"product_sales"> | number
    product_id?: IntFilter<"product_sales"> | number
    quantity?: FloatFilter<"product_sales"> | number
    base_price?: FloatFilter<"product_sales"> | number
    total_price?: FloatFilter<"product_sales"> | number
    observations?: StringNullableFilter<"product_sales"> | string | null
    item_product_sales?: Item_product_salesListRelationFilter
    products?: XOR<ProductsScalarRelationFilter, productsWhereInput>
    sales?: XOR<SalesScalarRelationFilter, salesWhereInput>
  }

  export type product_salesOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrderInput | SortOrder
    item_product_sales?: item_product_salesOrderByRelationAggregateInput
    products?: productsOrderByWithRelationInput
    sales?: salesOrderByWithRelationInput
  }

  export type product_salesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_salesWhereInput | product_salesWhereInput[]
    OR?: product_salesWhereInput[]
    NOT?: product_salesWhereInput | product_salesWhereInput[]
    sale_id?: IntFilter<"product_sales"> | number
    product_id?: IntFilter<"product_sales"> | number
    quantity?: FloatFilter<"product_sales"> | number
    base_price?: FloatFilter<"product_sales"> | number
    total_price?: FloatFilter<"product_sales"> | number
    observations?: StringNullableFilter<"product_sales"> | string | null
    item_product_sales?: Item_product_salesListRelationFilter
    products?: XOR<ProductsScalarRelationFilter, productsWhereInput>
    sales?: XOR<SalesScalarRelationFilter, salesWhereInput>
  }, "id">

  export type product_salesOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrderInput | SortOrder
    _count?: product_salesCountOrderByAggregateInput
    _avg?: product_salesAvgOrderByAggregateInput
    _max?: product_salesMaxOrderByAggregateInput
    _min?: product_salesMinOrderByAggregateInput
    _sum?: product_salesSumOrderByAggregateInput
  }

  export type product_salesScalarWhereWithAggregatesInput = {
    AND?: product_salesScalarWhereWithAggregatesInput | product_salesScalarWhereWithAggregatesInput[]
    OR?: product_salesScalarWhereWithAggregatesInput[]
    NOT?: product_salesScalarWhereWithAggregatesInput | product_salesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_sales"> | number
    sale_id?: IntWithAggregatesFilter<"product_sales"> | number
    product_id?: IntWithAggregatesFilter<"product_sales"> | number
    quantity?: FloatWithAggregatesFilter<"product_sales"> | number
    base_price?: FloatWithAggregatesFilter<"product_sales"> | number
    total_price?: FloatWithAggregatesFilter<"product_sales"> | number
    observations?: StringNullableWithAggregatesFilter<"product_sales"> | string | null
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    id?: IntFilter<"products"> | number
    brand_id?: IntNullableFilter<"products"> | number | null
    sub_brand_id?: IntNullableFilter<"products"> | number | null
    category_id?: IntNullableFilter<"products"> | number | null
    name?: StringFilter<"products"> | string
    pos_uuid?: StringNullableFilter<"products"> | string | null
    deleted_at?: DateTimeNullableFilter<"products"> | Date | string | null
    product_sales?: Product_salesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }

  export type productsOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    product_sales?: product_salesOrderByRelationAggregateInput
    brands?: brandsOrderByWithRelationInput
    categories?: categoriesOrderByWithRelationInput
    sub_brands?: sub_brandsOrderByWithRelationInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    brand_id?: IntNullableFilter<"products"> | number | null
    sub_brand_id?: IntNullableFilter<"products"> | number | null
    category_id?: IntNullableFilter<"products"> | number | null
    name?: StringFilter<"products"> | string
    pos_uuid?: StringNullableFilter<"products"> | string | null
    deleted_at?: DateTimeNullableFilter<"products"> | Date | string | null
    product_sales?: Product_salesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }, "id">

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: productsCountOrderByAggregateInput
    _avg?: productsAvgOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
    _sum?: productsSumOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"products"> | number
    brand_id?: IntNullableWithAggregatesFilter<"products"> | number | null
    sub_brand_id?: IntNullableWithAggregatesFilter<"products"> | number | null
    category_id?: IntNullableWithAggregatesFilter<"products"> | number | null
    name?: StringWithAggregatesFilter<"products"> | string
    pos_uuid?: StringNullableWithAggregatesFilter<"products"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"products"> | Date | string | null
  }

  export type salesWhereInput = {
    AND?: salesWhereInput | salesWhereInput[]
    OR?: salesWhereInput[]
    NOT?: salesWhereInput | salesWhereInput[]
    id?: IntFilter<"sales"> | number
    store_id?: IntFilter<"sales"> | number
    sub_brand_id?: IntNullableFilter<"sales"> | number | null
    customer_id?: IntNullableFilter<"sales"> | number | null
    channel_id?: IntFilter<"sales"> | number
    cod_sale1?: StringNullableFilter<"sales"> | string | null
    cod_sale2?: StringNullableFilter<"sales"> | string | null
    created_at?: DateTimeFilter<"sales"> | Date | string
    customer_name?: StringNullableFilter<"sales"> | string | null
    sale_status_desc?: StringFilter<"sales"> | string
    total_amount_items?: DecimalFilter<"sales"> | Decimal | DecimalJsLike | number | string
    total_discount?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    total_increase?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFilter<"sales"> | Decimal | DecimalJsLike | number | string
    value_paid?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    production_seconds?: IntNullableFilter<"sales"> | number | null
    delivery_seconds?: IntNullableFilter<"sales"> | number | null
    people_quantity?: IntNullableFilter<"sales"> | number | null
    discount_reason?: StringNullableFilter<"sales"> | string | null
    increase_reason?: StringNullableFilter<"sales"> | string | null
    origin?: StringNullableFilter<"sales"> | string | null
    coupon_sales?: Coupon_salesListRelationFilter
    delivery_addresses?: Delivery_addressesListRelationFilter
    delivery_sales?: Delivery_salesListRelationFilter
    payments?: PaymentsListRelationFilter
    product_sales?: Product_salesListRelationFilter
    channels?: XOR<ChannelsScalarRelationFilter, channelsWhereInput>
    customers?: XOR<CustomersNullableScalarRelationFilter, customersWhereInput> | null
    stores?: XOR<StoresScalarRelationFilter, storesWhereInput>
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }

  export type salesOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    customer_id?: SortOrderInput | SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrderInput | SortOrder
    cod_sale2?: SortOrderInput | SortOrder
    created_at?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrderInput | SortOrder
    total_increase?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    service_tax_fee?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrderInput | SortOrder
    production_seconds?: SortOrderInput | SortOrder
    delivery_seconds?: SortOrderInput | SortOrder
    people_quantity?: SortOrderInput | SortOrder
    discount_reason?: SortOrderInput | SortOrder
    increase_reason?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    coupon_sales?: coupon_salesOrderByRelationAggregateInput
    delivery_addresses?: delivery_addressesOrderByRelationAggregateInput
    delivery_sales?: delivery_salesOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    product_sales?: product_salesOrderByRelationAggregateInput
    channels?: channelsOrderByWithRelationInput
    customers?: customersOrderByWithRelationInput
    stores?: storesOrderByWithRelationInput
    sub_brands?: sub_brandsOrderByWithRelationInput
  }

  export type salesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: salesWhereInput | salesWhereInput[]
    OR?: salesWhereInput[]
    NOT?: salesWhereInput | salesWhereInput[]
    store_id?: IntFilter<"sales"> | number
    sub_brand_id?: IntNullableFilter<"sales"> | number | null
    customer_id?: IntNullableFilter<"sales"> | number | null
    channel_id?: IntFilter<"sales"> | number
    cod_sale1?: StringNullableFilter<"sales"> | string | null
    cod_sale2?: StringNullableFilter<"sales"> | string | null
    created_at?: DateTimeFilter<"sales"> | Date | string
    customer_name?: StringNullableFilter<"sales"> | string | null
    sale_status_desc?: StringFilter<"sales"> | string
    total_amount_items?: DecimalFilter<"sales"> | Decimal | DecimalJsLike | number | string
    total_discount?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    total_increase?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFilter<"sales"> | Decimal | DecimalJsLike | number | string
    value_paid?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    production_seconds?: IntNullableFilter<"sales"> | number | null
    delivery_seconds?: IntNullableFilter<"sales"> | number | null
    people_quantity?: IntNullableFilter<"sales"> | number | null
    discount_reason?: StringNullableFilter<"sales"> | string | null
    increase_reason?: StringNullableFilter<"sales"> | string | null
    origin?: StringNullableFilter<"sales"> | string | null
    coupon_sales?: Coupon_salesListRelationFilter
    delivery_addresses?: Delivery_addressesListRelationFilter
    delivery_sales?: Delivery_salesListRelationFilter
    payments?: PaymentsListRelationFilter
    product_sales?: Product_salesListRelationFilter
    channels?: XOR<ChannelsScalarRelationFilter, channelsWhereInput>
    customers?: XOR<CustomersNullableScalarRelationFilter, customersWhereInput> | null
    stores?: XOR<StoresScalarRelationFilter, storesWhereInput>
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }, "id">

  export type salesOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    customer_id?: SortOrderInput | SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrderInput | SortOrder
    cod_sale2?: SortOrderInput | SortOrder
    created_at?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrderInput | SortOrder
    total_increase?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    service_tax_fee?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrderInput | SortOrder
    production_seconds?: SortOrderInput | SortOrder
    delivery_seconds?: SortOrderInput | SortOrder
    people_quantity?: SortOrderInput | SortOrder
    discount_reason?: SortOrderInput | SortOrder
    increase_reason?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    _count?: salesCountOrderByAggregateInput
    _avg?: salesAvgOrderByAggregateInput
    _max?: salesMaxOrderByAggregateInput
    _min?: salesMinOrderByAggregateInput
    _sum?: salesSumOrderByAggregateInput
  }

  export type salesScalarWhereWithAggregatesInput = {
    AND?: salesScalarWhereWithAggregatesInput | salesScalarWhereWithAggregatesInput[]
    OR?: salesScalarWhereWithAggregatesInput[]
    NOT?: salesScalarWhereWithAggregatesInput | salesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sales"> | number
    store_id?: IntWithAggregatesFilter<"sales"> | number
    sub_brand_id?: IntNullableWithAggregatesFilter<"sales"> | number | null
    customer_id?: IntNullableWithAggregatesFilter<"sales"> | number | null
    channel_id?: IntWithAggregatesFilter<"sales"> | number
    cod_sale1?: StringNullableWithAggregatesFilter<"sales"> | string | null
    cod_sale2?: StringNullableWithAggregatesFilter<"sales"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"sales"> | Date | string
    customer_name?: StringNullableWithAggregatesFilter<"sales"> | string | null
    sale_status_desc?: StringWithAggregatesFilter<"sales"> | string
    total_amount_items?: DecimalWithAggregatesFilter<"sales"> | Decimal | DecimalJsLike | number | string
    total_discount?: DecimalNullableWithAggregatesFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    total_increase?: DecimalNullableWithAggregatesFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: DecimalNullableWithAggregatesFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: DecimalNullableWithAggregatesFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalWithAggregatesFilter<"sales"> | Decimal | DecimalJsLike | number | string
    value_paid?: DecimalNullableWithAggregatesFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    production_seconds?: IntNullableWithAggregatesFilter<"sales"> | number | null
    delivery_seconds?: IntNullableWithAggregatesFilter<"sales"> | number | null
    people_quantity?: IntNullableWithAggregatesFilter<"sales"> | number | null
    discount_reason?: StringNullableWithAggregatesFilter<"sales"> | string | null
    increase_reason?: StringNullableWithAggregatesFilter<"sales"> | string | null
    origin?: StringNullableWithAggregatesFilter<"sales"> | string | null
  }

  export type storesWhereInput = {
    AND?: storesWhereInput | storesWhereInput[]
    OR?: storesWhereInput[]
    NOT?: storesWhereInput | storesWhereInput[]
    id?: IntFilter<"stores"> | number
    brand_id?: IntNullableFilter<"stores"> | number | null
    sub_brand_id?: IntNullableFilter<"stores"> | number | null
    name?: StringFilter<"stores"> | string
    city?: StringNullableFilter<"stores"> | string | null
    state?: StringNullableFilter<"stores"> | string | null
    district?: StringNullableFilter<"stores"> | string | null
    address_street?: StringNullableFilter<"stores"> | string | null
    address_number?: IntNullableFilter<"stores"> | number | null
    zipcode?: StringNullableFilter<"stores"> | string | null
    latitude?: DecimalNullableFilter<"stores"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"stores"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"stores"> | boolean | null
    is_own?: BoolNullableFilter<"stores"> | boolean | null
    is_holding?: BoolNullableFilter<"stores"> | boolean | null
    creation_date?: DateTimeNullableFilter<"stores"> | Date | string | null
    created_at?: DateTimeNullableFilter<"stores"> | Date | string | null
    customers?: CustomersListRelationFilter
    sales?: SalesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }

  export type storesOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    address_street?: SortOrderInput | SortOrder
    address_number?: SortOrderInput | SortOrder
    zipcode?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    is_own?: SortOrderInput | SortOrder
    is_holding?: SortOrderInput | SortOrder
    creation_date?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    customers?: customersOrderByRelationAggregateInput
    sales?: salesOrderByRelationAggregateInput
    brands?: brandsOrderByWithRelationInput
    sub_brands?: sub_brandsOrderByWithRelationInput
  }

  export type storesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: storesWhereInput | storesWhereInput[]
    OR?: storesWhereInput[]
    NOT?: storesWhereInput | storesWhereInput[]
    brand_id?: IntNullableFilter<"stores"> | number | null
    sub_brand_id?: IntNullableFilter<"stores"> | number | null
    name?: StringFilter<"stores"> | string
    city?: StringNullableFilter<"stores"> | string | null
    state?: StringNullableFilter<"stores"> | string | null
    district?: StringNullableFilter<"stores"> | string | null
    address_street?: StringNullableFilter<"stores"> | string | null
    address_number?: IntNullableFilter<"stores"> | number | null
    zipcode?: StringNullableFilter<"stores"> | string | null
    latitude?: DecimalNullableFilter<"stores"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"stores"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"stores"> | boolean | null
    is_own?: BoolNullableFilter<"stores"> | boolean | null
    is_holding?: BoolNullableFilter<"stores"> | boolean | null
    creation_date?: DateTimeNullableFilter<"stores"> | Date | string | null
    created_at?: DateTimeNullableFilter<"stores"> | Date | string | null
    customers?: CustomersListRelationFilter
    sales?: SalesListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    sub_brands?: XOR<Sub_brandsNullableScalarRelationFilter, sub_brandsWhereInput> | null
  }, "id">

  export type storesOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    address_street?: SortOrderInput | SortOrder
    address_number?: SortOrderInput | SortOrder
    zipcode?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    is_own?: SortOrderInput | SortOrder
    is_holding?: SortOrderInput | SortOrder
    creation_date?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: storesCountOrderByAggregateInput
    _avg?: storesAvgOrderByAggregateInput
    _max?: storesMaxOrderByAggregateInput
    _min?: storesMinOrderByAggregateInput
    _sum?: storesSumOrderByAggregateInput
  }

  export type storesScalarWhereWithAggregatesInput = {
    AND?: storesScalarWhereWithAggregatesInput | storesScalarWhereWithAggregatesInput[]
    OR?: storesScalarWhereWithAggregatesInput[]
    NOT?: storesScalarWhereWithAggregatesInput | storesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"stores"> | number
    brand_id?: IntNullableWithAggregatesFilter<"stores"> | number | null
    sub_brand_id?: IntNullableWithAggregatesFilter<"stores"> | number | null
    name?: StringWithAggregatesFilter<"stores"> | string
    city?: StringNullableWithAggregatesFilter<"stores"> | string | null
    state?: StringNullableWithAggregatesFilter<"stores"> | string | null
    district?: StringNullableWithAggregatesFilter<"stores"> | string | null
    address_street?: StringNullableWithAggregatesFilter<"stores"> | string | null
    address_number?: IntNullableWithAggregatesFilter<"stores"> | number | null
    zipcode?: StringNullableWithAggregatesFilter<"stores"> | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"stores"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"stores"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableWithAggregatesFilter<"stores"> | boolean | null
    is_own?: BoolNullableWithAggregatesFilter<"stores"> | boolean | null
    is_holding?: BoolNullableWithAggregatesFilter<"stores"> | boolean | null
    creation_date?: DateTimeNullableWithAggregatesFilter<"stores"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"stores"> | Date | string | null
  }

  export type sub_brandsWhereInput = {
    AND?: sub_brandsWhereInput | sub_brandsWhereInput[]
    OR?: sub_brandsWhereInput[]
    NOT?: sub_brandsWhereInput | sub_brandsWhereInput[]
    id?: IntFilter<"sub_brands"> | number
    brand_id?: IntNullableFilter<"sub_brands"> | number | null
    name?: StringFilter<"sub_brands"> | string
    created_at?: DateTimeNullableFilter<"sub_brands"> | Date | string | null
    categories?: CategoriesListRelationFilter
    customers?: CustomersListRelationFilter
    items?: ItemsListRelationFilter
    option_groups?: Option_groupsListRelationFilter
    products?: ProductsListRelationFilter
    sales?: SalesListRelationFilter
    stores?: StoresListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
  }

  export type sub_brandsOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    categories?: categoriesOrderByRelationAggregateInput
    customers?: customersOrderByRelationAggregateInput
    items?: itemsOrderByRelationAggregateInput
    option_groups?: option_groupsOrderByRelationAggregateInput
    products?: productsOrderByRelationAggregateInput
    sales?: salesOrderByRelationAggregateInput
    stores?: storesOrderByRelationAggregateInput
    brands?: brandsOrderByWithRelationInput
  }

  export type sub_brandsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sub_brandsWhereInput | sub_brandsWhereInput[]
    OR?: sub_brandsWhereInput[]
    NOT?: sub_brandsWhereInput | sub_brandsWhereInput[]
    brand_id?: IntNullableFilter<"sub_brands"> | number | null
    name?: StringFilter<"sub_brands"> | string
    created_at?: DateTimeNullableFilter<"sub_brands"> | Date | string | null
    categories?: CategoriesListRelationFilter
    customers?: CustomersListRelationFilter
    items?: ItemsListRelationFilter
    option_groups?: Option_groupsListRelationFilter
    products?: ProductsListRelationFilter
    sales?: SalesListRelationFilter
    stores?: StoresListRelationFilter
    brands?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
  }, "id">

  export type sub_brandsOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: sub_brandsCountOrderByAggregateInput
    _avg?: sub_brandsAvgOrderByAggregateInput
    _max?: sub_brandsMaxOrderByAggregateInput
    _min?: sub_brandsMinOrderByAggregateInput
    _sum?: sub_brandsSumOrderByAggregateInput
  }

  export type sub_brandsScalarWhereWithAggregatesInput = {
    AND?: sub_brandsScalarWhereWithAggregatesInput | sub_brandsScalarWhereWithAggregatesInput[]
    OR?: sub_brandsScalarWhereWithAggregatesInput[]
    NOT?: sub_brandsScalarWhereWithAggregatesInput | sub_brandsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sub_brands"> | number
    brand_id?: IntNullableWithAggregatesFilter<"sub_brands"> | number | null
    name?: StringWithAggregatesFilter<"sub_brands"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"sub_brands"> | Date | string | null
  }

  export type brandsCreateInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    channels?: channelsCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type brandsCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string | null
  }

  export type brandsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type brandsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoriesCreateInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brands?: brandsCreateNestedOneWithoutCategoriesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutCategoriesInput
    items?: itemsCreateNestedManyWithoutCategoriesInput
    option_groups?: option_groupsCreateNestedManyWithoutCategoriesInput
    products?: productsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    items?: itemsUncheckedCreateNestedManyWithoutCategoriesInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutCategoriesInput
    products?: productsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutCategoriesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutCategoriesNestedInput
    items?: itemsUpdateManyWithoutCategoriesNestedInput
    option_groups?: option_groupsUpdateManyWithoutCategoriesNestedInput
    products?: productsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUncheckedUpdateManyWithoutCategoriesNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutCategoriesNestedInput
    products?: productsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type categoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type channelsCreateInput = {
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    brands?: brandsCreateNestedOneWithoutChannelsInput
    sales?: salesCreateNestedManyWithoutChannelsInput
  }

  export type channelsUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    sales?: salesUncheckedCreateNestedManyWithoutChannelsInput
  }

  export type channelsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutChannelsNestedInput
    sales?: salesUpdateManyWithoutChannelsNestedInput
  }

  export type channelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: salesUncheckedUpdateManyWithoutChannelsNestedInput
  }

  export type channelsCreateManyInput = {
    id?: number
    brand_id?: number | null
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type channelsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type channelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type coupon_salesCreateInput = {
    value?: number | null
    target?: string | null
    sponsorship?: string | null
    coupons?: couponsCreateNestedOneWithoutCoupon_salesInput
    sales?: salesCreateNestedOneWithoutCoupon_salesInput
  }

  export type coupon_salesUncheckedCreateInput = {
    id?: number
    sale_id?: number | null
    coupon_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type coupon_salesUpdateInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
    coupons?: couponsUpdateOneWithoutCoupon_salesNestedInput
    sales?: salesUpdateOneWithoutCoupon_salesNestedInput
  }

  export type coupon_salesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coupon_salesCreateManyInput = {
    id?: number
    sale_id?: number | null
    coupon_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type coupon_salesUpdateManyMutationInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coupon_salesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponsCreateInput = {
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutCouponsInput
    brands?: brandsCreateNestedOneWithoutCouponsInput
  }

  export type couponsUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutCouponsInput
  }

  export type couponsUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutCouponsNestedInput
    brands?: brandsUpdateOneWithoutCouponsNestedInput
  }

  export type couponsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutCouponsNestedInput
  }

  export type couponsCreateManyInput = {
    id?: number
    brand_id?: number | null
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
  }

  export type couponsUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customersCreateInput = {
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    stores?: storesCreateNestedOneWithoutCustomersInput
    sub_brands?: sub_brandsCreateNestedOneWithoutCustomersInput
    sales?: salesCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    sales?: salesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersUpdateInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storesUpdateOneWithoutCustomersNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutCustomersNestedInput
    sales?: salesUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: salesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type customersCreateManyInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
  }

  export type customersUpdateManyMutationInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type delivery_addressesCreateInput = {
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
    delivery_sales?: delivery_salesCreateNestedOneWithoutDelivery_addressesInput
    sales: salesCreateNestedOneWithoutDelivery_addressesInput
  }

  export type delivery_addressesUncheckedCreateInput = {
    id?: number
    sale_id: number
    delivery_sale_id?: number | null
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type delivery_addressesUpdateInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_sales?: delivery_salesUpdateOneWithoutDelivery_addressesNestedInput
    sales?: salesUpdateOneRequiredWithoutDelivery_addressesNestedInput
  }

  export type delivery_addressesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    delivery_sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type delivery_addressesCreateManyInput = {
    id?: number
    sale_id: number
    delivery_sale_id?: number | null
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type delivery_addressesUpdateManyMutationInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type delivery_addressesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    delivery_sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type delivery_salesCreateInput = {
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutDelivery_salesInput
    sales: salesCreateNestedOneWithoutDelivery_salesInput
  }

  export type delivery_salesUncheckedCreateInput = {
    id?: number
    sale_id: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutDelivery_salesInput
  }

  export type delivery_salesUpdateInput = {
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_addresses?: delivery_addressesUpdateManyWithoutDelivery_salesNestedInput
    sales?: salesUpdateOneRequiredWithoutDelivery_salesNestedInput
  }

  export type delivery_salesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutDelivery_salesNestedInput
  }

  export type delivery_salesCreateManyInput = {
    id?: number
    sale_id: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
  }

  export type delivery_salesUpdateManyMutationInput = {
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type delivery_salesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type item_item_product_salesCreateInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    items: itemsCreateNestedOneWithoutItem_item_product_salesInput
    item_product_sales: item_product_salesCreateNestedOneWithoutItem_item_product_salesInput
    option_groups?: option_groupsCreateNestedOneWithoutItem_item_product_salesInput
  }

  export type item_item_product_salesUncheckedCreateInput = {
    id?: number
    item_product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type item_item_product_salesUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    items?: itemsUpdateOneRequiredWithoutItem_item_product_salesNestedInput
    item_product_sales?: item_product_salesUpdateOneRequiredWithoutItem_item_product_salesNestedInput
    option_groups?: option_groupsUpdateOneWithoutItem_item_product_salesNestedInput
  }

  export type item_item_product_salesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_item_product_salesCreateManyInput = {
    id?: number
    item_product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type item_item_product_salesUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_item_product_salesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_product_salesCreateInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItem_product_salesInput
    items: itemsCreateNestedOneWithoutItem_product_salesInput
    option_groups?: option_groupsCreateNestedOneWithoutItem_product_salesInput
    product_sales: product_salesCreateNestedOneWithoutItem_product_salesInput
  }

  export type item_product_salesUncheckedCreateInput = {
    id?: number
    product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItem_product_salesInput
  }

  export type item_product_salesUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItem_product_salesNestedInput
    items?: itemsUpdateOneRequiredWithoutItem_product_salesNestedInput
    option_groups?: option_groupsUpdateOneWithoutItem_product_salesNestedInput
    product_sales?: product_salesUpdateOneRequiredWithoutItem_product_salesNestedInput
  }

  export type item_product_salesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItem_product_salesNestedInput
  }

  export type item_product_salesCreateManyInput = {
    id?: number
    product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type item_product_salesUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type item_product_salesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemsCreateInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItemsInput
    item_product_sales?: item_product_salesCreateNestedManyWithoutItemsInput
    brands?: brandsCreateNestedOneWithoutItemsInput
    categories?: categoriesCreateNestedOneWithoutItemsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItemsInput
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItemsNestedInput
    item_product_sales?: item_product_salesUpdateManyWithoutItemsNestedInput
    brands?: brandsUpdateOneWithoutItemsNestedInput
    categories?: categoriesUpdateOneWithoutItemsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type itemsCreateManyInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type itemsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type option_groupsCreateInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutOption_groupsInput
    item_product_sales?: item_product_salesCreateNestedManyWithoutOption_groupsInput
    brands?: brandsCreateNestedOneWithoutOption_groupsInput
    categories?: categoriesCreateNestedOneWithoutOption_groupsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutOption_groupsInput
  }

  export type option_groupsUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
  }

  export type option_groupsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutOption_groupsNestedInput
    item_product_sales?: item_product_salesUpdateManyWithoutOption_groupsNestedInput
    brands?: brandsUpdateOneWithoutOption_groupsNestedInput
    categories?: categoriesUpdateOneWithoutOption_groupsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
  }

  export type option_groupsCreateManyInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type option_groupsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type option_groupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_typesCreateInput = {
    description: string
    brands?: brandsCreateNestedOneWithoutPayment_typesInput
    payments?: paymentsCreateNestedManyWithoutPayment_typesInput
  }

  export type payment_typesUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    description: string
    payments?: paymentsUncheckedCreateNestedManyWithoutPayment_typesInput
  }

  export type payment_typesUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    brands?: brandsUpdateOneWithoutPayment_typesNestedInput
    payments?: paymentsUpdateManyWithoutPayment_typesNestedInput
  }

  export type payment_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    payments?: paymentsUncheckedUpdateManyWithoutPayment_typesNestedInput
  }

  export type payment_typesCreateManyInput = {
    id?: number
    brand_id?: number | null
    description: string
  }

  export type payment_typesUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type payment_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsCreateInput = {
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
    payment_types?: payment_typesCreateNestedOneWithoutPaymentsInput
    sales: salesCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: number
    sale_id: number
    payment_type_id?: number | null
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentsUpdateInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_types?: payment_typesUpdateOneWithoutPaymentsNestedInput
    sales?: salesUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsCreateManyInput = {
    id?: number
    sale_id: number
    payment_type_id?: number | null
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentsUpdateManyMutationInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type product_salesCreateInput = {
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    item_product_sales?: item_product_salesCreateNestedManyWithoutProduct_salesInput
    products: productsCreateNestedOneWithoutProduct_salesInput
    sales: salesCreateNestedOneWithoutProduct_salesInput
  }

  export type product_salesUncheckedCreateInput = {
    id?: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutProduct_salesInput
  }

  export type product_salesUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_product_sales?: item_product_salesUpdateManyWithoutProduct_salesNestedInput
    products?: productsUpdateOneRequiredWithoutProduct_salesNestedInput
    sales?: salesUpdateOneRequiredWithoutProduct_salesNestedInput
  }

  export type product_salesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutProduct_salesNestedInput
  }

  export type product_salesCreateManyInput = {
    id?: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
  }

  export type product_salesUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type product_salesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsCreateInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    product_sales?: product_salesCreateNestedManyWithoutProductsInput
    brands?: brandsCreateNestedOneWithoutProductsInput
    categories?: categoriesCreateNestedOneWithoutProductsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    product_sales?: product_salesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_sales?: product_salesUpdateManyWithoutProductsNestedInput
    brands?: brandsUpdateOneWithoutProductsNestedInput
    categories?: categoriesUpdateOneWithoutProductsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_sales?: product_salesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsCreateManyInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salesCreateInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesUpdateInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type salesCreateManyInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type salesUpdateManyMutationInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type salesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storesCreateInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customersCreateNestedManyWithoutStoresInput
    sales?: salesCreateNestedManyWithoutStoresInput
    brands?: brandsCreateNestedOneWithoutStoresInput
    sub_brands?: sub_brandsCreateNestedOneWithoutStoresInput
  }

  export type storesUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customersUncheckedCreateNestedManyWithoutStoresInput
    sales?: salesUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUpdateManyWithoutStoresNestedInput
    sales?: salesUpdateManyWithoutStoresNestedInput
    brands?: brandsUpdateOneWithoutStoresNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUncheckedUpdateManyWithoutStoresNestedInput
    sales?: salesUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type storesCreateManyInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type storesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_brandsCreateInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutSub_brandsInput
    customers?: customersCreateNestedManyWithoutSub_brandsInput
    items?: itemsCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsCreateNestedManyWithoutSub_brandsInput
    products?: productsCreateNestedManyWithoutSub_brandsInput
    sales?: salesCreateNestedManyWithoutSub_brandsInput
    stores?: storesCreateNestedManyWithoutSub_brandsInput
    brands?: brandsCreateNestedOneWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSub_brandsInput
    customers?: customersUncheckedCreateNestedManyWithoutSub_brandsInput
    items?: itemsUncheckedCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput
    products?: productsUncheckedCreateNestedManyWithoutSub_brandsInput
    sales?: salesUncheckedCreateNestedManyWithoutSub_brandsInput
    stores?: storesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutSub_brandsNestedInput
    products?: productsUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUpdateManyWithoutSub_brandsNestedInput
    brands?: brandsUpdateOneWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUncheckedUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput
    products?: productsUncheckedUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUncheckedUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type sub_brandsCreateManyInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
  }

  export type sub_brandsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_brandsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CategoriesListRelationFilter = {
    every?: categoriesWhereInput
    some?: categoriesWhereInput
    none?: categoriesWhereInput
  }

  export type ChannelsListRelationFilter = {
    every?: channelsWhereInput
    some?: channelsWhereInput
    none?: channelsWhereInput
  }

  export type CouponsListRelationFilter = {
    every?: couponsWhereInput
    some?: couponsWhereInput
    none?: couponsWhereInput
  }

  export type ItemsListRelationFilter = {
    every?: itemsWhereInput
    some?: itemsWhereInput
    none?: itemsWhereInput
  }

  export type Option_groupsListRelationFilter = {
    every?: option_groupsWhereInput
    some?: option_groupsWhereInput
    none?: option_groupsWhereInput
  }

  export type Payment_typesListRelationFilter = {
    every?: payment_typesWhereInput
    some?: payment_typesWhereInput
    none?: payment_typesWhereInput
  }

  export type ProductsListRelationFilter = {
    every?: productsWhereInput
    some?: productsWhereInput
    none?: productsWhereInput
  }

  export type StoresListRelationFilter = {
    every?: storesWhereInput
    some?: storesWhereInput
    none?: storesWhereInput
  }

  export type Sub_brandsListRelationFilter = {
    every?: sub_brandsWhereInput
    some?: sub_brandsWhereInput
    none?: sub_brandsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type categoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type channelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type couponsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type option_groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_typesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type storesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sub_brandsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type brandsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type brandsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type brandsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type brandsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type brandsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BrandsNullableScalarRelationFilter = {
    is?: brandsWhereInput | null
    isNot?: brandsWhereInput | null
  }

  export type Sub_brandsNullableScalarRelationFilter = {
    is?: sub_brandsWhereInput | null
    isNot?: sub_brandsWhereInput | null
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type SalesListRelationFilter = {
    every?: salesWhereInput
    some?: salesWhereInput
    none?: salesWhereInput
  }

  export type salesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type channelsCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type channelsAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type channelsMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type channelsMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type channelsSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CouponsNullableScalarRelationFilter = {
    is?: couponsWhereInput | null
    isNot?: couponsWhereInput | null
  }

  export type SalesNullableScalarRelationFilter = {
    is?: salesWhereInput | null
    isNot?: salesWhereInput | null
  }

  export type coupon_salesCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
    target?: SortOrder
    sponsorship?: SortOrder
  }

  export type coupon_salesAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
  }

  export type coupon_salesMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
    target?: SortOrder
    sponsorship?: SortOrder
  }

  export type coupon_salesMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
    target?: SortOrder
    sponsorship?: SortOrder
  }

  export type coupon_salesSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Coupon_salesListRelationFilter = {
    every?: coupon_salesWhereInput
    some?: coupon_salesWhereInput
    none?: coupon_salesWhereInput
  }

  export type coupon_salesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type couponsCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    is_active?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
  }

  export type couponsAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    discount_value?: SortOrder
  }

  export type couponsMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    is_active?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
  }

  export type couponsMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    is_active?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
  }

  export type couponsSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    discount_value?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StoresNullableScalarRelationFilter = {
    is?: storesWhereInput | null
    isNot?: storesWhereInput | null
  }

  export type customersCountOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    cpf?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    registration_origin?: SortOrder
    agree_terms?: SortOrder
    receive_promotions_email?: SortOrder
    receive_promotions_sms?: SortOrder
    created_at?: SortOrder
  }

  export type customersAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
  }

  export type customersMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    cpf?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    registration_origin?: SortOrder
    agree_terms?: SortOrder
    receive_promotions_email?: SortOrder
    receive_promotions_sms?: SortOrder
    created_at?: SortOrder
  }

  export type customersMinOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    cpf?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    registration_origin?: SortOrder
    agree_terms?: SortOrder
    receive_promotions_email?: SortOrder
    receive_promotions_sms?: SortOrder
    created_at?: SortOrder
  }

  export type customersSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
  }

  export type Delivery_salesNullableScalarRelationFilter = {
    is?: delivery_salesWhereInput | null
    isNot?: delivery_salesWhereInput | null
  }

  export type SalesScalarRelationFilter = {
    is?: salesWhereInput
    isNot?: salesWhereInput
  }

  export type delivery_addressesCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    formatted_address?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    reference?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type delivery_addressesAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type delivery_addressesMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    formatted_address?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    reference?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type delivery_addressesMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    formatted_address?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    reference?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type delivery_addressesSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type Delivery_addressesListRelationFilter = {
    every?: delivery_addressesWhereInput
    some?: delivery_addressesWhereInput
    none?: delivery_addressesWhereInput
  }

  export type delivery_addressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type delivery_salesCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrder
    courier_name?: SortOrder
    courier_phone?: SortOrder
    courier_type?: SortOrder
    delivered_by?: SortOrder
    delivery_type?: SortOrder
    status?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
    timing?: SortOrder
    mode?: SortOrder
  }

  export type delivery_salesAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
  }

  export type delivery_salesMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrder
    courier_name?: SortOrder
    courier_phone?: SortOrder
    courier_type?: SortOrder
    delivered_by?: SortOrder
    delivery_type?: SortOrder
    status?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
    timing?: SortOrder
    mode?: SortOrder
  }

  export type delivery_salesMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrder
    courier_name?: SortOrder
    courier_phone?: SortOrder
    courier_type?: SortOrder
    delivered_by?: SortOrder
    delivery_type?: SortOrder
    status?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
    timing?: SortOrder
    mode?: SortOrder
  }

  export type delivery_salesSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ItemsScalarRelationFilter = {
    is?: itemsWhereInput
    isNot?: itemsWhereInput
  }

  export type Item_product_salesScalarRelationFilter = {
    is?: item_product_salesWhereInput
    isNot?: item_product_salesWhereInput
  }

  export type Option_groupsNullableScalarRelationFilter = {
    is?: option_groupsWhereInput | null
    isNot?: option_groupsWhereInput | null
  }

  export type item_item_product_salesCountOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type item_item_product_salesAvgOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type item_item_product_salesMaxOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type item_item_product_salesMinOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type item_item_product_salesSumOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Item_item_product_salesListRelationFilter = {
    every?: item_item_product_salesWhereInput
    some?: item_item_product_salesWhereInput
    none?: item_item_product_salesWhereInput
  }

  export type Product_salesScalarRelationFilter = {
    is?: product_salesWhereInput
    isNot?: product_salesWhereInput
  }

  export type item_item_product_salesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type item_product_salesCountOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    observations?: SortOrder
  }

  export type item_product_salesAvgOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type item_product_salesMaxOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    observations?: SortOrder
  }

  export type item_product_salesMinOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    observations?: SortOrder
  }

  export type item_product_salesSumOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type Item_product_salesListRelationFilter = {
    every?: item_product_salesWhereInput
    some?: item_product_salesWhereInput
    none?: item_product_salesWhereInput
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type item_product_salesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemsCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type itemsMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type itemsSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type option_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type option_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type option_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type option_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type option_groupsSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_typesCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    description?: SortOrder
  }

  export type payment_typesAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type payment_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    description?: SortOrder
  }

  export type payment_typesMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    description?: SortOrder
  }

  export type payment_typesSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Payment_typesNullableScalarRelationFilter = {
    is?: payment_typesWhereInput | null
    isNot?: payment_typesWhereInput | null
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
    is_online?: SortOrder
    description?: SortOrder
    currency?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
    is_online?: SortOrder
    description?: SortOrder
    currency?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
    is_online?: SortOrder
    description?: SortOrder
    currency?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProductsScalarRelationFilter = {
    is?: productsWhereInput
    isNot?: productsWhereInput
  }

  export type product_salesCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrder
  }

  export type product_salesAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
  }

  export type product_salesMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrder
  }

  export type product_salesMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrder
  }

  export type product_salesSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
  }

  export type Product_salesListRelationFilter = {
    every?: product_salesWhereInput
    some?: product_salesWhereInput
    none?: product_salesWhereInput
  }

  export type product_salesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type productsAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type productsSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Delivery_salesListRelationFilter = {
    every?: delivery_salesWhereInput
    some?: delivery_salesWhereInput
    none?: delivery_salesWhereInput
  }

  export type ChannelsScalarRelationFilter = {
    is?: channelsWhereInput
    isNot?: channelsWhereInput
  }

  export type CustomersNullableScalarRelationFilter = {
    is?: customersWhereInput | null
    isNot?: customersWhereInput | null
  }

  export type StoresScalarRelationFilter = {
    is?: storesWhereInput
    isNot?: storesWhereInput
  }

  export type delivery_salesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type salesCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrder
    cod_sale2?: SortOrder
    created_at?: SortOrder
    customer_name?: SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
    discount_reason?: SortOrder
    increase_reason?: SortOrder
    origin?: SortOrder
  }

  export type salesAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
  }

  export type salesMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrder
    cod_sale2?: SortOrder
    created_at?: SortOrder
    customer_name?: SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
    discount_reason?: SortOrder
    increase_reason?: SortOrder
    origin?: SortOrder
  }

  export type salesMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrder
    cod_sale2?: SortOrder
    created_at?: SortOrder
    customer_name?: SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
    discount_reason?: SortOrder
    increase_reason?: SortOrder
    origin?: SortOrder
  }

  export type salesSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CustomersListRelationFilter = {
    every?: customersWhereInput
    some?: customersWhereInput
    none?: customersWhereInput
  }

  export type customersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type storesCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    state?: SortOrder
    district?: SortOrder
    address_street?: SortOrder
    address_number?: SortOrder
    zipcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    is_active?: SortOrder
    is_own?: SortOrder
    is_holding?: SortOrder
    creation_date?: SortOrder
    created_at?: SortOrder
  }

  export type storesAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    address_number?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type storesMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    state?: SortOrder
    district?: SortOrder
    address_street?: SortOrder
    address_number?: SortOrder
    zipcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    is_active?: SortOrder
    is_own?: SortOrder
    is_holding?: SortOrder
    creation_date?: SortOrder
    created_at?: SortOrder
  }

  export type storesMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    state?: SortOrder
    district?: SortOrder
    address_street?: SortOrder
    address_number?: SortOrder
    zipcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    is_active?: SortOrder
    is_own?: SortOrder
    is_holding?: SortOrder
    creation_date?: SortOrder
    created_at?: SortOrder
  }

  export type storesSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    address_number?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type sub_brandsCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type sub_brandsAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type sub_brandsMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type sub_brandsMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type sub_brandsSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type categoriesCreateNestedManyWithoutBrandsInput = {
    create?: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput> | categoriesCreateWithoutBrandsInput[] | categoriesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutBrandsInput | categoriesCreateOrConnectWithoutBrandsInput[]
    createMany?: categoriesCreateManyBrandsInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type channelsCreateNestedManyWithoutBrandsInput = {
    create?: XOR<channelsCreateWithoutBrandsInput, channelsUncheckedCreateWithoutBrandsInput> | channelsCreateWithoutBrandsInput[] | channelsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: channelsCreateOrConnectWithoutBrandsInput | channelsCreateOrConnectWithoutBrandsInput[]
    createMany?: channelsCreateManyBrandsInputEnvelope
    connect?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
  }

  export type couponsCreateNestedManyWithoutBrandsInput = {
    create?: XOR<couponsCreateWithoutBrandsInput, couponsUncheckedCreateWithoutBrandsInput> | couponsCreateWithoutBrandsInput[] | couponsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: couponsCreateOrConnectWithoutBrandsInput | couponsCreateOrConnectWithoutBrandsInput[]
    createMany?: couponsCreateManyBrandsInputEnvelope
    connect?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
  }

  export type itemsCreateNestedManyWithoutBrandsInput = {
    create?: XOR<itemsCreateWithoutBrandsInput, itemsUncheckedCreateWithoutBrandsInput> | itemsCreateWithoutBrandsInput[] | itemsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutBrandsInput | itemsCreateOrConnectWithoutBrandsInput[]
    createMany?: itemsCreateManyBrandsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type option_groupsCreateNestedManyWithoutBrandsInput = {
    create?: XOR<option_groupsCreateWithoutBrandsInput, option_groupsUncheckedCreateWithoutBrandsInput> | option_groupsCreateWithoutBrandsInput[] | option_groupsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutBrandsInput | option_groupsCreateOrConnectWithoutBrandsInput[]
    createMany?: option_groupsCreateManyBrandsInputEnvelope
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
  }

  export type payment_typesCreateNestedManyWithoutBrandsInput = {
    create?: XOR<payment_typesCreateWithoutBrandsInput, payment_typesUncheckedCreateWithoutBrandsInput> | payment_typesCreateWithoutBrandsInput[] | payment_typesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: payment_typesCreateOrConnectWithoutBrandsInput | payment_typesCreateOrConnectWithoutBrandsInput[]
    createMany?: payment_typesCreateManyBrandsInputEnvelope
    connect?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
  }

  export type productsCreateNestedManyWithoutBrandsInput = {
    create?: XOR<productsCreateWithoutBrandsInput, productsUncheckedCreateWithoutBrandsInput> | productsCreateWithoutBrandsInput[] | productsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandsInput | productsCreateOrConnectWithoutBrandsInput[]
    createMany?: productsCreateManyBrandsInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type storesCreateNestedManyWithoutBrandsInput = {
    create?: XOR<storesCreateWithoutBrandsInput, storesUncheckedCreateWithoutBrandsInput> | storesCreateWithoutBrandsInput[] | storesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: storesCreateOrConnectWithoutBrandsInput | storesCreateOrConnectWithoutBrandsInput[]
    createMany?: storesCreateManyBrandsInputEnvelope
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
  }

  export type sub_brandsCreateNestedManyWithoutBrandsInput = {
    create?: XOR<sub_brandsCreateWithoutBrandsInput, sub_brandsUncheckedCreateWithoutBrandsInput> | sub_brandsCreateWithoutBrandsInput[] | sub_brandsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: sub_brandsCreateOrConnectWithoutBrandsInput | sub_brandsCreateOrConnectWithoutBrandsInput[]
    createMany?: sub_brandsCreateManyBrandsInputEnvelope
    connect?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
  }

  export type categoriesUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput> | categoriesCreateWithoutBrandsInput[] | categoriesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutBrandsInput | categoriesCreateOrConnectWithoutBrandsInput[]
    createMany?: categoriesCreateManyBrandsInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type channelsUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<channelsCreateWithoutBrandsInput, channelsUncheckedCreateWithoutBrandsInput> | channelsCreateWithoutBrandsInput[] | channelsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: channelsCreateOrConnectWithoutBrandsInput | channelsCreateOrConnectWithoutBrandsInput[]
    createMany?: channelsCreateManyBrandsInputEnvelope
    connect?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
  }

  export type couponsUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<couponsCreateWithoutBrandsInput, couponsUncheckedCreateWithoutBrandsInput> | couponsCreateWithoutBrandsInput[] | couponsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: couponsCreateOrConnectWithoutBrandsInput | couponsCreateOrConnectWithoutBrandsInput[]
    createMany?: couponsCreateManyBrandsInputEnvelope
    connect?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
  }

  export type itemsUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<itemsCreateWithoutBrandsInput, itemsUncheckedCreateWithoutBrandsInput> | itemsCreateWithoutBrandsInput[] | itemsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutBrandsInput | itemsCreateOrConnectWithoutBrandsInput[]
    createMany?: itemsCreateManyBrandsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type option_groupsUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<option_groupsCreateWithoutBrandsInput, option_groupsUncheckedCreateWithoutBrandsInput> | option_groupsCreateWithoutBrandsInput[] | option_groupsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutBrandsInput | option_groupsCreateOrConnectWithoutBrandsInput[]
    createMany?: option_groupsCreateManyBrandsInputEnvelope
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
  }

  export type payment_typesUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<payment_typesCreateWithoutBrandsInput, payment_typesUncheckedCreateWithoutBrandsInput> | payment_typesCreateWithoutBrandsInput[] | payment_typesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: payment_typesCreateOrConnectWithoutBrandsInput | payment_typesCreateOrConnectWithoutBrandsInput[]
    createMany?: payment_typesCreateManyBrandsInputEnvelope
    connect?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<productsCreateWithoutBrandsInput, productsUncheckedCreateWithoutBrandsInput> | productsCreateWithoutBrandsInput[] | productsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandsInput | productsCreateOrConnectWithoutBrandsInput[]
    createMany?: productsCreateManyBrandsInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type storesUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<storesCreateWithoutBrandsInput, storesUncheckedCreateWithoutBrandsInput> | storesCreateWithoutBrandsInput[] | storesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: storesCreateOrConnectWithoutBrandsInput | storesCreateOrConnectWithoutBrandsInput[]
    createMany?: storesCreateManyBrandsInputEnvelope
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
  }

  export type sub_brandsUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<sub_brandsCreateWithoutBrandsInput, sub_brandsUncheckedCreateWithoutBrandsInput> | sub_brandsCreateWithoutBrandsInput[] | sub_brandsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: sub_brandsCreateOrConnectWithoutBrandsInput | sub_brandsCreateOrConnectWithoutBrandsInput[]
    createMany?: sub_brandsCreateManyBrandsInputEnvelope
    connect?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type categoriesUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput> | categoriesCreateWithoutBrandsInput[] | categoriesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutBrandsInput | categoriesCreateOrConnectWithoutBrandsInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutBrandsInput | categoriesUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: categoriesCreateManyBrandsInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutBrandsInput | categoriesUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutBrandsInput | categoriesUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type channelsUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<channelsCreateWithoutBrandsInput, channelsUncheckedCreateWithoutBrandsInput> | channelsCreateWithoutBrandsInput[] | channelsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: channelsCreateOrConnectWithoutBrandsInput | channelsCreateOrConnectWithoutBrandsInput[]
    upsert?: channelsUpsertWithWhereUniqueWithoutBrandsInput | channelsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: channelsCreateManyBrandsInputEnvelope
    set?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
    disconnect?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
    delete?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
    connect?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
    update?: channelsUpdateWithWhereUniqueWithoutBrandsInput | channelsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: channelsUpdateManyWithWhereWithoutBrandsInput | channelsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: channelsScalarWhereInput | channelsScalarWhereInput[]
  }

  export type couponsUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<couponsCreateWithoutBrandsInput, couponsUncheckedCreateWithoutBrandsInput> | couponsCreateWithoutBrandsInput[] | couponsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: couponsCreateOrConnectWithoutBrandsInput | couponsCreateOrConnectWithoutBrandsInput[]
    upsert?: couponsUpsertWithWhereUniqueWithoutBrandsInput | couponsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: couponsCreateManyBrandsInputEnvelope
    set?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
    disconnect?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
    delete?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
    connect?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
    update?: couponsUpdateWithWhereUniqueWithoutBrandsInput | couponsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: couponsUpdateManyWithWhereWithoutBrandsInput | couponsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: couponsScalarWhereInput | couponsScalarWhereInput[]
  }

  export type itemsUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<itemsCreateWithoutBrandsInput, itemsUncheckedCreateWithoutBrandsInput> | itemsCreateWithoutBrandsInput[] | itemsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutBrandsInput | itemsCreateOrConnectWithoutBrandsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutBrandsInput | itemsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: itemsCreateManyBrandsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutBrandsInput | itemsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutBrandsInput | itemsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type option_groupsUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<option_groupsCreateWithoutBrandsInput, option_groupsUncheckedCreateWithoutBrandsInput> | option_groupsCreateWithoutBrandsInput[] | option_groupsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutBrandsInput | option_groupsCreateOrConnectWithoutBrandsInput[]
    upsert?: option_groupsUpsertWithWhereUniqueWithoutBrandsInput | option_groupsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: option_groupsCreateManyBrandsInputEnvelope
    set?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    disconnect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    delete?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    update?: option_groupsUpdateWithWhereUniqueWithoutBrandsInput | option_groupsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: option_groupsUpdateManyWithWhereWithoutBrandsInput | option_groupsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: option_groupsScalarWhereInput | option_groupsScalarWhereInput[]
  }

  export type payment_typesUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<payment_typesCreateWithoutBrandsInput, payment_typesUncheckedCreateWithoutBrandsInput> | payment_typesCreateWithoutBrandsInput[] | payment_typesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: payment_typesCreateOrConnectWithoutBrandsInput | payment_typesCreateOrConnectWithoutBrandsInput[]
    upsert?: payment_typesUpsertWithWhereUniqueWithoutBrandsInput | payment_typesUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: payment_typesCreateManyBrandsInputEnvelope
    set?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
    disconnect?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
    delete?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
    connect?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
    update?: payment_typesUpdateWithWhereUniqueWithoutBrandsInput | payment_typesUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: payment_typesUpdateManyWithWhereWithoutBrandsInput | payment_typesUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: payment_typesScalarWhereInput | payment_typesScalarWhereInput[]
  }

  export type productsUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<productsCreateWithoutBrandsInput, productsUncheckedCreateWithoutBrandsInput> | productsCreateWithoutBrandsInput[] | productsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandsInput | productsCreateOrConnectWithoutBrandsInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutBrandsInput | productsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: productsCreateManyBrandsInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutBrandsInput | productsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: productsUpdateManyWithWhereWithoutBrandsInput | productsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type storesUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<storesCreateWithoutBrandsInput, storesUncheckedCreateWithoutBrandsInput> | storesCreateWithoutBrandsInput[] | storesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: storesCreateOrConnectWithoutBrandsInput | storesCreateOrConnectWithoutBrandsInput[]
    upsert?: storesUpsertWithWhereUniqueWithoutBrandsInput | storesUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: storesCreateManyBrandsInputEnvelope
    set?: storesWhereUniqueInput | storesWhereUniqueInput[]
    disconnect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    delete?: storesWhereUniqueInput | storesWhereUniqueInput[]
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    update?: storesUpdateWithWhereUniqueWithoutBrandsInput | storesUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: storesUpdateManyWithWhereWithoutBrandsInput | storesUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: storesScalarWhereInput | storesScalarWhereInput[]
  }

  export type sub_brandsUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<sub_brandsCreateWithoutBrandsInput, sub_brandsUncheckedCreateWithoutBrandsInput> | sub_brandsCreateWithoutBrandsInput[] | sub_brandsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: sub_brandsCreateOrConnectWithoutBrandsInput | sub_brandsCreateOrConnectWithoutBrandsInput[]
    upsert?: sub_brandsUpsertWithWhereUniqueWithoutBrandsInput | sub_brandsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: sub_brandsCreateManyBrandsInputEnvelope
    set?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
    disconnect?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
    delete?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
    connect?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
    update?: sub_brandsUpdateWithWhereUniqueWithoutBrandsInput | sub_brandsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: sub_brandsUpdateManyWithWhereWithoutBrandsInput | sub_brandsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: sub_brandsScalarWhereInput | sub_brandsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type categoriesUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput> | categoriesCreateWithoutBrandsInput[] | categoriesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutBrandsInput | categoriesCreateOrConnectWithoutBrandsInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutBrandsInput | categoriesUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: categoriesCreateManyBrandsInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutBrandsInput | categoriesUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutBrandsInput | categoriesUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type channelsUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<channelsCreateWithoutBrandsInput, channelsUncheckedCreateWithoutBrandsInput> | channelsCreateWithoutBrandsInput[] | channelsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: channelsCreateOrConnectWithoutBrandsInput | channelsCreateOrConnectWithoutBrandsInput[]
    upsert?: channelsUpsertWithWhereUniqueWithoutBrandsInput | channelsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: channelsCreateManyBrandsInputEnvelope
    set?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
    disconnect?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
    delete?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
    connect?: channelsWhereUniqueInput | channelsWhereUniqueInput[]
    update?: channelsUpdateWithWhereUniqueWithoutBrandsInput | channelsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: channelsUpdateManyWithWhereWithoutBrandsInput | channelsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: channelsScalarWhereInput | channelsScalarWhereInput[]
  }

  export type couponsUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<couponsCreateWithoutBrandsInput, couponsUncheckedCreateWithoutBrandsInput> | couponsCreateWithoutBrandsInput[] | couponsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: couponsCreateOrConnectWithoutBrandsInput | couponsCreateOrConnectWithoutBrandsInput[]
    upsert?: couponsUpsertWithWhereUniqueWithoutBrandsInput | couponsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: couponsCreateManyBrandsInputEnvelope
    set?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
    disconnect?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
    delete?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
    connect?: couponsWhereUniqueInput | couponsWhereUniqueInput[]
    update?: couponsUpdateWithWhereUniqueWithoutBrandsInput | couponsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: couponsUpdateManyWithWhereWithoutBrandsInput | couponsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: couponsScalarWhereInput | couponsScalarWhereInput[]
  }

  export type itemsUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<itemsCreateWithoutBrandsInput, itemsUncheckedCreateWithoutBrandsInput> | itemsCreateWithoutBrandsInput[] | itemsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutBrandsInput | itemsCreateOrConnectWithoutBrandsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutBrandsInput | itemsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: itemsCreateManyBrandsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutBrandsInput | itemsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutBrandsInput | itemsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type option_groupsUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<option_groupsCreateWithoutBrandsInput, option_groupsUncheckedCreateWithoutBrandsInput> | option_groupsCreateWithoutBrandsInput[] | option_groupsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutBrandsInput | option_groupsCreateOrConnectWithoutBrandsInput[]
    upsert?: option_groupsUpsertWithWhereUniqueWithoutBrandsInput | option_groupsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: option_groupsCreateManyBrandsInputEnvelope
    set?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    disconnect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    delete?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    update?: option_groupsUpdateWithWhereUniqueWithoutBrandsInput | option_groupsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: option_groupsUpdateManyWithWhereWithoutBrandsInput | option_groupsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: option_groupsScalarWhereInput | option_groupsScalarWhereInput[]
  }

  export type payment_typesUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<payment_typesCreateWithoutBrandsInput, payment_typesUncheckedCreateWithoutBrandsInput> | payment_typesCreateWithoutBrandsInput[] | payment_typesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: payment_typesCreateOrConnectWithoutBrandsInput | payment_typesCreateOrConnectWithoutBrandsInput[]
    upsert?: payment_typesUpsertWithWhereUniqueWithoutBrandsInput | payment_typesUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: payment_typesCreateManyBrandsInputEnvelope
    set?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
    disconnect?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
    delete?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
    connect?: payment_typesWhereUniqueInput | payment_typesWhereUniqueInput[]
    update?: payment_typesUpdateWithWhereUniqueWithoutBrandsInput | payment_typesUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: payment_typesUpdateManyWithWhereWithoutBrandsInput | payment_typesUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: payment_typesScalarWhereInput | payment_typesScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<productsCreateWithoutBrandsInput, productsUncheckedCreateWithoutBrandsInput> | productsCreateWithoutBrandsInput[] | productsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandsInput | productsCreateOrConnectWithoutBrandsInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutBrandsInput | productsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: productsCreateManyBrandsInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutBrandsInput | productsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: productsUpdateManyWithWhereWithoutBrandsInput | productsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type storesUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<storesCreateWithoutBrandsInput, storesUncheckedCreateWithoutBrandsInput> | storesCreateWithoutBrandsInput[] | storesUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: storesCreateOrConnectWithoutBrandsInput | storesCreateOrConnectWithoutBrandsInput[]
    upsert?: storesUpsertWithWhereUniqueWithoutBrandsInput | storesUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: storesCreateManyBrandsInputEnvelope
    set?: storesWhereUniqueInput | storesWhereUniqueInput[]
    disconnect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    delete?: storesWhereUniqueInput | storesWhereUniqueInput[]
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    update?: storesUpdateWithWhereUniqueWithoutBrandsInput | storesUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: storesUpdateManyWithWhereWithoutBrandsInput | storesUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: storesScalarWhereInput | storesScalarWhereInput[]
  }

  export type sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<sub_brandsCreateWithoutBrandsInput, sub_brandsUncheckedCreateWithoutBrandsInput> | sub_brandsCreateWithoutBrandsInput[] | sub_brandsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: sub_brandsCreateOrConnectWithoutBrandsInput | sub_brandsCreateOrConnectWithoutBrandsInput[]
    upsert?: sub_brandsUpsertWithWhereUniqueWithoutBrandsInput | sub_brandsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: sub_brandsCreateManyBrandsInputEnvelope
    set?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
    disconnect?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
    delete?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
    connect?: sub_brandsWhereUniqueInput | sub_brandsWhereUniqueInput[]
    update?: sub_brandsUpdateWithWhereUniqueWithoutBrandsInput | sub_brandsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: sub_brandsUpdateManyWithWhereWithoutBrandsInput | sub_brandsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: sub_brandsScalarWhereInput | sub_brandsScalarWhereInput[]
  }

  export type brandsCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<brandsCreateWithoutCategoriesInput, brandsUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: brandsCreateOrConnectWithoutCategoriesInput
    connect?: brandsWhereUniqueInput
  }

  export type sub_brandsCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<sub_brandsCreateWithoutCategoriesInput, sub_brandsUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutCategoriesInput
    connect?: sub_brandsWhereUniqueInput
  }

  export type itemsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<itemsCreateWithoutCategoriesInput, itemsUncheckedCreateWithoutCategoriesInput> | itemsCreateWithoutCategoriesInput[] | itemsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutCategoriesInput | itemsCreateOrConnectWithoutCategoriesInput[]
    createMany?: itemsCreateManyCategoriesInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type option_groupsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<option_groupsCreateWithoutCategoriesInput, option_groupsUncheckedCreateWithoutCategoriesInput> | option_groupsCreateWithoutCategoriesInput[] | option_groupsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutCategoriesInput | option_groupsCreateOrConnectWithoutCategoriesInput[]
    createMany?: option_groupsCreateManyCategoriesInputEnvelope
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
  }

  export type productsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput> | productsCreateWithoutCategoriesInput[] | productsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutCategoriesInput | productsCreateOrConnectWithoutCategoriesInput[]
    createMany?: productsCreateManyCategoriesInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type itemsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<itemsCreateWithoutCategoriesInput, itemsUncheckedCreateWithoutCategoriesInput> | itemsCreateWithoutCategoriesInput[] | itemsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutCategoriesInput | itemsCreateOrConnectWithoutCategoriesInput[]
    createMany?: itemsCreateManyCategoriesInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type option_groupsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<option_groupsCreateWithoutCategoriesInput, option_groupsUncheckedCreateWithoutCategoriesInput> | option_groupsCreateWithoutCategoriesInput[] | option_groupsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutCategoriesInput | option_groupsCreateOrConnectWithoutCategoriesInput[]
    createMany?: option_groupsCreateManyCategoriesInputEnvelope
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput> | productsCreateWithoutCategoriesInput[] | productsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutCategoriesInput | productsCreateOrConnectWithoutCategoriesInput[]
    createMany?: productsCreateManyCategoriesInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type brandsUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<brandsCreateWithoutCategoriesInput, brandsUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: brandsCreateOrConnectWithoutCategoriesInput
    upsert?: brandsUpsertWithoutCategoriesInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutCategoriesInput, brandsUpdateWithoutCategoriesInput>, brandsUncheckedUpdateWithoutCategoriesInput>
  }

  export type sub_brandsUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<sub_brandsCreateWithoutCategoriesInput, sub_brandsUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutCategoriesInput
    upsert?: sub_brandsUpsertWithoutCategoriesInput
    disconnect?: sub_brandsWhereInput | boolean
    delete?: sub_brandsWhereInput | boolean
    connect?: sub_brandsWhereUniqueInput
    update?: XOR<XOR<sub_brandsUpdateToOneWithWhereWithoutCategoriesInput, sub_brandsUpdateWithoutCategoriesInput>, sub_brandsUncheckedUpdateWithoutCategoriesInput>
  }

  export type itemsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<itemsCreateWithoutCategoriesInput, itemsUncheckedCreateWithoutCategoriesInput> | itemsCreateWithoutCategoriesInput[] | itemsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutCategoriesInput | itemsCreateOrConnectWithoutCategoriesInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutCategoriesInput | itemsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: itemsCreateManyCategoriesInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutCategoriesInput | itemsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutCategoriesInput | itemsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type option_groupsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<option_groupsCreateWithoutCategoriesInput, option_groupsUncheckedCreateWithoutCategoriesInput> | option_groupsCreateWithoutCategoriesInput[] | option_groupsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutCategoriesInput | option_groupsCreateOrConnectWithoutCategoriesInput[]
    upsert?: option_groupsUpsertWithWhereUniqueWithoutCategoriesInput | option_groupsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: option_groupsCreateManyCategoriesInputEnvelope
    set?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    disconnect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    delete?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    update?: option_groupsUpdateWithWhereUniqueWithoutCategoriesInput | option_groupsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: option_groupsUpdateManyWithWhereWithoutCategoriesInput | option_groupsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: option_groupsScalarWhereInput | option_groupsScalarWhereInput[]
  }

  export type productsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput> | productsCreateWithoutCategoriesInput[] | productsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutCategoriesInput | productsCreateOrConnectWithoutCategoriesInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutCategoriesInput | productsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: productsCreateManyCategoriesInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutCategoriesInput | productsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: productsUpdateManyWithWhereWithoutCategoriesInput | productsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type itemsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<itemsCreateWithoutCategoriesInput, itemsUncheckedCreateWithoutCategoriesInput> | itemsCreateWithoutCategoriesInput[] | itemsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutCategoriesInput | itemsCreateOrConnectWithoutCategoriesInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutCategoriesInput | itemsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: itemsCreateManyCategoriesInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutCategoriesInput | itemsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutCategoriesInput | itemsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type option_groupsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<option_groupsCreateWithoutCategoriesInput, option_groupsUncheckedCreateWithoutCategoriesInput> | option_groupsCreateWithoutCategoriesInput[] | option_groupsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutCategoriesInput | option_groupsCreateOrConnectWithoutCategoriesInput[]
    upsert?: option_groupsUpsertWithWhereUniqueWithoutCategoriesInput | option_groupsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: option_groupsCreateManyCategoriesInputEnvelope
    set?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    disconnect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    delete?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    update?: option_groupsUpdateWithWhereUniqueWithoutCategoriesInput | option_groupsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: option_groupsUpdateManyWithWhereWithoutCategoriesInput | option_groupsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: option_groupsScalarWhereInput | option_groupsScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput> | productsCreateWithoutCategoriesInput[] | productsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutCategoriesInput | productsCreateOrConnectWithoutCategoriesInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutCategoriesInput | productsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: productsCreateManyCategoriesInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutCategoriesInput | productsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: productsUpdateManyWithWhereWithoutCategoriesInput | productsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type brandsCreateNestedOneWithoutChannelsInput = {
    create?: XOR<brandsCreateWithoutChannelsInput, brandsUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutChannelsInput
    connect?: brandsWhereUniqueInput
  }

  export type salesCreateNestedManyWithoutChannelsInput = {
    create?: XOR<salesCreateWithoutChannelsInput, salesUncheckedCreateWithoutChannelsInput> | salesCreateWithoutChannelsInput[] | salesUncheckedCreateWithoutChannelsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutChannelsInput | salesCreateOrConnectWithoutChannelsInput[]
    createMany?: salesCreateManyChannelsInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type salesUncheckedCreateNestedManyWithoutChannelsInput = {
    create?: XOR<salesCreateWithoutChannelsInput, salesUncheckedCreateWithoutChannelsInput> | salesCreateWithoutChannelsInput[] | salesUncheckedCreateWithoutChannelsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutChannelsInput | salesCreateOrConnectWithoutChannelsInput[]
    createMany?: salesCreateManyChannelsInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type brandsUpdateOneWithoutChannelsNestedInput = {
    create?: XOR<brandsCreateWithoutChannelsInput, brandsUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutChannelsInput
    upsert?: brandsUpsertWithoutChannelsInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutChannelsInput, brandsUpdateWithoutChannelsInput>, brandsUncheckedUpdateWithoutChannelsInput>
  }

  export type salesUpdateManyWithoutChannelsNestedInput = {
    create?: XOR<salesCreateWithoutChannelsInput, salesUncheckedCreateWithoutChannelsInput> | salesCreateWithoutChannelsInput[] | salesUncheckedCreateWithoutChannelsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutChannelsInput | salesCreateOrConnectWithoutChannelsInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutChannelsInput | salesUpsertWithWhereUniqueWithoutChannelsInput[]
    createMany?: salesCreateManyChannelsInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutChannelsInput | salesUpdateWithWhereUniqueWithoutChannelsInput[]
    updateMany?: salesUpdateManyWithWhereWithoutChannelsInput | salesUpdateManyWithWhereWithoutChannelsInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type salesUncheckedUpdateManyWithoutChannelsNestedInput = {
    create?: XOR<salesCreateWithoutChannelsInput, salesUncheckedCreateWithoutChannelsInput> | salesCreateWithoutChannelsInput[] | salesUncheckedCreateWithoutChannelsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutChannelsInput | salesCreateOrConnectWithoutChannelsInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutChannelsInput | salesUpsertWithWhereUniqueWithoutChannelsInput[]
    createMany?: salesCreateManyChannelsInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutChannelsInput | salesUpdateWithWhereUniqueWithoutChannelsInput[]
    updateMany?: salesUpdateManyWithWhereWithoutChannelsInput | salesUpdateManyWithWhereWithoutChannelsInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type couponsCreateNestedOneWithoutCoupon_salesInput = {
    create?: XOR<couponsCreateWithoutCoupon_salesInput, couponsUncheckedCreateWithoutCoupon_salesInput>
    connectOrCreate?: couponsCreateOrConnectWithoutCoupon_salesInput
    connect?: couponsWhereUniqueInput
  }

  export type salesCreateNestedOneWithoutCoupon_salesInput = {
    create?: XOR<salesCreateWithoutCoupon_salesInput, salesUncheckedCreateWithoutCoupon_salesInput>
    connectOrCreate?: salesCreateOrConnectWithoutCoupon_salesInput
    connect?: salesWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type couponsUpdateOneWithoutCoupon_salesNestedInput = {
    create?: XOR<couponsCreateWithoutCoupon_salesInput, couponsUncheckedCreateWithoutCoupon_salesInput>
    connectOrCreate?: couponsCreateOrConnectWithoutCoupon_salesInput
    upsert?: couponsUpsertWithoutCoupon_salesInput
    disconnect?: couponsWhereInput | boolean
    delete?: couponsWhereInput | boolean
    connect?: couponsWhereUniqueInput
    update?: XOR<XOR<couponsUpdateToOneWithWhereWithoutCoupon_salesInput, couponsUpdateWithoutCoupon_salesInput>, couponsUncheckedUpdateWithoutCoupon_salesInput>
  }

  export type salesUpdateOneWithoutCoupon_salesNestedInput = {
    create?: XOR<salesCreateWithoutCoupon_salesInput, salesUncheckedCreateWithoutCoupon_salesInput>
    connectOrCreate?: salesCreateOrConnectWithoutCoupon_salesInput
    upsert?: salesUpsertWithoutCoupon_salesInput
    disconnect?: salesWhereInput | boolean
    delete?: salesWhereInput | boolean
    connect?: salesWhereUniqueInput
    update?: XOR<XOR<salesUpdateToOneWithWhereWithoutCoupon_salesInput, salesUpdateWithoutCoupon_salesInput>, salesUncheckedUpdateWithoutCoupon_salesInput>
  }

  export type coupon_salesCreateNestedManyWithoutCouponsInput = {
    create?: XOR<coupon_salesCreateWithoutCouponsInput, coupon_salesUncheckedCreateWithoutCouponsInput> | coupon_salesCreateWithoutCouponsInput[] | coupon_salesUncheckedCreateWithoutCouponsInput[]
    connectOrCreate?: coupon_salesCreateOrConnectWithoutCouponsInput | coupon_salesCreateOrConnectWithoutCouponsInput[]
    createMany?: coupon_salesCreateManyCouponsInputEnvelope
    connect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutCouponsInput = {
    create?: XOR<brandsCreateWithoutCouponsInput, brandsUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutCouponsInput
    connect?: brandsWhereUniqueInput
  }

  export type coupon_salesUncheckedCreateNestedManyWithoutCouponsInput = {
    create?: XOR<coupon_salesCreateWithoutCouponsInput, coupon_salesUncheckedCreateWithoutCouponsInput> | coupon_salesCreateWithoutCouponsInput[] | coupon_salesUncheckedCreateWithoutCouponsInput[]
    connectOrCreate?: coupon_salesCreateOrConnectWithoutCouponsInput | coupon_salesCreateOrConnectWithoutCouponsInput[]
    createMany?: coupon_salesCreateManyCouponsInputEnvelope
    connect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type coupon_salesUpdateManyWithoutCouponsNestedInput = {
    create?: XOR<coupon_salesCreateWithoutCouponsInput, coupon_salesUncheckedCreateWithoutCouponsInput> | coupon_salesCreateWithoutCouponsInput[] | coupon_salesUncheckedCreateWithoutCouponsInput[]
    connectOrCreate?: coupon_salesCreateOrConnectWithoutCouponsInput | coupon_salesCreateOrConnectWithoutCouponsInput[]
    upsert?: coupon_salesUpsertWithWhereUniqueWithoutCouponsInput | coupon_salesUpsertWithWhereUniqueWithoutCouponsInput[]
    createMany?: coupon_salesCreateManyCouponsInputEnvelope
    set?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    disconnect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    delete?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    connect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    update?: coupon_salesUpdateWithWhereUniqueWithoutCouponsInput | coupon_salesUpdateWithWhereUniqueWithoutCouponsInput[]
    updateMany?: coupon_salesUpdateManyWithWhereWithoutCouponsInput | coupon_salesUpdateManyWithWhereWithoutCouponsInput[]
    deleteMany?: coupon_salesScalarWhereInput | coupon_salesScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutCouponsNestedInput = {
    create?: XOR<brandsCreateWithoutCouponsInput, brandsUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutCouponsInput
    upsert?: brandsUpsertWithoutCouponsInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutCouponsInput, brandsUpdateWithoutCouponsInput>, brandsUncheckedUpdateWithoutCouponsInput>
  }

  export type coupon_salesUncheckedUpdateManyWithoutCouponsNestedInput = {
    create?: XOR<coupon_salesCreateWithoutCouponsInput, coupon_salesUncheckedCreateWithoutCouponsInput> | coupon_salesCreateWithoutCouponsInput[] | coupon_salesUncheckedCreateWithoutCouponsInput[]
    connectOrCreate?: coupon_salesCreateOrConnectWithoutCouponsInput | coupon_salesCreateOrConnectWithoutCouponsInput[]
    upsert?: coupon_salesUpsertWithWhereUniqueWithoutCouponsInput | coupon_salesUpsertWithWhereUniqueWithoutCouponsInput[]
    createMany?: coupon_salesCreateManyCouponsInputEnvelope
    set?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    disconnect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    delete?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    connect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    update?: coupon_salesUpdateWithWhereUniqueWithoutCouponsInput | coupon_salesUpdateWithWhereUniqueWithoutCouponsInput[]
    updateMany?: coupon_salesUpdateManyWithWhereWithoutCouponsInput | coupon_salesUpdateManyWithWhereWithoutCouponsInput[]
    deleteMany?: coupon_salesScalarWhereInput | coupon_salesScalarWhereInput[]
  }

  export type storesCreateNestedOneWithoutCustomersInput = {
    create?: XOR<storesCreateWithoutCustomersInput, storesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: storesCreateOrConnectWithoutCustomersInput
    connect?: storesWhereUniqueInput
  }

  export type sub_brandsCreateNestedOneWithoutCustomersInput = {
    create?: XOR<sub_brandsCreateWithoutCustomersInput, sub_brandsUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutCustomersInput
    connect?: sub_brandsWhereUniqueInput
  }

  export type salesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<salesCreateWithoutCustomersInput, salesUncheckedCreateWithoutCustomersInput> | salesCreateWithoutCustomersInput[] | salesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: salesCreateOrConnectWithoutCustomersInput | salesCreateOrConnectWithoutCustomersInput[]
    createMany?: salesCreateManyCustomersInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type salesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<salesCreateWithoutCustomersInput, salesUncheckedCreateWithoutCustomersInput> | salesCreateWithoutCustomersInput[] | salesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: salesCreateOrConnectWithoutCustomersInput | salesCreateOrConnectWithoutCustomersInput[]
    createMany?: salesCreateManyCustomersInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type storesUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<storesCreateWithoutCustomersInput, storesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: storesCreateOrConnectWithoutCustomersInput
    upsert?: storesUpsertWithoutCustomersInput
    disconnect?: storesWhereInput | boolean
    delete?: storesWhereInput | boolean
    connect?: storesWhereUniqueInput
    update?: XOR<XOR<storesUpdateToOneWithWhereWithoutCustomersInput, storesUpdateWithoutCustomersInput>, storesUncheckedUpdateWithoutCustomersInput>
  }

  export type sub_brandsUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<sub_brandsCreateWithoutCustomersInput, sub_brandsUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutCustomersInput
    upsert?: sub_brandsUpsertWithoutCustomersInput
    disconnect?: sub_brandsWhereInput | boolean
    delete?: sub_brandsWhereInput | boolean
    connect?: sub_brandsWhereUniqueInput
    update?: XOR<XOR<sub_brandsUpdateToOneWithWhereWithoutCustomersInput, sub_brandsUpdateWithoutCustomersInput>, sub_brandsUncheckedUpdateWithoutCustomersInput>
  }

  export type salesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<salesCreateWithoutCustomersInput, salesUncheckedCreateWithoutCustomersInput> | salesCreateWithoutCustomersInput[] | salesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: salesCreateOrConnectWithoutCustomersInput | salesCreateOrConnectWithoutCustomersInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutCustomersInput | salesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: salesCreateManyCustomersInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutCustomersInput | salesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: salesUpdateManyWithWhereWithoutCustomersInput | salesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type salesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<salesCreateWithoutCustomersInput, salesUncheckedCreateWithoutCustomersInput> | salesCreateWithoutCustomersInput[] | salesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: salesCreateOrConnectWithoutCustomersInput | salesCreateOrConnectWithoutCustomersInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutCustomersInput | salesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: salesCreateManyCustomersInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutCustomersInput | salesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: salesUpdateManyWithWhereWithoutCustomersInput | salesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type delivery_salesCreateNestedOneWithoutDelivery_addressesInput = {
    create?: XOR<delivery_salesCreateWithoutDelivery_addressesInput, delivery_salesUncheckedCreateWithoutDelivery_addressesInput>
    connectOrCreate?: delivery_salesCreateOrConnectWithoutDelivery_addressesInput
    connect?: delivery_salesWhereUniqueInput
  }

  export type salesCreateNestedOneWithoutDelivery_addressesInput = {
    create?: XOR<salesCreateWithoutDelivery_addressesInput, salesUncheckedCreateWithoutDelivery_addressesInput>
    connectOrCreate?: salesCreateOrConnectWithoutDelivery_addressesInput
    connect?: salesWhereUniqueInput
  }

  export type delivery_salesUpdateOneWithoutDelivery_addressesNestedInput = {
    create?: XOR<delivery_salesCreateWithoutDelivery_addressesInput, delivery_salesUncheckedCreateWithoutDelivery_addressesInput>
    connectOrCreate?: delivery_salesCreateOrConnectWithoutDelivery_addressesInput
    upsert?: delivery_salesUpsertWithoutDelivery_addressesInput
    disconnect?: delivery_salesWhereInput | boolean
    delete?: delivery_salesWhereInput | boolean
    connect?: delivery_salesWhereUniqueInput
    update?: XOR<XOR<delivery_salesUpdateToOneWithWhereWithoutDelivery_addressesInput, delivery_salesUpdateWithoutDelivery_addressesInput>, delivery_salesUncheckedUpdateWithoutDelivery_addressesInput>
  }

  export type salesUpdateOneRequiredWithoutDelivery_addressesNestedInput = {
    create?: XOR<salesCreateWithoutDelivery_addressesInput, salesUncheckedCreateWithoutDelivery_addressesInput>
    connectOrCreate?: salesCreateOrConnectWithoutDelivery_addressesInput
    upsert?: salesUpsertWithoutDelivery_addressesInput
    connect?: salesWhereUniqueInput
    update?: XOR<XOR<salesUpdateToOneWithWhereWithoutDelivery_addressesInput, salesUpdateWithoutDelivery_addressesInput>, salesUncheckedUpdateWithoutDelivery_addressesInput>
  }

  export type delivery_addressesCreateNestedManyWithoutDelivery_salesInput = {
    create?: XOR<delivery_addressesCreateWithoutDelivery_salesInput, delivery_addressesUncheckedCreateWithoutDelivery_salesInput> | delivery_addressesCreateWithoutDelivery_salesInput[] | delivery_addressesUncheckedCreateWithoutDelivery_salesInput[]
    connectOrCreate?: delivery_addressesCreateOrConnectWithoutDelivery_salesInput | delivery_addressesCreateOrConnectWithoutDelivery_salesInput[]
    createMany?: delivery_addressesCreateManyDelivery_salesInputEnvelope
    connect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
  }

  export type salesCreateNestedOneWithoutDelivery_salesInput = {
    create?: XOR<salesCreateWithoutDelivery_salesInput, salesUncheckedCreateWithoutDelivery_salesInput>
    connectOrCreate?: salesCreateOrConnectWithoutDelivery_salesInput
    connect?: salesWhereUniqueInput
  }

  export type delivery_addressesUncheckedCreateNestedManyWithoutDelivery_salesInput = {
    create?: XOR<delivery_addressesCreateWithoutDelivery_salesInput, delivery_addressesUncheckedCreateWithoutDelivery_salesInput> | delivery_addressesCreateWithoutDelivery_salesInput[] | delivery_addressesUncheckedCreateWithoutDelivery_salesInput[]
    connectOrCreate?: delivery_addressesCreateOrConnectWithoutDelivery_salesInput | delivery_addressesCreateOrConnectWithoutDelivery_salesInput[]
    createMany?: delivery_addressesCreateManyDelivery_salesInputEnvelope
    connect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
  }

  export type delivery_addressesUpdateManyWithoutDelivery_salesNestedInput = {
    create?: XOR<delivery_addressesCreateWithoutDelivery_salesInput, delivery_addressesUncheckedCreateWithoutDelivery_salesInput> | delivery_addressesCreateWithoutDelivery_salesInput[] | delivery_addressesUncheckedCreateWithoutDelivery_salesInput[]
    connectOrCreate?: delivery_addressesCreateOrConnectWithoutDelivery_salesInput | delivery_addressesCreateOrConnectWithoutDelivery_salesInput[]
    upsert?: delivery_addressesUpsertWithWhereUniqueWithoutDelivery_salesInput | delivery_addressesUpsertWithWhereUniqueWithoutDelivery_salesInput[]
    createMany?: delivery_addressesCreateManyDelivery_salesInputEnvelope
    set?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    disconnect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    delete?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    connect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    update?: delivery_addressesUpdateWithWhereUniqueWithoutDelivery_salesInput | delivery_addressesUpdateWithWhereUniqueWithoutDelivery_salesInput[]
    updateMany?: delivery_addressesUpdateManyWithWhereWithoutDelivery_salesInput | delivery_addressesUpdateManyWithWhereWithoutDelivery_salesInput[]
    deleteMany?: delivery_addressesScalarWhereInput | delivery_addressesScalarWhereInput[]
  }

  export type salesUpdateOneRequiredWithoutDelivery_salesNestedInput = {
    create?: XOR<salesCreateWithoutDelivery_salesInput, salesUncheckedCreateWithoutDelivery_salesInput>
    connectOrCreate?: salesCreateOrConnectWithoutDelivery_salesInput
    upsert?: salesUpsertWithoutDelivery_salesInput
    connect?: salesWhereUniqueInput
    update?: XOR<XOR<salesUpdateToOneWithWhereWithoutDelivery_salesInput, salesUpdateWithoutDelivery_salesInput>, salesUncheckedUpdateWithoutDelivery_salesInput>
  }

  export type delivery_addressesUncheckedUpdateManyWithoutDelivery_salesNestedInput = {
    create?: XOR<delivery_addressesCreateWithoutDelivery_salesInput, delivery_addressesUncheckedCreateWithoutDelivery_salesInput> | delivery_addressesCreateWithoutDelivery_salesInput[] | delivery_addressesUncheckedCreateWithoutDelivery_salesInput[]
    connectOrCreate?: delivery_addressesCreateOrConnectWithoutDelivery_salesInput | delivery_addressesCreateOrConnectWithoutDelivery_salesInput[]
    upsert?: delivery_addressesUpsertWithWhereUniqueWithoutDelivery_salesInput | delivery_addressesUpsertWithWhereUniqueWithoutDelivery_salesInput[]
    createMany?: delivery_addressesCreateManyDelivery_salesInputEnvelope
    set?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    disconnect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    delete?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    connect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    update?: delivery_addressesUpdateWithWhereUniqueWithoutDelivery_salesInput | delivery_addressesUpdateWithWhereUniqueWithoutDelivery_salesInput[]
    updateMany?: delivery_addressesUpdateManyWithWhereWithoutDelivery_salesInput | delivery_addressesUpdateManyWithWhereWithoutDelivery_salesInput[]
    deleteMany?: delivery_addressesScalarWhereInput | delivery_addressesScalarWhereInput[]
  }

  export type itemsCreateNestedOneWithoutItem_item_product_salesInput = {
    create?: XOR<itemsCreateWithoutItem_item_product_salesInput, itemsUncheckedCreateWithoutItem_item_product_salesInput>
    connectOrCreate?: itemsCreateOrConnectWithoutItem_item_product_salesInput
    connect?: itemsWhereUniqueInput
  }

  export type item_product_salesCreateNestedOneWithoutItem_item_product_salesInput = {
    create?: XOR<item_product_salesCreateWithoutItem_item_product_salesInput, item_product_salesUncheckedCreateWithoutItem_item_product_salesInput>
    connectOrCreate?: item_product_salesCreateOrConnectWithoutItem_item_product_salesInput
    connect?: item_product_salesWhereUniqueInput
  }

  export type option_groupsCreateNestedOneWithoutItem_item_product_salesInput = {
    create?: XOR<option_groupsCreateWithoutItem_item_product_salesInput, option_groupsUncheckedCreateWithoutItem_item_product_salesInput>
    connectOrCreate?: option_groupsCreateOrConnectWithoutItem_item_product_salesInput
    connect?: option_groupsWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type itemsUpdateOneRequiredWithoutItem_item_product_salesNestedInput = {
    create?: XOR<itemsCreateWithoutItem_item_product_salesInput, itemsUncheckedCreateWithoutItem_item_product_salesInput>
    connectOrCreate?: itemsCreateOrConnectWithoutItem_item_product_salesInput
    upsert?: itemsUpsertWithoutItem_item_product_salesInput
    connect?: itemsWhereUniqueInput
    update?: XOR<XOR<itemsUpdateToOneWithWhereWithoutItem_item_product_salesInput, itemsUpdateWithoutItem_item_product_salesInput>, itemsUncheckedUpdateWithoutItem_item_product_salesInput>
  }

  export type item_product_salesUpdateOneRequiredWithoutItem_item_product_salesNestedInput = {
    create?: XOR<item_product_salesCreateWithoutItem_item_product_salesInput, item_product_salesUncheckedCreateWithoutItem_item_product_salesInput>
    connectOrCreate?: item_product_salesCreateOrConnectWithoutItem_item_product_salesInput
    upsert?: item_product_salesUpsertWithoutItem_item_product_salesInput
    connect?: item_product_salesWhereUniqueInput
    update?: XOR<XOR<item_product_salesUpdateToOneWithWhereWithoutItem_item_product_salesInput, item_product_salesUpdateWithoutItem_item_product_salesInput>, item_product_salesUncheckedUpdateWithoutItem_item_product_salesInput>
  }

  export type option_groupsUpdateOneWithoutItem_item_product_salesNestedInput = {
    create?: XOR<option_groupsCreateWithoutItem_item_product_salesInput, option_groupsUncheckedCreateWithoutItem_item_product_salesInput>
    connectOrCreate?: option_groupsCreateOrConnectWithoutItem_item_product_salesInput
    upsert?: option_groupsUpsertWithoutItem_item_product_salesInput
    disconnect?: option_groupsWhereInput | boolean
    delete?: option_groupsWhereInput | boolean
    connect?: option_groupsWhereUniqueInput
    update?: XOR<XOR<option_groupsUpdateToOneWithWhereWithoutItem_item_product_salesInput, option_groupsUpdateWithoutItem_item_product_salesInput>, option_groupsUncheckedUpdateWithoutItem_item_product_salesInput>
  }

  export type item_item_product_salesCreateNestedManyWithoutItem_product_salesInput = {
    create?: XOR<item_item_product_salesCreateWithoutItem_product_salesInput, item_item_product_salesUncheckedCreateWithoutItem_product_salesInput> | item_item_product_salesCreateWithoutItem_product_salesInput[] | item_item_product_salesUncheckedCreateWithoutItem_product_salesInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutItem_product_salesInput | item_item_product_salesCreateOrConnectWithoutItem_product_salesInput[]
    createMany?: item_item_product_salesCreateManyItem_product_salesInputEnvelope
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
  }

  export type itemsCreateNestedOneWithoutItem_product_salesInput = {
    create?: XOR<itemsCreateWithoutItem_product_salesInput, itemsUncheckedCreateWithoutItem_product_salesInput>
    connectOrCreate?: itemsCreateOrConnectWithoutItem_product_salesInput
    connect?: itemsWhereUniqueInput
  }

  export type option_groupsCreateNestedOneWithoutItem_product_salesInput = {
    create?: XOR<option_groupsCreateWithoutItem_product_salesInput, option_groupsUncheckedCreateWithoutItem_product_salesInput>
    connectOrCreate?: option_groupsCreateOrConnectWithoutItem_product_salesInput
    connect?: option_groupsWhereUniqueInput
  }

  export type product_salesCreateNestedOneWithoutItem_product_salesInput = {
    create?: XOR<product_salesCreateWithoutItem_product_salesInput, product_salesUncheckedCreateWithoutItem_product_salesInput>
    connectOrCreate?: product_salesCreateOrConnectWithoutItem_product_salesInput
    connect?: product_salesWhereUniqueInput
  }

  export type item_item_product_salesUncheckedCreateNestedManyWithoutItem_product_salesInput = {
    create?: XOR<item_item_product_salesCreateWithoutItem_product_salesInput, item_item_product_salesUncheckedCreateWithoutItem_product_salesInput> | item_item_product_salesCreateWithoutItem_product_salesInput[] | item_item_product_salesUncheckedCreateWithoutItem_product_salesInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutItem_product_salesInput | item_item_product_salesCreateOrConnectWithoutItem_product_salesInput[]
    createMany?: item_item_product_salesCreateManyItem_product_salesInputEnvelope
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
  }

  export type item_item_product_salesUpdateManyWithoutItem_product_salesNestedInput = {
    create?: XOR<item_item_product_salesCreateWithoutItem_product_salesInput, item_item_product_salesUncheckedCreateWithoutItem_product_salesInput> | item_item_product_salesCreateWithoutItem_product_salesInput[] | item_item_product_salesUncheckedCreateWithoutItem_product_salesInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutItem_product_salesInput | item_item_product_salesCreateOrConnectWithoutItem_product_salesInput[]
    upsert?: item_item_product_salesUpsertWithWhereUniqueWithoutItem_product_salesInput | item_item_product_salesUpsertWithWhereUniqueWithoutItem_product_salesInput[]
    createMany?: item_item_product_salesCreateManyItem_product_salesInputEnvelope
    set?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    disconnect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    delete?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    update?: item_item_product_salesUpdateWithWhereUniqueWithoutItem_product_salesInput | item_item_product_salesUpdateWithWhereUniqueWithoutItem_product_salesInput[]
    updateMany?: item_item_product_salesUpdateManyWithWhereWithoutItem_product_salesInput | item_item_product_salesUpdateManyWithWhereWithoutItem_product_salesInput[]
    deleteMany?: item_item_product_salesScalarWhereInput | item_item_product_salesScalarWhereInput[]
  }

  export type itemsUpdateOneRequiredWithoutItem_product_salesNestedInput = {
    create?: XOR<itemsCreateWithoutItem_product_salesInput, itemsUncheckedCreateWithoutItem_product_salesInput>
    connectOrCreate?: itemsCreateOrConnectWithoutItem_product_salesInput
    upsert?: itemsUpsertWithoutItem_product_salesInput
    connect?: itemsWhereUniqueInput
    update?: XOR<XOR<itemsUpdateToOneWithWhereWithoutItem_product_salesInput, itemsUpdateWithoutItem_product_salesInput>, itemsUncheckedUpdateWithoutItem_product_salesInput>
  }

  export type option_groupsUpdateOneWithoutItem_product_salesNestedInput = {
    create?: XOR<option_groupsCreateWithoutItem_product_salesInput, option_groupsUncheckedCreateWithoutItem_product_salesInput>
    connectOrCreate?: option_groupsCreateOrConnectWithoutItem_product_salesInput
    upsert?: option_groupsUpsertWithoutItem_product_salesInput
    disconnect?: option_groupsWhereInput | boolean
    delete?: option_groupsWhereInput | boolean
    connect?: option_groupsWhereUniqueInput
    update?: XOR<XOR<option_groupsUpdateToOneWithWhereWithoutItem_product_salesInput, option_groupsUpdateWithoutItem_product_salesInput>, option_groupsUncheckedUpdateWithoutItem_product_salesInput>
  }

  export type product_salesUpdateOneRequiredWithoutItem_product_salesNestedInput = {
    create?: XOR<product_salesCreateWithoutItem_product_salesInput, product_salesUncheckedCreateWithoutItem_product_salesInput>
    connectOrCreate?: product_salesCreateOrConnectWithoutItem_product_salesInput
    upsert?: product_salesUpsertWithoutItem_product_salesInput
    connect?: product_salesWhereUniqueInput
    update?: XOR<XOR<product_salesUpdateToOneWithWhereWithoutItem_product_salesInput, product_salesUpdateWithoutItem_product_salesInput>, product_salesUncheckedUpdateWithoutItem_product_salesInput>
  }

  export type item_item_product_salesUncheckedUpdateManyWithoutItem_product_salesNestedInput = {
    create?: XOR<item_item_product_salesCreateWithoutItem_product_salesInput, item_item_product_salesUncheckedCreateWithoutItem_product_salesInput> | item_item_product_salesCreateWithoutItem_product_salesInput[] | item_item_product_salesUncheckedCreateWithoutItem_product_salesInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutItem_product_salesInput | item_item_product_salesCreateOrConnectWithoutItem_product_salesInput[]
    upsert?: item_item_product_salesUpsertWithWhereUniqueWithoutItem_product_salesInput | item_item_product_salesUpsertWithWhereUniqueWithoutItem_product_salesInput[]
    createMany?: item_item_product_salesCreateManyItem_product_salesInputEnvelope
    set?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    disconnect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    delete?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    update?: item_item_product_salesUpdateWithWhereUniqueWithoutItem_product_salesInput | item_item_product_salesUpdateWithWhereUniqueWithoutItem_product_salesInput[]
    updateMany?: item_item_product_salesUpdateManyWithWhereWithoutItem_product_salesInput | item_item_product_salesUpdateManyWithWhereWithoutItem_product_salesInput[]
    deleteMany?: item_item_product_salesScalarWhereInput | item_item_product_salesScalarWhereInput[]
  }

  export type item_item_product_salesCreateNestedManyWithoutItemsInput = {
    create?: XOR<item_item_product_salesCreateWithoutItemsInput, item_item_product_salesUncheckedCreateWithoutItemsInput> | item_item_product_salesCreateWithoutItemsInput[] | item_item_product_salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutItemsInput | item_item_product_salesCreateOrConnectWithoutItemsInput[]
    createMany?: item_item_product_salesCreateManyItemsInputEnvelope
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
  }

  export type item_product_salesCreateNestedManyWithoutItemsInput = {
    create?: XOR<item_product_salesCreateWithoutItemsInput, item_product_salesUncheckedCreateWithoutItemsInput> | item_product_salesCreateWithoutItemsInput[] | item_product_salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutItemsInput | item_product_salesCreateOrConnectWithoutItemsInput[]
    createMany?: item_product_salesCreateManyItemsInputEnvelope
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutItemsInput = {
    create?: XOR<brandsCreateWithoutItemsInput, brandsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutItemsInput
    connect?: brandsWhereUniqueInput
  }

  export type categoriesCreateNestedOneWithoutItemsInput = {
    create?: XOR<categoriesCreateWithoutItemsInput, categoriesUncheckedCreateWithoutItemsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutItemsInput
    connect?: categoriesWhereUniqueInput
  }

  export type sub_brandsCreateNestedOneWithoutItemsInput = {
    create?: XOR<sub_brandsCreateWithoutItemsInput, sub_brandsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutItemsInput
    connect?: sub_brandsWhereUniqueInput
  }

  export type item_item_product_salesUncheckedCreateNestedManyWithoutItemsInput = {
    create?: XOR<item_item_product_salesCreateWithoutItemsInput, item_item_product_salesUncheckedCreateWithoutItemsInput> | item_item_product_salesCreateWithoutItemsInput[] | item_item_product_salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutItemsInput | item_item_product_salesCreateOrConnectWithoutItemsInput[]
    createMany?: item_item_product_salesCreateManyItemsInputEnvelope
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
  }

  export type item_product_salesUncheckedCreateNestedManyWithoutItemsInput = {
    create?: XOR<item_product_salesCreateWithoutItemsInput, item_product_salesUncheckedCreateWithoutItemsInput> | item_product_salesCreateWithoutItemsInput[] | item_product_salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutItemsInput | item_product_salesCreateOrConnectWithoutItemsInput[]
    createMany?: item_product_salesCreateManyItemsInputEnvelope
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
  }

  export type item_item_product_salesUpdateManyWithoutItemsNestedInput = {
    create?: XOR<item_item_product_salesCreateWithoutItemsInput, item_item_product_salesUncheckedCreateWithoutItemsInput> | item_item_product_salesCreateWithoutItemsInput[] | item_item_product_salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutItemsInput | item_item_product_salesCreateOrConnectWithoutItemsInput[]
    upsert?: item_item_product_salesUpsertWithWhereUniqueWithoutItemsInput | item_item_product_salesUpsertWithWhereUniqueWithoutItemsInput[]
    createMany?: item_item_product_salesCreateManyItemsInputEnvelope
    set?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    disconnect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    delete?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    update?: item_item_product_salesUpdateWithWhereUniqueWithoutItemsInput | item_item_product_salesUpdateWithWhereUniqueWithoutItemsInput[]
    updateMany?: item_item_product_salesUpdateManyWithWhereWithoutItemsInput | item_item_product_salesUpdateManyWithWhereWithoutItemsInput[]
    deleteMany?: item_item_product_salesScalarWhereInput | item_item_product_salesScalarWhereInput[]
  }

  export type item_product_salesUpdateManyWithoutItemsNestedInput = {
    create?: XOR<item_product_salesCreateWithoutItemsInput, item_product_salesUncheckedCreateWithoutItemsInput> | item_product_salesCreateWithoutItemsInput[] | item_product_salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutItemsInput | item_product_salesCreateOrConnectWithoutItemsInput[]
    upsert?: item_product_salesUpsertWithWhereUniqueWithoutItemsInput | item_product_salesUpsertWithWhereUniqueWithoutItemsInput[]
    createMany?: item_product_salesCreateManyItemsInputEnvelope
    set?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    disconnect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    delete?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    update?: item_product_salesUpdateWithWhereUniqueWithoutItemsInput | item_product_salesUpdateWithWhereUniqueWithoutItemsInput[]
    updateMany?: item_product_salesUpdateManyWithWhereWithoutItemsInput | item_product_salesUpdateManyWithWhereWithoutItemsInput[]
    deleteMany?: item_product_salesScalarWhereInput | item_product_salesScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutItemsNestedInput = {
    create?: XOR<brandsCreateWithoutItemsInput, brandsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutItemsInput
    upsert?: brandsUpsertWithoutItemsInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutItemsInput, brandsUpdateWithoutItemsInput>, brandsUncheckedUpdateWithoutItemsInput>
  }

  export type categoriesUpdateOneWithoutItemsNestedInput = {
    create?: XOR<categoriesCreateWithoutItemsInput, categoriesUncheckedCreateWithoutItemsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutItemsInput
    upsert?: categoriesUpsertWithoutItemsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutItemsInput, categoriesUpdateWithoutItemsInput>, categoriesUncheckedUpdateWithoutItemsInput>
  }

  export type sub_brandsUpdateOneWithoutItemsNestedInput = {
    create?: XOR<sub_brandsCreateWithoutItemsInput, sub_brandsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutItemsInput
    upsert?: sub_brandsUpsertWithoutItemsInput
    disconnect?: sub_brandsWhereInput | boolean
    delete?: sub_brandsWhereInput | boolean
    connect?: sub_brandsWhereUniqueInput
    update?: XOR<XOR<sub_brandsUpdateToOneWithWhereWithoutItemsInput, sub_brandsUpdateWithoutItemsInput>, sub_brandsUncheckedUpdateWithoutItemsInput>
  }

  export type item_item_product_salesUncheckedUpdateManyWithoutItemsNestedInput = {
    create?: XOR<item_item_product_salesCreateWithoutItemsInput, item_item_product_salesUncheckedCreateWithoutItemsInput> | item_item_product_salesCreateWithoutItemsInput[] | item_item_product_salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutItemsInput | item_item_product_salesCreateOrConnectWithoutItemsInput[]
    upsert?: item_item_product_salesUpsertWithWhereUniqueWithoutItemsInput | item_item_product_salesUpsertWithWhereUniqueWithoutItemsInput[]
    createMany?: item_item_product_salesCreateManyItemsInputEnvelope
    set?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    disconnect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    delete?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    update?: item_item_product_salesUpdateWithWhereUniqueWithoutItemsInput | item_item_product_salesUpdateWithWhereUniqueWithoutItemsInput[]
    updateMany?: item_item_product_salesUpdateManyWithWhereWithoutItemsInput | item_item_product_salesUpdateManyWithWhereWithoutItemsInput[]
    deleteMany?: item_item_product_salesScalarWhereInput | item_item_product_salesScalarWhereInput[]
  }

  export type item_product_salesUncheckedUpdateManyWithoutItemsNestedInput = {
    create?: XOR<item_product_salesCreateWithoutItemsInput, item_product_salesUncheckedCreateWithoutItemsInput> | item_product_salesCreateWithoutItemsInput[] | item_product_salesUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutItemsInput | item_product_salesCreateOrConnectWithoutItemsInput[]
    upsert?: item_product_salesUpsertWithWhereUniqueWithoutItemsInput | item_product_salesUpsertWithWhereUniqueWithoutItemsInput[]
    createMany?: item_product_salesCreateManyItemsInputEnvelope
    set?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    disconnect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    delete?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    update?: item_product_salesUpdateWithWhereUniqueWithoutItemsInput | item_product_salesUpdateWithWhereUniqueWithoutItemsInput[]
    updateMany?: item_product_salesUpdateManyWithWhereWithoutItemsInput | item_product_salesUpdateManyWithWhereWithoutItemsInput[]
    deleteMany?: item_product_salesScalarWhereInput | item_product_salesScalarWhereInput[]
  }

  export type item_item_product_salesCreateNestedManyWithoutOption_groupsInput = {
    create?: XOR<item_item_product_salesCreateWithoutOption_groupsInput, item_item_product_salesUncheckedCreateWithoutOption_groupsInput> | item_item_product_salesCreateWithoutOption_groupsInput[] | item_item_product_salesUncheckedCreateWithoutOption_groupsInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutOption_groupsInput | item_item_product_salesCreateOrConnectWithoutOption_groupsInput[]
    createMany?: item_item_product_salesCreateManyOption_groupsInputEnvelope
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
  }

  export type item_product_salesCreateNestedManyWithoutOption_groupsInput = {
    create?: XOR<item_product_salesCreateWithoutOption_groupsInput, item_product_salesUncheckedCreateWithoutOption_groupsInput> | item_product_salesCreateWithoutOption_groupsInput[] | item_product_salesUncheckedCreateWithoutOption_groupsInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutOption_groupsInput | item_product_salesCreateOrConnectWithoutOption_groupsInput[]
    createMany?: item_product_salesCreateManyOption_groupsInputEnvelope
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutOption_groupsInput = {
    create?: XOR<brandsCreateWithoutOption_groupsInput, brandsUncheckedCreateWithoutOption_groupsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutOption_groupsInput
    connect?: brandsWhereUniqueInput
  }

  export type categoriesCreateNestedOneWithoutOption_groupsInput = {
    create?: XOR<categoriesCreateWithoutOption_groupsInput, categoriesUncheckedCreateWithoutOption_groupsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOption_groupsInput
    connect?: categoriesWhereUniqueInput
  }

  export type sub_brandsCreateNestedOneWithoutOption_groupsInput = {
    create?: XOR<sub_brandsCreateWithoutOption_groupsInput, sub_brandsUncheckedCreateWithoutOption_groupsInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutOption_groupsInput
    connect?: sub_brandsWhereUniqueInput
  }

  export type item_item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput = {
    create?: XOR<item_item_product_salesCreateWithoutOption_groupsInput, item_item_product_salesUncheckedCreateWithoutOption_groupsInput> | item_item_product_salesCreateWithoutOption_groupsInput[] | item_item_product_salesUncheckedCreateWithoutOption_groupsInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutOption_groupsInput | item_item_product_salesCreateOrConnectWithoutOption_groupsInput[]
    createMany?: item_item_product_salesCreateManyOption_groupsInputEnvelope
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
  }

  export type item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput = {
    create?: XOR<item_product_salesCreateWithoutOption_groupsInput, item_product_salesUncheckedCreateWithoutOption_groupsInput> | item_product_salesCreateWithoutOption_groupsInput[] | item_product_salesUncheckedCreateWithoutOption_groupsInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutOption_groupsInput | item_product_salesCreateOrConnectWithoutOption_groupsInput[]
    createMany?: item_product_salesCreateManyOption_groupsInputEnvelope
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
  }

  export type item_item_product_salesUpdateManyWithoutOption_groupsNestedInput = {
    create?: XOR<item_item_product_salesCreateWithoutOption_groupsInput, item_item_product_salesUncheckedCreateWithoutOption_groupsInput> | item_item_product_salesCreateWithoutOption_groupsInput[] | item_item_product_salesUncheckedCreateWithoutOption_groupsInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutOption_groupsInput | item_item_product_salesCreateOrConnectWithoutOption_groupsInput[]
    upsert?: item_item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput | item_item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput[]
    createMany?: item_item_product_salesCreateManyOption_groupsInputEnvelope
    set?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    disconnect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    delete?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    update?: item_item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput | item_item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput[]
    updateMany?: item_item_product_salesUpdateManyWithWhereWithoutOption_groupsInput | item_item_product_salesUpdateManyWithWhereWithoutOption_groupsInput[]
    deleteMany?: item_item_product_salesScalarWhereInput | item_item_product_salesScalarWhereInput[]
  }

  export type item_product_salesUpdateManyWithoutOption_groupsNestedInput = {
    create?: XOR<item_product_salesCreateWithoutOption_groupsInput, item_product_salesUncheckedCreateWithoutOption_groupsInput> | item_product_salesCreateWithoutOption_groupsInput[] | item_product_salesUncheckedCreateWithoutOption_groupsInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutOption_groupsInput | item_product_salesCreateOrConnectWithoutOption_groupsInput[]
    upsert?: item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput | item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput[]
    createMany?: item_product_salesCreateManyOption_groupsInputEnvelope
    set?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    disconnect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    delete?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    update?: item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput | item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput[]
    updateMany?: item_product_salesUpdateManyWithWhereWithoutOption_groupsInput | item_product_salesUpdateManyWithWhereWithoutOption_groupsInput[]
    deleteMany?: item_product_salesScalarWhereInput | item_product_salesScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutOption_groupsNestedInput = {
    create?: XOR<brandsCreateWithoutOption_groupsInput, brandsUncheckedCreateWithoutOption_groupsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutOption_groupsInput
    upsert?: brandsUpsertWithoutOption_groupsInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutOption_groupsInput, brandsUpdateWithoutOption_groupsInput>, brandsUncheckedUpdateWithoutOption_groupsInput>
  }

  export type categoriesUpdateOneWithoutOption_groupsNestedInput = {
    create?: XOR<categoriesCreateWithoutOption_groupsInput, categoriesUncheckedCreateWithoutOption_groupsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOption_groupsInput
    upsert?: categoriesUpsertWithoutOption_groupsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutOption_groupsInput, categoriesUpdateWithoutOption_groupsInput>, categoriesUncheckedUpdateWithoutOption_groupsInput>
  }

  export type sub_brandsUpdateOneWithoutOption_groupsNestedInput = {
    create?: XOR<sub_brandsCreateWithoutOption_groupsInput, sub_brandsUncheckedCreateWithoutOption_groupsInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutOption_groupsInput
    upsert?: sub_brandsUpsertWithoutOption_groupsInput
    disconnect?: sub_brandsWhereInput | boolean
    delete?: sub_brandsWhereInput | boolean
    connect?: sub_brandsWhereUniqueInput
    update?: XOR<XOR<sub_brandsUpdateToOneWithWhereWithoutOption_groupsInput, sub_brandsUpdateWithoutOption_groupsInput>, sub_brandsUncheckedUpdateWithoutOption_groupsInput>
  }

  export type item_item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput = {
    create?: XOR<item_item_product_salesCreateWithoutOption_groupsInput, item_item_product_salesUncheckedCreateWithoutOption_groupsInput> | item_item_product_salesCreateWithoutOption_groupsInput[] | item_item_product_salesUncheckedCreateWithoutOption_groupsInput[]
    connectOrCreate?: item_item_product_salesCreateOrConnectWithoutOption_groupsInput | item_item_product_salesCreateOrConnectWithoutOption_groupsInput[]
    upsert?: item_item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput | item_item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput[]
    createMany?: item_item_product_salesCreateManyOption_groupsInputEnvelope
    set?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    disconnect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    delete?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    connect?: item_item_product_salesWhereUniqueInput | item_item_product_salesWhereUniqueInput[]
    update?: item_item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput | item_item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput[]
    updateMany?: item_item_product_salesUpdateManyWithWhereWithoutOption_groupsInput | item_item_product_salesUpdateManyWithWhereWithoutOption_groupsInput[]
    deleteMany?: item_item_product_salesScalarWhereInput | item_item_product_salesScalarWhereInput[]
  }

  export type item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput = {
    create?: XOR<item_product_salesCreateWithoutOption_groupsInput, item_product_salesUncheckedCreateWithoutOption_groupsInput> | item_product_salesCreateWithoutOption_groupsInput[] | item_product_salesUncheckedCreateWithoutOption_groupsInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutOption_groupsInput | item_product_salesCreateOrConnectWithoutOption_groupsInput[]
    upsert?: item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput | item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput[]
    createMany?: item_product_salesCreateManyOption_groupsInputEnvelope
    set?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    disconnect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    delete?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    update?: item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput | item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput[]
    updateMany?: item_product_salesUpdateManyWithWhereWithoutOption_groupsInput | item_product_salesUpdateManyWithWhereWithoutOption_groupsInput[]
    deleteMany?: item_product_salesScalarWhereInput | item_product_salesScalarWhereInput[]
  }

  export type brandsCreateNestedOneWithoutPayment_typesInput = {
    create?: XOR<brandsCreateWithoutPayment_typesInput, brandsUncheckedCreateWithoutPayment_typesInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPayment_typesInput
    connect?: brandsWhereUniqueInput
  }

  export type paymentsCreateNestedManyWithoutPayment_typesInput = {
    create?: XOR<paymentsCreateWithoutPayment_typesInput, paymentsUncheckedCreateWithoutPayment_typesInput> | paymentsCreateWithoutPayment_typesInput[] | paymentsUncheckedCreateWithoutPayment_typesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayment_typesInput | paymentsCreateOrConnectWithoutPayment_typesInput[]
    createMany?: paymentsCreateManyPayment_typesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutPayment_typesInput = {
    create?: XOR<paymentsCreateWithoutPayment_typesInput, paymentsUncheckedCreateWithoutPayment_typesInput> | paymentsCreateWithoutPayment_typesInput[] | paymentsUncheckedCreateWithoutPayment_typesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayment_typesInput | paymentsCreateOrConnectWithoutPayment_typesInput[]
    createMany?: paymentsCreateManyPayment_typesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type brandsUpdateOneWithoutPayment_typesNestedInput = {
    create?: XOR<brandsCreateWithoutPayment_typesInput, brandsUncheckedCreateWithoutPayment_typesInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPayment_typesInput
    upsert?: brandsUpsertWithoutPayment_typesInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutPayment_typesInput, brandsUpdateWithoutPayment_typesInput>, brandsUncheckedUpdateWithoutPayment_typesInput>
  }

  export type paymentsUpdateManyWithoutPayment_typesNestedInput = {
    create?: XOR<paymentsCreateWithoutPayment_typesInput, paymentsUncheckedCreateWithoutPayment_typesInput> | paymentsCreateWithoutPayment_typesInput[] | paymentsUncheckedCreateWithoutPayment_typesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayment_typesInput | paymentsCreateOrConnectWithoutPayment_typesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutPayment_typesInput | paymentsUpsertWithWhereUniqueWithoutPayment_typesInput[]
    createMany?: paymentsCreateManyPayment_typesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutPayment_typesInput | paymentsUpdateWithWhereUniqueWithoutPayment_typesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutPayment_typesInput | paymentsUpdateManyWithWhereWithoutPayment_typesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutPayment_typesNestedInput = {
    create?: XOR<paymentsCreateWithoutPayment_typesInput, paymentsUncheckedCreateWithoutPayment_typesInput> | paymentsCreateWithoutPayment_typesInput[] | paymentsUncheckedCreateWithoutPayment_typesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayment_typesInput | paymentsCreateOrConnectWithoutPayment_typesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutPayment_typesInput | paymentsUpsertWithWhereUniqueWithoutPayment_typesInput[]
    createMany?: paymentsCreateManyPayment_typesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutPayment_typesInput | paymentsUpdateWithWhereUniqueWithoutPayment_typesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutPayment_typesInput | paymentsUpdateManyWithWhereWithoutPayment_typesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type payment_typesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<payment_typesCreateWithoutPaymentsInput, payment_typesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: payment_typesCreateOrConnectWithoutPaymentsInput
    connect?: payment_typesWhereUniqueInput
  }

  export type salesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<salesCreateWithoutPaymentsInput, salesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: salesCreateOrConnectWithoutPaymentsInput
    connect?: salesWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type payment_typesUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<payment_typesCreateWithoutPaymentsInput, payment_typesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: payment_typesCreateOrConnectWithoutPaymentsInput
    upsert?: payment_typesUpsertWithoutPaymentsInput
    disconnect?: payment_typesWhereInput | boolean
    delete?: payment_typesWhereInput | boolean
    connect?: payment_typesWhereUniqueInput
    update?: XOR<XOR<payment_typesUpdateToOneWithWhereWithoutPaymentsInput, payment_typesUpdateWithoutPaymentsInput>, payment_typesUncheckedUpdateWithoutPaymentsInput>
  }

  export type salesUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<salesCreateWithoutPaymentsInput, salesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: salesCreateOrConnectWithoutPaymentsInput
    upsert?: salesUpsertWithoutPaymentsInput
    connect?: salesWhereUniqueInput
    update?: XOR<XOR<salesUpdateToOneWithWhereWithoutPaymentsInput, salesUpdateWithoutPaymentsInput>, salesUncheckedUpdateWithoutPaymentsInput>
  }

  export type item_product_salesCreateNestedManyWithoutProduct_salesInput = {
    create?: XOR<item_product_salesCreateWithoutProduct_salesInput, item_product_salesUncheckedCreateWithoutProduct_salesInput> | item_product_salesCreateWithoutProduct_salesInput[] | item_product_salesUncheckedCreateWithoutProduct_salesInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutProduct_salesInput | item_product_salesCreateOrConnectWithoutProduct_salesInput[]
    createMany?: item_product_salesCreateManyProduct_salesInputEnvelope
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
  }

  export type productsCreateNestedOneWithoutProduct_salesInput = {
    create?: XOR<productsCreateWithoutProduct_salesInput, productsUncheckedCreateWithoutProduct_salesInput>
    connectOrCreate?: productsCreateOrConnectWithoutProduct_salesInput
    connect?: productsWhereUniqueInput
  }

  export type salesCreateNestedOneWithoutProduct_salesInput = {
    create?: XOR<salesCreateWithoutProduct_salesInput, salesUncheckedCreateWithoutProduct_salesInput>
    connectOrCreate?: salesCreateOrConnectWithoutProduct_salesInput
    connect?: salesWhereUniqueInput
  }

  export type item_product_salesUncheckedCreateNestedManyWithoutProduct_salesInput = {
    create?: XOR<item_product_salesCreateWithoutProduct_salesInput, item_product_salesUncheckedCreateWithoutProduct_salesInput> | item_product_salesCreateWithoutProduct_salesInput[] | item_product_salesUncheckedCreateWithoutProduct_salesInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutProduct_salesInput | item_product_salesCreateOrConnectWithoutProduct_salesInput[]
    createMany?: item_product_salesCreateManyProduct_salesInputEnvelope
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
  }

  export type item_product_salesUpdateManyWithoutProduct_salesNestedInput = {
    create?: XOR<item_product_salesCreateWithoutProduct_salesInput, item_product_salesUncheckedCreateWithoutProduct_salesInput> | item_product_salesCreateWithoutProduct_salesInput[] | item_product_salesUncheckedCreateWithoutProduct_salesInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutProduct_salesInput | item_product_salesCreateOrConnectWithoutProduct_salesInput[]
    upsert?: item_product_salesUpsertWithWhereUniqueWithoutProduct_salesInput | item_product_salesUpsertWithWhereUniqueWithoutProduct_salesInput[]
    createMany?: item_product_salesCreateManyProduct_salesInputEnvelope
    set?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    disconnect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    delete?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    update?: item_product_salesUpdateWithWhereUniqueWithoutProduct_salesInput | item_product_salesUpdateWithWhereUniqueWithoutProduct_salesInput[]
    updateMany?: item_product_salesUpdateManyWithWhereWithoutProduct_salesInput | item_product_salesUpdateManyWithWhereWithoutProduct_salesInput[]
    deleteMany?: item_product_salesScalarWhereInput | item_product_salesScalarWhereInput[]
  }

  export type productsUpdateOneRequiredWithoutProduct_salesNestedInput = {
    create?: XOR<productsCreateWithoutProduct_salesInput, productsUncheckedCreateWithoutProduct_salesInput>
    connectOrCreate?: productsCreateOrConnectWithoutProduct_salesInput
    upsert?: productsUpsertWithoutProduct_salesInput
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutProduct_salesInput, productsUpdateWithoutProduct_salesInput>, productsUncheckedUpdateWithoutProduct_salesInput>
  }

  export type salesUpdateOneRequiredWithoutProduct_salesNestedInput = {
    create?: XOR<salesCreateWithoutProduct_salesInput, salesUncheckedCreateWithoutProduct_salesInput>
    connectOrCreate?: salesCreateOrConnectWithoutProduct_salesInput
    upsert?: salesUpsertWithoutProduct_salesInput
    connect?: salesWhereUniqueInput
    update?: XOR<XOR<salesUpdateToOneWithWhereWithoutProduct_salesInput, salesUpdateWithoutProduct_salesInput>, salesUncheckedUpdateWithoutProduct_salesInput>
  }

  export type item_product_salesUncheckedUpdateManyWithoutProduct_salesNestedInput = {
    create?: XOR<item_product_salesCreateWithoutProduct_salesInput, item_product_salesUncheckedCreateWithoutProduct_salesInput> | item_product_salesCreateWithoutProduct_salesInput[] | item_product_salesUncheckedCreateWithoutProduct_salesInput[]
    connectOrCreate?: item_product_salesCreateOrConnectWithoutProduct_salesInput | item_product_salesCreateOrConnectWithoutProduct_salesInput[]
    upsert?: item_product_salesUpsertWithWhereUniqueWithoutProduct_salesInput | item_product_salesUpsertWithWhereUniqueWithoutProduct_salesInput[]
    createMany?: item_product_salesCreateManyProduct_salesInputEnvelope
    set?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    disconnect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    delete?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    connect?: item_product_salesWhereUniqueInput | item_product_salesWhereUniqueInput[]
    update?: item_product_salesUpdateWithWhereUniqueWithoutProduct_salesInput | item_product_salesUpdateWithWhereUniqueWithoutProduct_salesInput[]
    updateMany?: item_product_salesUpdateManyWithWhereWithoutProduct_salesInput | item_product_salesUpdateManyWithWhereWithoutProduct_salesInput[]
    deleteMany?: item_product_salesScalarWhereInput | item_product_salesScalarWhereInput[]
  }

  export type product_salesCreateNestedManyWithoutProductsInput = {
    create?: XOR<product_salesCreateWithoutProductsInput, product_salesUncheckedCreateWithoutProductsInput> | product_salesCreateWithoutProductsInput[] | product_salesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: product_salesCreateOrConnectWithoutProductsInput | product_salesCreateOrConnectWithoutProductsInput[]
    createMany?: product_salesCreateManyProductsInputEnvelope
    connect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutProductsInput = {
    create?: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductsInput
    connect?: brandsWhereUniqueInput
  }

  export type categoriesCreateNestedOneWithoutProductsInput = {
    create?: XOR<categoriesCreateWithoutProductsInput, categoriesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutProductsInput
    connect?: categoriesWhereUniqueInput
  }

  export type sub_brandsCreateNestedOneWithoutProductsInput = {
    create?: XOR<sub_brandsCreateWithoutProductsInput, sub_brandsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutProductsInput
    connect?: sub_brandsWhereUniqueInput
  }

  export type product_salesUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<product_salesCreateWithoutProductsInput, product_salesUncheckedCreateWithoutProductsInput> | product_salesCreateWithoutProductsInput[] | product_salesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: product_salesCreateOrConnectWithoutProductsInput | product_salesCreateOrConnectWithoutProductsInput[]
    createMany?: product_salesCreateManyProductsInputEnvelope
    connect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
  }

  export type product_salesUpdateManyWithoutProductsNestedInput = {
    create?: XOR<product_salesCreateWithoutProductsInput, product_salesUncheckedCreateWithoutProductsInput> | product_salesCreateWithoutProductsInput[] | product_salesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: product_salesCreateOrConnectWithoutProductsInput | product_salesCreateOrConnectWithoutProductsInput[]
    upsert?: product_salesUpsertWithWhereUniqueWithoutProductsInput | product_salesUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: product_salesCreateManyProductsInputEnvelope
    set?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    disconnect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    delete?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    connect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    update?: product_salesUpdateWithWhereUniqueWithoutProductsInput | product_salesUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: product_salesUpdateManyWithWhereWithoutProductsInput | product_salesUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: product_salesScalarWhereInput | product_salesScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutProductsNestedInput = {
    create?: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductsInput
    upsert?: brandsUpsertWithoutProductsInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutProductsInput, brandsUpdateWithoutProductsInput>, brandsUncheckedUpdateWithoutProductsInput>
  }

  export type categoriesUpdateOneWithoutProductsNestedInput = {
    create?: XOR<categoriesCreateWithoutProductsInput, categoriesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutProductsInput
    upsert?: categoriesUpsertWithoutProductsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutProductsInput, categoriesUpdateWithoutProductsInput>, categoriesUncheckedUpdateWithoutProductsInput>
  }

  export type sub_brandsUpdateOneWithoutProductsNestedInput = {
    create?: XOR<sub_brandsCreateWithoutProductsInput, sub_brandsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutProductsInput
    upsert?: sub_brandsUpsertWithoutProductsInput
    disconnect?: sub_brandsWhereInput | boolean
    delete?: sub_brandsWhereInput | boolean
    connect?: sub_brandsWhereUniqueInput
    update?: XOR<XOR<sub_brandsUpdateToOneWithWhereWithoutProductsInput, sub_brandsUpdateWithoutProductsInput>, sub_brandsUncheckedUpdateWithoutProductsInput>
  }

  export type product_salesUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<product_salesCreateWithoutProductsInput, product_salesUncheckedCreateWithoutProductsInput> | product_salesCreateWithoutProductsInput[] | product_salesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: product_salesCreateOrConnectWithoutProductsInput | product_salesCreateOrConnectWithoutProductsInput[]
    upsert?: product_salesUpsertWithWhereUniqueWithoutProductsInput | product_salesUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: product_salesCreateManyProductsInputEnvelope
    set?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    disconnect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    delete?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    connect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    update?: product_salesUpdateWithWhereUniqueWithoutProductsInput | product_salesUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: product_salesUpdateManyWithWhereWithoutProductsInput | product_salesUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: product_salesScalarWhereInput | product_salesScalarWhereInput[]
  }

  export type coupon_salesCreateNestedManyWithoutSalesInput = {
    create?: XOR<coupon_salesCreateWithoutSalesInput, coupon_salesUncheckedCreateWithoutSalesInput> | coupon_salesCreateWithoutSalesInput[] | coupon_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: coupon_salesCreateOrConnectWithoutSalesInput | coupon_salesCreateOrConnectWithoutSalesInput[]
    createMany?: coupon_salesCreateManySalesInputEnvelope
    connect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
  }

  export type delivery_addressesCreateNestedManyWithoutSalesInput = {
    create?: XOR<delivery_addressesCreateWithoutSalesInput, delivery_addressesUncheckedCreateWithoutSalesInput> | delivery_addressesCreateWithoutSalesInput[] | delivery_addressesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: delivery_addressesCreateOrConnectWithoutSalesInput | delivery_addressesCreateOrConnectWithoutSalesInput[]
    createMany?: delivery_addressesCreateManySalesInputEnvelope
    connect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
  }

  export type delivery_salesCreateNestedManyWithoutSalesInput = {
    create?: XOR<delivery_salesCreateWithoutSalesInput, delivery_salesUncheckedCreateWithoutSalesInput> | delivery_salesCreateWithoutSalesInput[] | delivery_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: delivery_salesCreateOrConnectWithoutSalesInput | delivery_salesCreateOrConnectWithoutSalesInput[]
    createMany?: delivery_salesCreateManySalesInputEnvelope
    connect?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutSalesInput = {
    create?: XOR<paymentsCreateWithoutSalesInput, paymentsUncheckedCreateWithoutSalesInput> | paymentsCreateWithoutSalesInput[] | paymentsUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutSalesInput | paymentsCreateOrConnectWithoutSalesInput[]
    createMany?: paymentsCreateManySalesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type product_salesCreateNestedManyWithoutSalesInput = {
    create?: XOR<product_salesCreateWithoutSalesInput, product_salesUncheckedCreateWithoutSalesInput> | product_salesCreateWithoutSalesInput[] | product_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: product_salesCreateOrConnectWithoutSalesInput | product_salesCreateOrConnectWithoutSalesInput[]
    createMany?: product_salesCreateManySalesInputEnvelope
    connect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
  }

  export type channelsCreateNestedOneWithoutSalesInput = {
    create?: XOR<channelsCreateWithoutSalesInput, channelsUncheckedCreateWithoutSalesInput>
    connectOrCreate?: channelsCreateOrConnectWithoutSalesInput
    connect?: channelsWhereUniqueInput
  }

  export type customersCreateNestedOneWithoutSalesInput = {
    create?: XOR<customersCreateWithoutSalesInput, customersUncheckedCreateWithoutSalesInput>
    connectOrCreate?: customersCreateOrConnectWithoutSalesInput
    connect?: customersWhereUniqueInput
  }

  export type storesCreateNestedOneWithoutSalesInput = {
    create?: XOR<storesCreateWithoutSalesInput, storesUncheckedCreateWithoutSalesInput>
    connectOrCreate?: storesCreateOrConnectWithoutSalesInput
    connect?: storesWhereUniqueInput
  }

  export type sub_brandsCreateNestedOneWithoutSalesInput = {
    create?: XOR<sub_brandsCreateWithoutSalesInput, sub_brandsUncheckedCreateWithoutSalesInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutSalesInput
    connect?: sub_brandsWhereUniqueInput
  }

  export type coupon_salesUncheckedCreateNestedManyWithoutSalesInput = {
    create?: XOR<coupon_salesCreateWithoutSalesInput, coupon_salesUncheckedCreateWithoutSalesInput> | coupon_salesCreateWithoutSalesInput[] | coupon_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: coupon_salesCreateOrConnectWithoutSalesInput | coupon_salesCreateOrConnectWithoutSalesInput[]
    createMany?: coupon_salesCreateManySalesInputEnvelope
    connect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
  }

  export type delivery_addressesUncheckedCreateNestedManyWithoutSalesInput = {
    create?: XOR<delivery_addressesCreateWithoutSalesInput, delivery_addressesUncheckedCreateWithoutSalesInput> | delivery_addressesCreateWithoutSalesInput[] | delivery_addressesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: delivery_addressesCreateOrConnectWithoutSalesInput | delivery_addressesCreateOrConnectWithoutSalesInput[]
    createMany?: delivery_addressesCreateManySalesInputEnvelope
    connect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
  }

  export type delivery_salesUncheckedCreateNestedManyWithoutSalesInput = {
    create?: XOR<delivery_salesCreateWithoutSalesInput, delivery_salesUncheckedCreateWithoutSalesInput> | delivery_salesCreateWithoutSalesInput[] | delivery_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: delivery_salesCreateOrConnectWithoutSalesInput | delivery_salesCreateOrConnectWithoutSalesInput[]
    createMany?: delivery_salesCreateManySalesInputEnvelope
    connect?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutSalesInput = {
    create?: XOR<paymentsCreateWithoutSalesInput, paymentsUncheckedCreateWithoutSalesInput> | paymentsCreateWithoutSalesInput[] | paymentsUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutSalesInput | paymentsCreateOrConnectWithoutSalesInput[]
    createMany?: paymentsCreateManySalesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type product_salesUncheckedCreateNestedManyWithoutSalesInput = {
    create?: XOR<product_salesCreateWithoutSalesInput, product_salesUncheckedCreateWithoutSalesInput> | product_salesCreateWithoutSalesInput[] | product_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: product_salesCreateOrConnectWithoutSalesInput | product_salesCreateOrConnectWithoutSalesInput[]
    createMany?: product_salesCreateManySalesInputEnvelope
    connect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type coupon_salesUpdateManyWithoutSalesNestedInput = {
    create?: XOR<coupon_salesCreateWithoutSalesInput, coupon_salesUncheckedCreateWithoutSalesInput> | coupon_salesCreateWithoutSalesInput[] | coupon_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: coupon_salesCreateOrConnectWithoutSalesInput | coupon_salesCreateOrConnectWithoutSalesInput[]
    upsert?: coupon_salesUpsertWithWhereUniqueWithoutSalesInput | coupon_salesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: coupon_salesCreateManySalesInputEnvelope
    set?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    disconnect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    delete?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    connect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    update?: coupon_salesUpdateWithWhereUniqueWithoutSalesInput | coupon_salesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: coupon_salesUpdateManyWithWhereWithoutSalesInput | coupon_salesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: coupon_salesScalarWhereInput | coupon_salesScalarWhereInput[]
  }

  export type delivery_addressesUpdateManyWithoutSalesNestedInput = {
    create?: XOR<delivery_addressesCreateWithoutSalesInput, delivery_addressesUncheckedCreateWithoutSalesInput> | delivery_addressesCreateWithoutSalesInput[] | delivery_addressesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: delivery_addressesCreateOrConnectWithoutSalesInput | delivery_addressesCreateOrConnectWithoutSalesInput[]
    upsert?: delivery_addressesUpsertWithWhereUniqueWithoutSalesInput | delivery_addressesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: delivery_addressesCreateManySalesInputEnvelope
    set?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    disconnect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    delete?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    connect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    update?: delivery_addressesUpdateWithWhereUniqueWithoutSalesInput | delivery_addressesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: delivery_addressesUpdateManyWithWhereWithoutSalesInput | delivery_addressesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: delivery_addressesScalarWhereInput | delivery_addressesScalarWhereInput[]
  }

  export type delivery_salesUpdateManyWithoutSalesNestedInput = {
    create?: XOR<delivery_salesCreateWithoutSalesInput, delivery_salesUncheckedCreateWithoutSalesInput> | delivery_salesCreateWithoutSalesInput[] | delivery_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: delivery_salesCreateOrConnectWithoutSalesInput | delivery_salesCreateOrConnectWithoutSalesInput[]
    upsert?: delivery_salesUpsertWithWhereUniqueWithoutSalesInput | delivery_salesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: delivery_salesCreateManySalesInputEnvelope
    set?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
    disconnect?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
    delete?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
    connect?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
    update?: delivery_salesUpdateWithWhereUniqueWithoutSalesInput | delivery_salesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: delivery_salesUpdateManyWithWhereWithoutSalesInput | delivery_salesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: delivery_salesScalarWhereInput | delivery_salesScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutSalesNestedInput = {
    create?: XOR<paymentsCreateWithoutSalesInput, paymentsUncheckedCreateWithoutSalesInput> | paymentsCreateWithoutSalesInput[] | paymentsUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutSalesInput | paymentsCreateOrConnectWithoutSalesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutSalesInput | paymentsUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: paymentsCreateManySalesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutSalesInput | paymentsUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutSalesInput | paymentsUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type product_salesUpdateManyWithoutSalesNestedInput = {
    create?: XOR<product_salesCreateWithoutSalesInput, product_salesUncheckedCreateWithoutSalesInput> | product_salesCreateWithoutSalesInput[] | product_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: product_salesCreateOrConnectWithoutSalesInput | product_salesCreateOrConnectWithoutSalesInput[]
    upsert?: product_salesUpsertWithWhereUniqueWithoutSalesInput | product_salesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: product_salesCreateManySalesInputEnvelope
    set?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    disconnect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    delete?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    connect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    update?: product_salesUpdateWithWhereUniqueWithoutSalesInput | product_salesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: product_salesUpdateManyWithWhereWithoutSalesInput | product_salesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: product_salesScalarWhereInput | product_salesScalarWhereInput[]
  }

  export type channelsUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<channelsCreateWithoutSalesInput, channelsUncheckedCreateWithoutSalesInput>
    connectOrCreate?: channelsCreateOrConnectWithoutSalesInput
    upsert?: channelsUpsertWithoutSalesInput
    connect?: channelsWhereUniqueInput
    update?: XOR<XOR<channelsUpdateToOneWithWhereWithoutSalesInput, channelsUpdateWithoutSalesInput>, channelsUncheckedUpdateWithoutSalesInput>
  }

  export type customersUpdateOneWithoutSalesNestedInput = {
    create?: XOR<customersCreateWithoutSalesInput, customersUncheckedCreateWithoutSalesInput>
    connectOrCreate?: customersCreateOrConnectWithoutSalesInput
    upsert?: customersUpsertWithoutSalesInput
    disconnect?: customersWhereInput | boolean
    delete?: customersWhereInput | boolean
    connect?: customersWhereUniqueInput
    update?: XOR<XOR<customersUpdateToOneWithWhereWithoutSalesInput, customersUpdateWithoutSalesInput>, customersUncheckedUpdateWithoutSalesInput>
  }

  export type storesUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<storesCreateWithoutSalesInput, storesUncheckedCreateWithoutSalesInput>
    connectOrCreate?: storesCreateOrConnectWithoutSalesInput
    upsert?: storesUpsertWithoutSalesInput
    connect?: storesWhereUniqueInput
    update?: XOR<XOR<storesUpdateToOneWithWhereWithoutSalesInput, storesUpdateWithoutSalesInput>, storesUncheckedUpdateWithoutSalesInput>
  }

  export type sub_brandsUpdateOneWithoutSalesNestedInput = {
    create?: XOR<sub_brandsCreateWithoutSalesInput, sub_brandsUncheckedCreateWithoutSalesInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutSalesInput
    upsert?: sub_brandsUpsertWithoutSalesInput
    disconnect?: sub_brandsWhereInput | boolean
    delete?: sub_brandsWhereInput | boolean
    connect?: sub_brandsWhereUniqueInput
    update?: XOR<XOR<sub_brandsUpdateToOneWithWhereWithoutSalesInput, sub_brandsUpdateWithoutSalesInput>, sub_brandsUncheckedUpdateWithoutSalesInput>
  }

  export type coupon_salesUncheckedUpdateManyWithoutSalesNestedInput = {
    create?: XOR<coupon_salesCreateWithoutSalesInput, coupon_salesUncheckedCreateWithoutSalesInput> | coupon_salesCreateWithoutSalesInput[] | coupon_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: coupon_salesCreateOrConnectWithoutSalesInput | coupon_salesCreateOrConnectWithoutSalesInput[]
    upsert?: coupon_salesUpsertWithWhereUniqueWithoutSalesInput | coupon_salesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: coupon_salesCreateManySalesInputEnvelope
    set?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    disconnect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    delete?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    connect?: coupon_salesWhereUniqueInput | coupon_salesWhereUniqueInput[]
    update?: coupon_salesUpdateWithWhereUniqueWithoutSalesInput | coupon_salesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: coupon_salesUpdateManyWithWhereWithoutSalesInput | coupon_salesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: coupon_salesScalarWhereInput | coupon_salesScalarWhereInput[]
  }

  export type delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput = {
    create?: XOR<delivery_addressesCreateWithoutSalesInput, delivery_addressesUncheckedCreateWithoutSalesInput> | delivery_addressesCreateWithoutSalesInput[] | delivery_addressesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: delivery_addressesCreateOrConnectWithoutSalesInput | delivery_addressesCreateOrConnectWithoutSalesInput[]
    upsert?: delivery_addressesUpsertWithWhereUniqueWithoutSalesInput | delivery_addressesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: delivery_addressesCreateManySalesInputEnvelope
    set?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    disconnect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    delete?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    connect?: delivery_addressesWhereUniqueInput | delivery_addressesWhereUniqueInput[]
    update?: delivery_addressesUpdateWithWhereUniqueWithoutSalesInput | delivery_addressesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: delivery_addressesUpdateManyWithWhereWithoutSalesInput | delivery_addressesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: delivery_addressesScalarWhereInput | delivery_addressesScalarWhereInput[]
  }

  export type delivery_salesUncheckedUpdateManyWithoutSalesNestedInput = {
    create?: XOR<delivery_salesCreateWithoutSalesInput, delivery_salesUncheckedCreateWithoutSalesInput> | delivery_salesCreateWithoutSalesInput[] | delivery_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: delivery_salesCreateOrConnectWithoutSalesInput | delivery_salesCreateOrConnectWithoutSalesInput[]
    upsert?: delivery_salesUpsertWithWhereUniqueWithoutSalesInput | delivery_salesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: delivery_salesCreateManySalesInputEnvelope
    set?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
    disconnect?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
    delete?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
    connect?: delivery_salesWhereUniqueInput | delivery_salesWhereUniqueInput[]
    update?: delivery_salesUpdateWithWhereUniqueWithoutSalesInput | delivery_salesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: delivery_salesUpdateManyWithWhereWithoutSalesInput | delivery_salesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: delivery_salesScalarWhereInput | delivery_salesScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutSalesNestedInput = {
    create?: XOR<paymentsCreateWithoutSalesInput, paymentsUncheckedCreateWithoutSalesInput> | paymentsCreateWithoutSalesInput[] | paymentsUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutSalesInput | paymentsCreateOrConnectWithoutSalesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutSalesInput | paymentsUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: paymentsCreateManySalesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutSalesInput | paymentsUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutSalesInput | paymentsUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type product_salesUncheckedUpdateManyWithoutSalesNestedInput = {
    create?: XOR<product_salesCreateWithoutSalesInput, product_salesUncheckedCreateWithoutSalesInput> | product_salesCreateWithoutSalesInput[] | product_salesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: product_salesCreateOrConnectWithoutSalesInput | product_salesCreateOrConnectWithoutSalesInput[]
    upsert?: product_salesUpsertWithWhereUniqueWithoutSalesInput | product_salesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: product_salesCreateManySalesInputEnvelope
    set?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    disconnect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    delete?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    connect?: product_salesWhereUniqueInput | product_salesWhereUniqueInput[]
    update?: product_salesUpdateWithWhereUniqueWithoutSalesInput | product_salesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: product_salesUpdateManyWithWhereWithoutSalesInput | product_salesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: product_salesScalarWhereInput | product_salesScalarWhereInput[]
  }

  export type customersCreateNestedManyWithoutStoresInput = {
    create?: XOR<customersCreateWithoutStoresInput, customersUncheckedCreateWithoutStoresInput> | customersCreateWithoutStoresInput[] | customersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: customersCreateOrConnectWithoutStoresInput | customersCreateOrConnectWithoutStoresInput[]
    createMany?: customersCreateManyStoresInputEnvelope
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
  }

  export type salesCreateNestedManyWithoutStoresInput = {
    create?: XOR<salesCreateWithoutStoresInput, salesUncheckedCreateWithoutStoresInput> | salesCreateWithoutStoresInput[] | salesUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: salesCreateOrConnectWithoutStoresInput | salesCreateOrConnectWithoutStoresInput[]
    createMany?: salesCreateManyStoresInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutStoresInput = {
    create?: XOR<brandsCreateWithoutStoresInput, brandsUncheckedCreateWithoutStoresInput>
    connectOrCreate?: brandsCreateOrConnectWithoutStoresInput
    connect?: brandsWhereUniqueInput
  }

  export type sub_brandsCreateNestedOneWithoutStoresInput = {
    create?: XOR<sub_brandsCreateWithoutStoresInput, sub_brandsUncheckedCreateWithoutStoresInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutStoresInput
    connect?: sub_brandsWhereUniqueInput
  }

  export type customersUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<customersCreateWithoutStoresInput, customersUncheckedCreateWithoutStoresInput> | customersCreateWithoutStoresInput[] | customersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: customersCreateOrConnectWithoutStoresInput | customersCreateOrConnectWithoutStoresInput[]
    createMany?: customersCreateManyStoresInputEnvelope
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
  }

  export type salesUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<salesCreateWithoutStoresInput, salesUncheckedCreateWithoutStoresInput> | salesCreateWithoutStoresInput[] | salesUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: salesCreateOrConnectWithoutStoresInput | salesCreateOrConnectWithoutStoresInput[]
    createMany?: salesCreateManyStoresInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type customersUpdateManyWithoutStoresNestedInput = {
    create?: XOR<customersCreateWithoutStoresInput, customersUncheckedCreateWithoutStoresInput> | customersCreateWithoutStoresInput[] | customersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: customersCreateOrConnectWithoutStoresInput | customersCreateOrConnectWithoutStoresInput[]
    upsert?: customersUpsertWithWhereUniqueWithoutStoresInput | customersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: customersCreateManyStoresInputEnvelope
    set?: customersWhereUniqueInput | customersWhereUniqueInput[]
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[]
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    update?: customersUpdateWithWhereUniqueWithoutStoresInput | customersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: customersUpdateManyWithWhereWithoutStoresInput | customersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[]
  }

  export type salesUpdateManyWithoutStoresNestedInput = {
    create?: XOR<salesCreateWithoutStoresInput, salesUncheckedCreateWithoutStoresInput> | salesCreateWithoutStoresInput[] | salesUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: salesCreateOrConnectWithoutStoresInput | salesCreateOrConnectWithoutStoresInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutStoresInput | salesUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: salesCreateManyStoresInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutStoresInput | salesUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: salesUpdateManyWithWhereWithoutStoresInput | salesUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutStoresNestedInput = {
    create?: XOR<brandsCreateWithoutStoresInput, brandsUncheckedCreateWithoutStoresInput>
    connectOrCreate?: brandsCreateOrConnectWithoutStoresInput
    upsert?: brandsUpsertWithoutStoresInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutStoresInput, brandsUpdateWithoutStoresInput>, brandsUncheckedUpdateWithoutStoresInput>
  }

  export type sub_brandsUpdateOneWithoutStoresNestedInput = {
    create?: XOR<sub_brandsCreateWithoutStoresInput, sub_brandsUncheckedCreateWithoutStoresInput>
    connectOrCreate?: sub_brandsCreateOrConnectWithoutStoresInput
    upsert?: sub_brandsUpsertWithoutStoresInput
    disconnect?: sub_brandsWhereInput | boolean
    delete?: sub_brandsWhereInput | boolean
    connect?: sub_brandsWhereUniqueInput
    update?: XOR<XOR<sub_brandsUpdateToOneWithWhereWithoutStoresInput, sub_brandsUpdateWithoutStoresInput>, sub_brandsUncheckedUpdateWithoutStoresInput>
  }

  export type customersUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<customersCreateWithoutStoresInput, customersUncheckedCreateWithoutStoresInput> | customersCreateWithoutStoresInput[] | customersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: customersCreateOrConnectWithoutStoresInput | customersCreateOrConnectWithoutStoresInput[]
    upsert?: customersUpsertWithWhereUniqueWithoutStoresInput | customersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: customersCreateManyStoresInputEnvelope
    set?: customersWhereUniqueInput | customersWhereUniqueInput[]
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[]
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    update?: customersUpdateWithWhereUniqueWithoutStoresInput | customersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: customersUpdateManyWithWhereWithoutStoresInput | customersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[]
  }

  export type salesUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<salesCreateWithoutStoresInput, salesUncheckedCreateWithoutStoresInput> | salesCreateWithoutStoresInput[] | salesUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: salesCreateOrConnectWithoutStoresInput | salesCreateOrConnectWithoutStoresInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutStoresInput | salesUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: salesCreateManyStoresInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutStoresInput | salesUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: salesUpdateManyWithWhereWithoutStoresInput | salesUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type categoriesCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<categoriesCreateWithoutSub_brandsInput, categoriesUncheckedCreateWithoutSub_brandsInput> | categoriesCreateWithoutSub_brandsInput[] | categoriesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutSub_brandsInput | categoriesCreateOrConnectWithoutSub_brandsInput[]
    createMany?: categoriesCreateManySub_brandsInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type customersCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<customersCreateWithoutSub_brandsInput, customersUncheckedCreateWithoutSub_brandsInput> | customersCreateWithoutSub_brandsInput[] | customersUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: customersCreateOrConnectWithoutSub_brandsInput | customersCreateOrConnectWithoutSub_brandsInput[]
    createMany?: customersCreateManySub_brandsInputEnvelope
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
  }

  export type itemsCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<itemsCreateWithoutSub_brandsInput, itemsUncheckedCreateWithoutSub_brandsInput> | itemsCreateWithoutSub_brandsInput[] | itemsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutSub_brandsInput | itemsCreateOrConnectWithoutSub_brandsInput[]
    createMany?: itemsCreateManySub_brandsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type option_groupsCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<option_groupsCreateWithoutSub_brandsInput, option_groupsUncheckedCreateWithoutSub_brandsInput> | option_groupsCreateWithoutSub_brandsInput[] | option_groupsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutSub_brandsInput | option_groupsCreateOrConnectWithoutSub_brandsInput[]
    createMany?: option_groupsCreateManySub_brandsInputEnvelope
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
  }

  export type productsCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<productsCreateWithoutSub_brandsInput, productsUncheckedCreateWithoutSub_brandsInput> | productsCreateWithoutSub_brandsInput[] | productsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: productsCreateOrConnectWithoutSub_brandsInput | productsCreateOrConnectWithoutSub_brandsInput[]
    createMany?: productsCreateManySub_brandsInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type salesCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<salesCreateWithoutSub_brandsInput, salesUncheckedCreateWithoutSub_brandsInput> | salesCreateWithoutSub_brandsInput[] | salesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutSub_brandsInput | salesCreateOrConnectWithoutSub_brandsInput[]
    createMany?: salesCreateManySub_brandsInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type storesCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<storesCreateWithoutSub_brandsInput, storesUncheckedCreateWithoutSub_brandsInput> | storesCreateWithoutSub_brandsInput[] | storesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: storesCreateOrConnectWithoutSub_brandsInput | storesCreateOrConnectWithoutSub_brandsInput[]
    createMany?: storesCreateManySub_brandsInputEnvelope
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutSub_brandsInput = {
    create?: XOR<brandsCreateWithoutSub_brandsInput, brandsUncheckedCreateWithoutSub_brandsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutSub_brandsInput
    connect?: brandsWhereUniqueInput
  }

  export type categoriesUncheckedCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<categoriesCreateWithoutSub_brandsInput, categoriesUncheckedCreateWithoutSub_brandsInput> | categoriesCreateWithoutSub_brandsInput[] | categoriesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutSub_brandsInput | categoriesCreateOrConnectWithoutSub_brandsInput[]
    createMany?: categoriesCreateManySub_brandsInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type customersUncheckedCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<customersCreateWithoutSub_brandsInput, customersUncheckedCreateWithoutSub_brandsInput> | customersCreateWithoutSub_brandsInput[] | customersUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: customersCreateOrConnectWithoutSub_brandsInput | customersCreateOrConnectWithoutSub_brandsInput[]
    createMany?: customersCreateManySub_brandsInputEnvelope
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
  }

  export type itemsUncheckedCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<itemsCreateWithoutSub_brandsInput, itemsUncheckedCreateWithoutSub_brandsInput> | itemsCreateWithoutSub_brandsInput[] | itemsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutSub_brandsInput | itemsCreateOrConnectWithoutSub_brandsInput[]
    createMany?: itemsCreateManySub_brandsInputEnvelope
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
  }

  export type option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<option_groupsCreateWithoutSub_brandsInput, option_groupsUncheckedCreateWithoutSub_brandsInput> | option_groupsCreateWithoutSub_brandsInput[] | option_groupsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutSub_brandsInput | option_groupsCreateOrConnectWithoutSub_brandsInput[]
    createMany?: option_groupsCreateManySub_brandsInputEnvelope
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<productsCreateWithoutSub_brandsInput, productsUncheckedCreateWithoutSub_brandsInput> | productsCreateWithoutSub_brandsInput[] | productsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: productsCreateOrConnectWithoutSub_brandsInput | productsCreateOrConnectWithoutSub_brandsInput[]
    createMany?: productsCreateManySub_brandsInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type salesUncheckedCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<salesCreateWithoutSub_brandsInput, salesUncheckedCreateWithoutSub_brandsInput> | salesCreateWithoutSub_brandsInput[] | salesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutSub_brandsInput | salesCreateOrConnectWithoutSub_brandsInput[]
    createMany?: salesCreateManySub_brandsInputEnvelope
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
  }

  export type storesUncheckedCreateNestedManyWithoutSub_brandsInput = {
    create?: XOR<storesCreateWithoutSub_brandsInput, storesUncheckedCreateWithoutSub_brandsInput> | storesCreateWithoutSub_brandsInput[] | storesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: storesCreateOrConnectWithoutSub_brandsInput | storesCreateOrConnectWithoutSub_brandsInput[]
    createMany?: storesCreateManySub_brandsInputEnvelope
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
  }

  export type categoriesUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<categoriesCreateWithoutSub_brandsInput, categoriesUncheckedCreateWithoutSub_brandsInput> | categoriesCreateWithoutSub_brandsInput[] | categoriesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutSub_brandsInput | categoriesCreateOrConnectWithoutSub_brandsInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutSub_brandsInput | categoriesUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: categoriesCreateManySub_brandsInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutSub_brandsInput | categoriesUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutSub_brandsInput | categoriesUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type customersUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<customersCreateWithoutSub_brandsInput, customersUncheckedCreateWithoutSub_brandsInput> | customersCreateWithoutSub_brandsInput[] | customersUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: customersCreateOrConnectWithoutSub_brandsInput | customersCreateOrConnectWithoutSub_brandsInput[]
    upsert?: customersUpsertWithWhereUniqueWithoutSub_brandsInput | customersUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: customersCreateManySub_brandsInputEnvelope
    set?: customersWhereUniqueInput | customersWhereUniqueInput[]
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[]
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    update?: customersUpdateWithWhereUniqueWithoutSub_brandsInput | customersUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: customersUpdateManyWithWhereWithoutSub_brandsInput | customersUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[]
  }

  export type itemsUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<itemsCreateWithoutSub_brandsInput, itemsUncheckedCreateWithoutSub_brandsInput> | itemsCreateWithoutSub_brandsInput[] | itemsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutSub_brandsInput | itemsCreateOrConnectWithoutSub_brandsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutSub_brandsInput | itemsUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: itemsCreateManySub_brandsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutSub_brandsInput | itemsUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutSub_brandsInput | itemsUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type option_groupsUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<option_groupsCreateWithoutSub_brandsInput, option_groupsUncheckedCreateWithoutSub_brandsInput> | option_groupsCreateWithoutSub_brandsInput[] | option_groupsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutSub_brandsInput | option_groupsCreateOrConnectWithoutSub_brandsInput[]
    upsert?: option_groupsUpsertWithWhereUniqueWithoutSub_brandsInput | option_groupsUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: option_groupsCreateManySub_brandsInputEnvelope
    set?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    disconnect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    delete?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    update?: option_groupsUpdateWithWhereUniqueWithoutSub_brandsInput | option_groupsUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: option_groupsUpdateManyWithWhereWithoutSub_brandsInput | option_groupsUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: option_groupsScalarWhereInput | option_groupsScalarWhereInput[]
  }

  export type productsUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<productsCreateWithoutSub_brandsInput, productsUncheckedCreateWithoutSub_brandsInput> | productsCreateWithoutSub_brandsInput[] | productsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: productsCreateOrConnectWithoutSub_brandsInput | productsCreateOrConnectWithoutSub_brandsInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutSub_brandsInput | productsUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: productsCreateManySub_brandsInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutSub_brandsInput | productsUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: productsUpdateManyWithWhereWithoutSub_brandsInput | productsUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type salesUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<salesCreateWithoutSub_brandsInput, salesUncheckedCreateWithoutSub_brandsInput> | salesCreateWithoutSub_brandsInput[] | salesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutSub_brandsInput | salesCreateOrConnectWithoutSub_brandsInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutSub_brandsInput | salesUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: salesCreateManySub_brandsInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutSub_brandsInput | salesUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: salesUpdateManyWithWhereWithoutSub_brandsInput | salesUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type storesUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<storesCreateWithoutSub_brandsInput, storesUncheckedCreateWithoutSub_brandsInput> | storesCreateWithoutSub_brandsInput[] | storesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: storesCreateOrConnectWithoutSub_brandsInput | storesCreateOrConnectWithoutSub_brandsInput[]
    upsert?: storesUpsertWithWhereUniqueWithoutSub_brandsInput | storesUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: storesCreateManySub_brandsInputEnvelope
    set?: storesWhereUniqueInput | storesWhereUniqueInput[]
    disconnect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    delete?: storesWhereUniqueInput | storesWhereUniqueInput[]
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    update?: storesUpdateWithWhereUniqueWithoutSub_brandsInput | storesUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: storesUpdateManyWithWhereWithoutSub_brandsInput | storesUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: storesScalarWhereInput | storesScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutSub_brandsNestedInput = {
    create?: XOR<brandsCreateWithoutSub_brandsInput, brandsUncheckedCreateWithoutSub_brandsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutSub_brandsInput
    upsert?: brandsUpsertWithoutSub_brandsInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutSub_brandsInput, brandsUpdateWithoutSub_brandsInput>, brandsUncheckedUpdateWithoutSub_brandsInput>
  }

  export type categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<categoriesCreateWithoutSub_brandsInput, categoriesUncheckedCreateWithoutSub_brandsInput> | categoriesCreateWithoutSub_brandsInput[] | categoriesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutSub_brandsInput | categoriesCreateOrConnectWithoutSub_brandsInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutSub_brandsInput | categoriesUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: categoriesCreateManySub_brandsInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutSub_brandsInput | categoriesUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutSub_brandsInput | categoriesUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type customersUncheckedUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<customersCreateWithoutSub_brandsInput, customersUncheckedCreateWithoutSub_brandsInput> | customersCreateWithoutSub_brandsInput[] | customersUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: customersCreateOrConnectWithoutSub_brandsInput | customersCreateOrConnectWithoutSub_brandsInput[]
    upsert?: customersUpsertWithWhereUniqueWithoutSub_brandsInput | customersUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: customersCreateManySub_brandsInputEnvelope
    set?: customersWhereUniqueInput | customersWhereUniqueInput[]
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[]
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    update?: customersUpdateWithWhereUniqueWithoutSub_brandsInput | customersUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: customersUpdateManyWithWhereWithoutSub_brandsInput | customersUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[]
  }

  export type itemsUncheckedUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<itemsCreateWithoutSub_brandsInput, itemsUncheckedCreateWithoutSub_brandsInput> | itemsCreateWithoutSub_brandsInput[] | itemsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: itemsCreateOrConnectWithoutSub_brandsInput | itemsCreateOrConnectWithoutSub_brandsInput[]
    upsert?: itemsUpsertWithWhereUniqueWithoutSub_brandsInput | itemsUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: itemsCreateManySub_brandsInputEnvelope
    set?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    disconnect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    delete?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    connect?: itemsWhereUniqueInput | itemsWhereUniqueInput[]
    update?: itemsUpdateWithWhereUniqueWithoutSub_brandsInput | itemsUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: itemsUpdateManyWithWhereWithoutSub_brandsInput | itemsUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: itemsScalarWhereInput | itemsScalarWhereInput[]
  }

  export type option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<option_groupsCreateWithoutSub_brandsInput, option_groupsUncheckedCreateWithoutSub_brandsInput> | option_groupsCreateWithoutSub_brandsInput[] | option_groupsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: option_groupsCreateOrConnectWithoutSub_brandsInput | option_groupsCreateOrConnectWithoutSub_brandsInput[]
    upsert?: option_groupsUpsertWithWhereUniqueWithoutSub_brandsInput | option_groupsUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: option_groupsCreateManySub_brandsInputEnvelope
    set?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    disconnect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    delete?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    connect?: option_groupsWhereUniqueInput | option_groupsWhereUniqueInput[]
    update?: option_groupsUpdateWithWhereUniqueWithoutSub_brandsInput | option_groupsUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: option_groupsUpdateManyWithWhereWithoutSub_brandsInput | option_groupsUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: option_groupsScalarWhereInput | option_groupsScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<productsCreateWithoutSub_brandsInput, productsUncheckedCreateWithoutSub_brandsInput> | productsCreateWithoutSub_brandsInput[] | productsUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: productsCreateOrConnectWithoutSub_brandsInput | productsCreateOrConnectWithoutSub_brandsInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutSub_brandsInput | productsUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: productsCreateManySub_brandsInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutSub_brandsInput | productsUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: productsUpdateManyWithWhereWithoutSub_brandsInput | productsUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type salesUncheckedUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<salesCreateWithoutSub_brandsInput, salesUncheckedCreateWithoutSub_brandsInput> | salesCreateWithoutSub_brandsInput[] | salesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: salesCreateOrConnectWithoutSub_brandsInput | salesCreateOrConnectWithoutSub_brandsInput[]
    upsert?: salesUpsertWithWhereUniqueWithoutSub_brandsInput | salesUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: salesCreateManySub_brandsInputEnvelope
    set?: salesWhereUniqueInput | salesWhereUniqueInput[]
    disconnect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    delete?: salesWhereUniqueInput | salesWhereUniqueInput[]
    connect?: salesWhereUniqueInput | salesWhereUniqueInput[]
    update?: salesUpdateWithWhereUniqueWithoutSub_brandsInput | salesUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: salesUpdateManyWithWhereWithoutSub_brandsInput | salesUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: salesScalarWhereInput | salesScalarWhereInput[]
  }

  export type storesUncheckedUpdateManyWithoutSub_brandsNestedInput = {
    create?: XOR<storesCreateWithoutSub_brandsInput, storesUncheckedCreateWithoutSub_brandsInput> | storesCreateWithoutSub_brandsInput[] | storesUncheckedCreateWithoutSub_brandsInput[]
    connectOrCreate?: storesCreateOrConnectWithoutSub_brandsInput | storesCreateOrConnectWithoutSub_brandsInput[]
    upsert?: storesUpsertWithWhereUniqueWithoutSub_brandsInput | storesUpsertWithWhereUniqueWithoutSub_brandsInput[]
    createMany?: storesCreateManySub_brandsInputEnvelope
    set?: storesWhereUniqueInput | storesWhereUniqueInput[]
    disconnect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    delete?: storesWhereUniqueInput | storesWhereUniqueInput[]
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    update?: storesUpdateWithWhereUniqueWithoutSub_brandsInput | storesUpdateWithWhereUniqueWithoutSub_brandsInput[]
    updateMany?: storesUpdateManyWithWhereWithoutSub_brandsInput | storesUpdateManyWithWhereWithoutSub_brandsInput[]
    deleteMany?: storesScalarWhereInput | storesScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type categoriesCreateWithoutBrandsInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    sub_brands?: sub_brandsCreateNestedOneWithoutCategoriesInput
    items?: itemsCreateNestedManyWithoutCategoriesInput
    option_groups?: option_groupsCreateNestedManyWithoutCategoriesInput
    products?: productsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    items?: itemsUncheckedCreateNestedManyWithoutCategoriesInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutCategoriesInput
    products?: productsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutBrandsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput>
  }

  export type categoriesCreateManyBrandsInputEnvelope = {
    data: categoriesCreateManyBrandsInput | categoriesCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type channelsCreateWithoutBrandsInput = {
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    sales?: salesCreateNestedManyWithoutChannelsInput
  }

  export type channelsUncheckedCreateWithoutBrandsInput = {
    id?: number
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    sales?: salesUncheckedCreateNestedManyWithoutChannelsInput
  }

  export type channelsCreateOrConnectWithoutBrandsInput = {
    where: channelsWhereUniqueInput
    create: XOR<channelsCreateWithoutBrandsInput, channelsUncheckedCreateWithoutBrandsInput>
  }

  export type channelsCreateManyBrandsInputEnvelope = {
    data: channelsCreateManyBrandsInput | channelsCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type couponsCreateWithoutBrandsInput = {
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutCouponsInput
  }

  export type couponsUncheckedCreateWithoutBrandsInput = {
    id?: number
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutCouponsInput
  }

  export type couponsCreateOrConnectWithoutBrandsInput = {
    where: couponsWhereUniqueInput
    create: XOR<couponsCreateWithoutBrandsInput, couponsUncheckedCreateWithoutBrandsInput>
  }

  export type couponsCreateManyBrandsInputEnvelope = {
    data: couponsCreateManyBrandsInput | couponsCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type itemsCreateWithoutBrandsInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItemsInput
    item_product_sales?: item_product_salesCreateNestedManyWithoutItemsInput
    categories?: categoriesCreateNestedOneWithoutItemsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItemsInput
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutBrandsInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutBrandsInput, itemsUncheckedCreateWithoutBrandsInput>
  }

  export type itemsCreateManyBrandsInputEnvelope = {
    data: itemsCreateManyBrandsInput | itemsCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type option_groupsCreateWithoutBrandsInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutOption_groupsInput
    item_product_sales?: item_product_salesCreateNestedManyWithoutOption_groupsInput
    categories?: categoriesCreateNestedOneWithoutOption_groupsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutOption_groupsInput
  }

  export type option_groupsUncheckedCreateWithoutBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
  }

  export type option_groupsCreateOrConnectWithoutBrandsInput = {
    where: option_groupsWhereUniqueInput
    create: XOR<option_groupsCreateWithoutBrandsInput, option_groupsUncheckedCreateWithoutBrandsInput>
  }

  export type option_groupsCreateManyBrandsInputEnvelope = {
    data: option_groupsCreateManyBrandsInput | option_groupsCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type payment_typesCreateWithoutBrandsInput = {
    description: string
    payments?: paymentsCreateNestedManyWithoutPayment_typesInput
  }

  export type payment_typesUncheckedCreateWithoutBrandsInput = {
    id?: number
    description: string
    payments?: paymentsUncheckedCreateNestedManyWithoutPayment_typesInput
  }

  export type payment_typesCreateOrConnectWithoutBrandsInput = {
    where: payment_typesWhereUniqueInput
    create: XOR<payment_typesCreateWithoutBrandsInput, payment_typesUncheckedCreateWithoutBrandsInput>
  }

  export type payment_typesCreateManyBrandsInputEnvelope = {
    data: payment_typesCreateManyBrandsInput | payment_typesCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type productsCreateWithoutBrandsInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    product_sales?: product_salesCreateNestedManyWithoutProductsInput
    categories?: categoriesCreateNestedOneWithoutProductsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    product_sales?: product_salesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutBrandsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutBrandsInput, productsUncheckedCreateWithoutBrandsInput>
  }

  export type productsCreateManyBrandsInputEnvelope = {
    data: productsCreateManyBrandsInput | productsCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type storesCreateWithoutBrandsInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customersCreateNestedManyWithoutStoresInput
    sales?: salesCreateNestedManyWithoutStoresInput
    sub_brands?: sub_brandsCreateNestedOneWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customersUncheckedCreateNestedManyWithoutStoresInput
    sales?: salesUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutBrandsInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutBrandsInput, storesUncheckedCreateWithoutBrandsInput>
  }

  export type storesCreateManyBrandsInputEnvelope = {
    data: storesCreateManyBrandsInput | storesCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type sub_brandsCreateWithoutBrandsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutSub_brandsInput
    customers?: customersCreateNestedManyWithoutSub_brandsInput
    items?: itemsCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsCreateNestedManyWithoutSub_brandsInput
    products?: productsCreateNestedManyWithoutSub_brandsInput
    sales?: salesCreateNestedManyWithoutSub_brandsInput
    stores?: storesCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateWithoutBrandsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSub_brandsInput
    customers?: customersUncheckedCreateNestedManyWithoutSub_brandsInput
    items?: itemsUncheckedCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput
    products?: productsUncheckedCreateNestedManyWithoutSub_brandsInput
    sales?: salesUncheckedCreateNestedManyWithoutSub_brandsInput
    stores?: storesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsCreateOrConnectWithoutBrandsInput = {
    where: sub_brandsWhereUniqueInput
    create: XOR<sub_brandsCreateWithoutBrandsInput, sub_brandsUncheckedCreateWithoutBrandsInput>
  }

  export type sub_brandsCreateManyBrandsInputEnvelope = {
    data: sub_brandsCreateManyBrandsInput | sub_brandsCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type categoriesUpsertWithWhereUniqueWithoutBrandsInput = {
    where: categoriesWhereUniqueInput
    update: XOR<categoriesUpdateWithoutBrandsInput, categoriesUncheckedUpdateWithoutBrandsInput>
    create: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput>
  }

  export type categoriesUpdateWithWhereUniqueWithoutBrandsInput = {
    where: categoriesWhereUniqueInput
    data: XOR<categoriesUpdateWithoutBrandsInput, categoriesUncheckedUpdateWithoutBrandsInput>
  }

  export type categoriesUpdateManyWithWhereWithoutBrandsInput = {
    where: categoriesScalarWhereInput
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyWithoutBrandsInput>
  }

  export type categoriesScalarWhereInput = {
    AND?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    OR?: categoriesScalarWhereInput[]
    NOT?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    id?: IntFilter<"categories"> | number
    brand_id?: IntNullableFilter<"categories"> | number | null
    sub_brand_id?: IntNullableFilter<"categories"> | number | null
    name?: StringFilter<"categories"> | string
    type?: StringNullableFilter<"categories"> | string | null
    pos_uuid?: StringNullableFilter<"categories"> | string | null
    deleted_at?: DateTimeNullableFilter<"categories"> | Date | string | null
  }

  export type channelsUpsertWithWhereUniqueWithoutBrandsInput = {
    where: channelsWhereUniqueInput
    update: XOR<channelsUpdateWithoutBrandsInput, channelsUncheckedUpdateWithoutBrandsInput>
    create: XOR<channelsCreateWithoutBrandsInput, channelsUncheckedCreateWithoutBrandsInput>
  }

  export type channelsUpdateWithWhereUniqueWithoutBrandsInput = {
    where: channelsWhereUniqueInput
    data: XOR<channelsUpdateWithoutBrandsInput, channelsUncheckedUpdateWithoutBrandsInput>
  }

  export type channelsUpdateManyWithWhereWithoutBrandsInput = {
    where: channelsScalarWhereInput
    data: XOR<channelsUpdateManyMutationInput, channelsUncheckedUpdateManyWithoutBrandsInput>
  }

  export type channelsScalarWhereInput = {
    AND?: channelsScalarWhereInput | channelsScalarWhereInput[]
    OR?: channelsScalarWhereInput[]
    NOT?: channelsScalarWhereInput | channelsScalarWhereInput[]
    id?: IntFilter<"channels"> | number
    brand_id?: IntNullableFilter<"channels"> | number | null
    name?: StringFilter<"channels"> | string
    description?: StringNullableFilter<"channels"> | string | null
    type?: StringNullableFilter<"channels"> | string | null
    created_at?: DateTimeNullableFilter<"channels"> | Date | string | null
  }

  export type couponsUpsertWithWhereUniqueWithoutBrandsInput = {
    where: couponsWhereUniqueInput
    update: XOR<couponsUpdateWithoutBrandsInput, couponsUncheckedUpdateWithoutBrandsInput>
    create: XOR<couponsCreateWithoutBrandsInput, couponsUncheckedCreateWithoutBrandsInput>
  }

  export type couponsUpdateWithWhereUniqueWithoutBrandsInput = {
    where: couponsWhereUniqueInput
    data: XOR<couponsUpdateWithoutBrandsInput, couponsUncheckedUpdateWithoutBrandsInput>
  }

  export type couponsUpdateManyWithWhereWithoutBrandsInput = {
    where: couponsScalarWhereInput
    data: XOR<couponsUpdateManyMutationInput, couponsUncheckedUpdateManyWithoutBrandsInput>
  }

  export type couponsScalarWhereInput = {
    AND?: couponsScalarWhereInput | couponsScalarWhereInput[]
    OR?: couponsScalarWhereInput[]
    NOT?: couponsScalarWhereInput | couponsScalarWhereInput[]
    id?: IntFilter<"coupons"> | number
    brand_id?: IntNullableFilter<"coupons"> | number | null
    code?: StringFilter<"coupons"> | string
    discount_type?: StringNullableFilter<"coupons"> | string | null
    discount_value?: DecimalNullableFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"coupons"> | boolean | null
    valid_from?: DateTimeNullableFilter<"coupons"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"coupons"> | Date | string | null
  }

  export type itemsUpsertWithWhereUniqueWithoutBrandsInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutBrandsInput, itemsUncheckedUpdateWithoutBrandsInput>
    create: XOR<itemsCreateWithoutBrandsInput, itemsUncheckedCreateWithoutBrandsInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutBrandsInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutBrandsInput, itemsUncheckedUpdateWithoutBrandsInput>
  }

  export type itemsUpdateManyWithWhereWithoutBrandsInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutBrandsInput>
  }

  export type itemsScalarWhereInput = {
    AND?: itemsScalarWhereInput | itemsScalarWhereInput[]
    OR?: itemsScalarWhereInput[]
    NOT?: itemsScalarWhereInput | itemsScalarWhereInput[]
    id?: IntFilter<"items"> | number
    brand_id?: IntNullableFilter<"items"> | number | null
    sub_brand_id?: IntNullableFilter<"items"> | number | null
    category_id?: IntNullableFilter<"items"> | number | null
    name?: StringFilter<"items"> | string
    pos_uuid?: StringNullableFilter<"items"> | string | null
    deleted_at?: DateTimeNullableFilter<"items"> | Date | string | null
  }

  export type option_groupsUpsertWithWhereUniqueWithoutBrandsInput = {
    where: option_groupsWhereUniqueInput
    update: XOR<option_groupsUpdateWithoutBrandsInput, option_groupsUncheckedUpdateWithoutBrandsInput>
    create: XOR<option_groupsCreateWithoutBrandsInput, option_groupsUncheckedCreateWithoutBrandsInput>
  }

  export type option_groupsUpdateWithWhereUniqueWithoutBrandsInput = {
    where: option_groupsWhereUniqueInput
    data: XOR<option_groupsUpdateWithoutBrandsInput, option_groupsUncheckedUpdateWithoutBrandsInput>
  }

  export type option_groupsUpdateManyWithWhereWithoutBrandsInput = {
    where: option_groupsScalarWhereInput
    data: XOR<option_groupsUpdateManyMutationInput, option_groupsUncheckedUpdateManyWithoutBrandsInput>
  }

  export type option_groupsScalarWhereInput = {
    AND?: option_groupsScalarWhereInput | option_groupsScalarWhereInput[]
    OR?: option_groupsScalarWhereInput[]
    NOT?: option_groupsScalarWhereInput | option_groupsScalarWhereInput[]
    id?: IntFilter<"option_groups"> | number
    brand_id?: IntNullableFilter<"option_groups"> | number | null
    sub_brand_id?: IntNullableFilter<"option_groups"> | number | null
    category_id?: IntNullableFilter<"option_groups"> | number | null
    name?: StringFilter<"option_groups"> | string
    pos_uuid?: StringNullableFilter<"option_groups"> | string | null
    deleted_at?: DateTimeNullableFilter<"option_groups"> | Date | string | null
  }

  export type payment_typesUpsertWithWhereUniqueWithoutBrandsInput = {
    where: payment_typesWhereUniqueInput
    update: XOR<payment_typesUpdateWithoutBrandsInput, payment_typesUncheckedUpdateWithoutBrandsInput>
    create: XOR<payment_typesCreateWithoutBrandsInput, payment_typesUncheckedCreateWithoutBrandsInput>
  }

  export type payment_typesUpdateWithWhereUniqueWithoutBrandsInput = {
    where: payment_typesWhereUniqueInput
    data: XOR<payment_typesUpdateWithoutBrandsInput, payment_typesUncheckedUpdateWithoutBrandsInput>
  }

  export type payment_typesUpdateManyWithWhereWithoutBrandsInput = {
    where: payment_typesScalarWhereInput
    data: XOR<payment_typesUpdateManyMutationInput, payment_typesUncheckedUpdateManyWithoutBrandsInput>
  }

  export type payment_typesScalarWhereInput = {
    AND?: payment_typesScalarWhereInput | payment_typesScalarWhereInput[]
    OR?: payment_typesScalarWhereInput[]
    NOT?: payment_typesScalarWhereInput | payment_typesScalarWhereInput[]
    id?: IntFilter<"payment_types"> | number
    brand_id?: IntNullableFilter<"payment_types"> | number | null
    description?: StringFilter<"payment_types"> | string
  }

  export type productsUpsertWithWhereUniqueWithoutBrandsInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutBrandsInput, productsUncheckedUpdateWithoutBrandsInput>
    create: XOR<productsCreateWithoutBrandsInput, productsUncheckedCreateWithoutBrandsInput>
  }

  export type productsUpdateWithWhereUniqueWithoutBrandsInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutBrandsInput, productsUncheckedUpdateWithoutBrandsInput>
  }

  export type productsUpdateManyWithWhereWithoutBrandsInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutBrandsInput>
  }

  export type productsScalarWhereInput = {
    AND?: productsScalarWhereInput | productsScalarWhereInput[]
    OR?: productsScalarWhereInput[]
    NOT?: productsScalarWhereInput | productsScalarWhereInput[]
    id?: IntFilter<"products"> | number
    brand_id?: IntNullableFilter<"products"> | number | null
    sub_brand_id?: IntNullableFilter<"products"> | number | null
    category_id?: IntNullableFilter<"products"> | number | null
    name?: StringFilter<"products"> | string
    pos_uuid?: StringNullableFilter<"products"> | string | null
    deleted_at?: DateTimeNullableFilter<"products"> | Date | string | null
  }

  export type storesUpsertWithWhereUniqueWithoutBrandsInput = {
    where: storesWhereUniqueInput
    update: XOR<storesUpdateWithoutBrandsInput, storesUncheckedUpdateWithoutBrandsInput>
    create: XOR<storesCreateWithoutBrandsInput, storesUncheckedCreateWithoutBrandsInput>
  }

  export type storesUpdateWithWhereUniqueWithoutBrandsInput = {
    where: storesWhereUniqueInput
    data: XOR<storesUpdateWithoutBrandsInput, storesUncheckedUpdateWithoutBrandsInput>
  }

  export type storesUpdateManyWithWhereWithoutBrandsInput = {
    where: storesScalarWhereInput
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyWithoutBrandsInput>
  }

  export type storesScalarWhereInput = {
    AND?: storesScalarWhereInput | storesScalarWhereInput[]
    OR?: storesScalarWhereInput[]
    NOT?: storesScalarWhereInput | storesScalarWhereInput[]
    id?: IntFilter<"stores"> | number
    brand_id?: IntNullableFilter<"stores"> | number | null
    sub_brand_id?: IntNullableFilter<"stores"> | number | null
    name?: StringFilter<"stores"> | string
    city?: StringNullableFilter<"stores"> | string | null
    state?: StringNullableFilter<"stores"> | string | null
    district?: StringNullableFilter<"stores"> | string | null
    address_street?: StringNullableFilter<"stores"> | string | null
    address_number?: IntNullableFilter<"stores"> | number | null
    zipcode?: StringNullableFilter<"stores"> | string | null
    latitude?: DecimalNullableFilter<"stores"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"stores"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"stores"> | boolean | null
    is_own?: BoolNullableFilter<"stores"> | boolean | null
    is_holding?: BoolNullableFilter<"stores"> | boolean | null
    creation_date?: DateTimeNullableFilter<"stores"> | Date | string | null
    created_at?: DateTimeNullableFilter<"stores"> | Date | string | null
  }

  export type sub_brandsUpsertWithWhereUniqueWithoutBrandsInput = {
    where: sub_brandsWhereUniqueInput
    update: XOR<sub_brandsUpdateWithoutBrandsInput, sub_brandsUncheckedUpdateWithoutBrandsInput>
    create: XOR<sub_brandsCreateWithoutBrandsInput, sub_brandsUncheckedCreateWithoutBrandsInput>
  }

  export type sub_brandsUpdateWithWhereUniqueWithoutBrandsInput = {
    where: sub_brandsWhereUniqueInput
    data: XOR<sub_brandsUpdateWithoutBrandsInput, sub_brandsUncheckedUpdateWithoutBrandsInput>
  }

  export type sub_brandsUpdateManyWithWhereWithoutBrandsInput = {
    where: sub_brandsScalarWhereInput
    data: XOR<sub_brandsUpdateManyMutationInput, sub_brandsUncheckedUpdateManyWithoutBrandsInput>
  }

  export type sub_brandsScalarWhereInput = {
    AND?: sub_brandsScalarWhereInput | sub_brandsScalarWhereInput[]
    OR?: sub_brandsScalarWhereInput[]
    NOT?: sub_brandsScalarWhereInput | sub_brandsScalarWhereInput[]
    id?: IntFilter<"sub_brands"> | number
    brand_id?: IntNullableFilter<"sub_brands"> | number | null
    name?: StringFilter<"sub_brands"> | string
    created_at?: DateTimeNullableFilter<"sub_brands"> | Date | string | null
  }

  export type brandsCreateWithoutCategoriesInput = {
    name: string
    created_at?: Date | string | null
    channels?: channelsCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutCategoriesInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutCategoriesInput, brandsUncheckedCreateWithoutCategoriesInput>
  }

  export type sub_brandsCreateWithoutCategoriesInput = {
    name: string
    created_at?: Date | string | null
    customers?: customersCreateNestedManyWithoutSub_brandsInput
    items?: itemsCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsCreateNestedManyWithoutSub_brandsInput
    products?: productsCreateNestedManyWithoutSub_brandsInput
    sales?: salesCreateNestedManyWithoutSub_brandsInput
    stores?: storesCreateNestedManyWithoutSub_brandsInput
    brands?: brandsCreateNestedOneWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
    customers?: customersUncheckedCreateNestedManyWithoutSub_brandsInput
    items?: itemsUncheckedCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput
    products?: productsUncheckedCreateNestedManyWithoutSub_brandsInput
    sales?: salesUncheckedCreateNestedManyWithoutSub_brandsInput
    stores?: storesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsCreateOrConnectWithoutCategoriesInput = {
    where: sub_brandsWhereUniqueInput
    create: XOR<sub_brandsCreateWithoutCategoriesInput, sub_brandsUncheckedCreateWithoutCategoriesInput>
  }

  export type itemsCreateWithoutCategoriesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItemsInput
    item_product_sales?: item_product_salesCreateNestedManyWithoutItemsInput
    brands?: brandsCreateNestedOneWithoutItemsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItemsInput
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutCategoriesInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutCategoriesInput, itemsUncheckedCreateWithoutCategoriesInput>
  }

  export type itemsCreateManyCategoriesInputEnvelope = {
    data: itemsCreateManyCategoriesInput | itemsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type option_groupsCreateWithoutCategoriesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutOption_groupsInput
    item_product_sales?: item_product_salesCreateNestedManyWithoutOption_groupsInput
    brands?: brandsCreateNestedOneWithoutOption_groupsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutOption_groupsInput
  }

  export type option_groupsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
  }

  export type option_groupsCreateOrConnectWithoutCategoriesInput = {
    where: option_groupsWhereUniqueInput
    create: XOR<option_groupsCreateWithoutCategoriesInput, option_groupsUncheckedCreateWithoutCategoriesInput>
  }

  export type option_groupsCreateManyCategoriesInputEnvelope = {
    data: option_groupsCreateManyCategoriesInput | option_groupsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type productsCreateWithoutCategoriesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    product_sales?: product_salesCreateNestedManyWithoutProductsInput
    brands?: brandsCreateNestedOneWithoutProductsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    product_sales?: product_salesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutCategoriesInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput>
  }

  export type productsCreateManyCategoriesInputEnvelope = {
    data: productsCreateManyCategoriesInput | productsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type brandsUpsertWithoutCategoriesInput = {
    update: XOR<brandsUpdateWithoutCategoriesInput, brandsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<brandsCreateWithoutCategoriesInput, brandsUncheckedCreateWithoutCategoriesInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutCategoriesInput, brandsUncheckedUpdateWithoutCategoriesInput>
  }

  export type brandsUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type sub_brandsUpsertWithoutCategoriesInput = {
    update: XOR<sub_brandsUpdateWithoutCategoriesInput, sub_brandsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<sub_brandsCreateWithoutCategoriesInput, sub_brandsUncheckedCreateWithoutCategoriesInput>
    where?: sub_brandsWhereInput
  }

  export type sub_brandsUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: sub_brandsWhereInput
    data: XOR<sub_brandsUpdateWithoutCategoriesInput, sub_brandsUncheckedUpdateWithoutCategoriesInput>
  }

  export type sub_brandsUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutSub_brandsNestedInput
    products?: productsUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUpdateManyWithoutSub_brandsNestedInput
    brands?: brandsUpdateOneWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUncheckedUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput
    products?: productsUncheckedUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUncheckedUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type itemsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutCategoriesInput, itemsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<itemsCreateWithoutCategoriesInput, itemsUncheckedCreateWithoutCategoriesInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutCategoriesInput, itemsUncheckedUpdateWithoutCategoriesInput>
  }

  export type itemsUpdateManyWithWhereWithoutCategoriesInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type option_groupsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: option_groupsWhereUniqueInput
    update: XOR<option_groupsUpdateWithoutCategoriesInput, option_groupsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<option_groupsCreateWithoutCategoriesInput, option_groupsUncheckedCreateWithoutCategoriesInput>
  }

  export type option_groupsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: option_groupsWhereUniqueInput
    data: XOR<option_groupsUpdateWithoutCategoriesInput, option_groupsUncheckedUpdateWithoutCategoriesInput>
  }

  export type option_groupsUpdateManyWithWhereWithoutCategoriesInput = {
    where: option_groupsScalarWhereInput
    data: XOR<option_groupsUpdateManyMutationInput, option_groupsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type productsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutCategoriesInput, productsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput>
  }

  export type productsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutCategoriesInput, productsUncheckedUpdateWithoutCategoriesInput>
  }

  export type productsUpdateManyWithWhereWithoutCategoriesInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type brandsCreateWithoutChannelsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutChannelsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutChannelsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutChannelsInput, brandsUncheckedCreateWithoutChannelsInput>
  }

  export type salesCreateWithoutChannelsInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutChannelsInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutChannelsInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutChannelsInput, salesUncheckedCreateWithoutChannelsInput>
  }

  export type salesCreateManyChannelsInputEnvelope = {
    data: salesCreateManyChannelsInput | salesCreateManyChannelsInput[]
    skipDuplicates?: boolean
  }

  export type brandsUpsertWithoutChannelsInput = {
    update: XOR<brandsUpdateWithoutChannelsInput, brandsUncheckedUpdateWithoutChannelsInput>
    create: XOR<brandsCreateWithoutChannelsInput, brandsUncheckedCreateWithoutChannelsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutChannelsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutChannelsInput, brandsUncheckedUpdateWithoutChannelsInput>
  }

  export type brandsUpdateWithoutChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type salesUpsertWithWhereUniqueWithoutChannelsInput = {
    where: salesWhereUniqueInput
    update: XOR<salesUpdateWithoutChannelsInput, salesUncheckedUpdateWithoutChannelsInput>
    create: XOR<salesCreateWithoutChannelsInput, salesUncheckedCreateWithoutChannelsInput>
  }

  export type salesUpdateWithWhereUniqueWithoutChannelsInput = {
    where: salesWhereUniqueInput
    data: XOR<salesUpdateWithoutChannelsInput, salesUncheckedUpdateWithoutChannelsInput>
  }

  export type salesUpdateManyWithWhereWithoutChannelsInput = {
    where: salesScalarWhereInput
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyWithoutChannelsInput>
  }

  export type salesScalarWhereInput = {
    AND?: salesScalarWhereInput | salesScalarWhereInput[]
    OR?: salesScalarWhereInput[]
    NOT?: salesScalarWhereInput | salesScalarWhereInput[]
    id?: IntFilter<"sales"> | number
    store_id?: IntFilter<"sales"> | number
    sub_brand_id?: IntNullableFilter<"sales"> | number | null
    customer_id?: IntNullableFilter<"sales"> | number | null
    channel_id?: IntFilter<"sales"> | number
    cod_sale1?: StringNullableFilter<"sales"> | string | null
    cod_sale2?: StringNullableFilter<"sales"> | string | null
    created_at?: DateTimeFilter<"sales"> | Date | string
    customer_name?: StringNullableFilter<"sales"> | string | null
    sale_status_desc?: StringFilter<"sales"> | string
    total_amount_items?: DecimalFilter<"sales"> | Decimal | DecimalJsLike | number | string
    total_discount?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    total_increase?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFilter<"sales"> | Decimal | DecimalJsLike | number | string
    value_paid?: DecimalNullableFilter<"sales"> | Decimal | DecimalJsLike | number | string | null
    production_seconds?: IntNullableFilter<"sales"> | number | null
    delivery_seconds?: IntNullableFilter<"sales"> | number | null
    people_quantity?: IntNullableFilter<"sales"> | number | null
    discount_reason?: StringNullableFilter<"sales"> | string | null
    increase_reason?: StringNullableFilter<"sales"> | string | null
    origin?: StringNullableFilter<"sales"> | string | null
  }

  export type couponsCreateWithoutCoupon_salesInput = {
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    brands?: brandsCreateNestedOneWithoutCouponsInput
  }

  export type couponsUncheckedCreateWithoutCoupon_salesInput = {
    id?: number
    brand_id?: number | null
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
  }

  export type couponsCreateOrConnectWithoutCoupon_salesInput = {
    where: couponsWhereUniqueInput
    create: XOR<couponsCreateWithoutCoupon_salesInput, couponsUncheckedCreateWithoutCoupon_salesInput>
  }

  export type salesCreateWithoutCoupon_salesInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutCoupon_salesInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutCoupon_salesInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutCoupon_salesInput, salesUncheckedCreateWithoutCoupon_salesInput>
  }

  export type couponsUpsertWithoutCoupon_salesInput = {
    update: XOR<couponsUpdateWithoutCoupon_salesInput, couponsUncheckedUpdateWithoutCoupon_salesInput>
    create: XOR<couponsCreateWithoutCoupon_salesInput, couponsUncheckedCreateWithoutCoupon_salesInput>
    where?: couponsWhereInput
  }

  export type couponsUpdateToOneWithWhereWithoutCoupon_salesInput = {
    where?: couponsWhereInput
    data: XOR<couponsUpdateWithoutCoupon_salesInput, couponsUncheckedUpdateWithoutCoupon_salesInput>
  }

  export type couponsUpdateWithoutCoupon_salesInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutCouponsNestedInput
  }

  export type couponsUncheckedUpdateWithoutCoupon_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salesUpsertWithoutCoupon_salesInput = {
    update: XOR<salesUpdateWithoutCoupon_salesInput, salesUncheckedUpdateWithoutCoupon_salesInput>
    create: XOR<salesCreateWithoutCoupon_salesInput, salesUncheckedCreateWithoutCoupon_salesInput>
    where?: salesWhereInput
  }

  export type salesUpdateToOneWithWhereWithoutCoupon_salesInput = {
    where?: salesWhereInput
    data: XOR<salesUpdateWithoutCoupon_salesInput, salesUncheckedUpdateWithoutCoupon_salesInput>
  }

  export type salesUpdateWithoutCoupon_salesInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutCoupon_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type coupon_salesCreateWithoutCouponsInput = {
    value?: number | null
    target?: string | null
    sponsorship?: string | null
    sales?: salesCreateNestedOneWithoutCoupon_salesInput
  }

  export type coupon_salesUncheckedCreateWithoutCouponsInput = {
    id?: number
    sale_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type coupon_salesCreateOrConnectWithoutCouponsInput = {
    where: coupon_salesWhereUniqueInput
    create: XOR<coupon_salesCreateWithoutCouponsInput, coupon_salesUncheckedCreateWithoutCouponsInput>
  }

  export type coupon_salesCreateManyCouponsInputEnvelope = {
    data: coupon_salesCreateManyCouponsInput | coupon_salesCreateManyCouponsInput[]
    skipDuplicates?: boolean
  }

  export type brandsCreateWithoutCouponsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    channels?: channelsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutCouponsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutCouponsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutCouponsInput, brandsUncheckedCreateWithoutCouponsInput>
  }

  export type coupon_salesUpsertWithWhereUniqueWithoutCouponsInput = {
    where: coupon_salesWhereUniqueInput
    update: XOR<coupon_salesUpdateWithoutCouponsInput, coupon_salesUncheckedUpdateWithoutCouponsInput>
    create: XOR<coupon_salesCreateWithoutCouponsInput, coupon_salesUncheckedCreateWithoutCouponsInput>
  }

  export type coupon_salesUpdateWithWhereUniqueWithoutCouponsInput = {
    where: coupon_salesWhereUniqueInput
    data: XOR<coupon_salesUpdateWithoutCouponsInput, coupon_salesUncheckedUpdateWithoutCouponsInput>
  }

  export type coupon_salesUpdateManyWithWhereWithoutCouponsInput = {
    where: coupon_salesScalarWhereInput
    data: XOR<coupon_salesUpdateManyMutationInput, coupon_salesUncheckedUpdateManyWithoutCouponsInput>
  }

  export type coupon_salesScalarWhereInput = {
    AND?: coupon_salesScalarWhereInput | coupon_salesScalarWhereInput[]
    OR?: coupon_salesScalarWhereInput[]
    NOT?: coupon_salesScalarWhereInput | coupon_salesScalarWhereInput[]
    id?: IntFilter<"coupon_sales"> | number
    sale_id?: IntNullableFilter<"coupon_sales"> | number | null
    coupon_id?: IntNullableFilter<"coupon_sales"> | number | null
    value?: FloatNullableFilter<"coupon_sales"> | number | null
    target?: StringNullableFilter<"coupon_sales"> | string | null
    sponsorship?: StringNullableFilter<"coupon_sales"> | string | null
  }

  export type brandsUpsertWithoutCouponsInput = {
    update: XOR<brandsUpdateWithoutCouponsInput, brandsUncheckedUpdateWithoutCouponsInput>
    create: XOR<brandsCreateWithoutCouponsInput, brandsUncheckedCreateWithoutCouponsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutCouponsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutCouponsInput, brandsUncheckedUpdateWithoutCouponsInput>
  }

  export type brandsUpdateWithoutCouponsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type storesCreateWithoutCustomersInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    sales?: salesCreateNestedManyWithoutStoresInput
    brands?: brandsCreateNestedOneWithoutStoresInput
    sub_brands?: sub_brandsCreateNestedOneWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutCustomersInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    sales?: salesUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutCustomersInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutCustomersInput, storesUncheckedCreateWithoutCustomersInput>
  }

  export type sub_brandsCreateWithoutCustomersInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutSub_brandsInput
    items?: itemsCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsCreateNestedManyWithoutSub_brandsInput
    products?: productsCreateNestedManyWithoutSub_brandsInput
    sales?: salesCreateNestedManyWithoutSub_brandsInput
    stores?: storesCreateNestedManyWithoutSub_brandsInput
    brands?: brandsCreateNestedOneWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateWithoutCustomersInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSub_brandsInput
    items?: itemsUncheckedCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput
    products?: productsUncheckedCreateNestedManyWithoutSub_brandsInput
    sales?: salesUncheckedCreateNestedManyWithoutSub_brandsInput
    stores?: storesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsCreateOrConnectWithoutCustomersInput = {
    where: sub_brandsWhereUniqueInput
    create: XOR<sub_brandsCreateWithoutCustomersInput, sub_brandsUncheckedCreateWithoutCustomersInput>
  }

  export type salesCreateWithoutCustomersInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutCustomersInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutCustomersInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutCustomersInput, salesUncheckedCreateWithoutCustomersInput>
  }

  export type salesCreateManyCustomersInputEnvelope = {
    data: salesCreateManyCustomersInput | salesCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type storesUpsertWithoutCustomersInput = {
    update: XOR<storesUpdateWithoutCustomersInput, storesUncheckedUpdateWithoutCustomersInput>
    create: XOR<storesCreateWithoutCustomersInput, storesUncheckedCreateWithoutCustomersInput>
    where?: storesWhereInput
  }

  export type storesUpdateToOneWithWhereWithoutCustomersInput = {
    where?: storesWhereInput
    data: XOR<storesUpdateWithoutCustomersInput, storesUncheckedUpdateWithoutCustomersInput>
  }

  export type storesUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: salesUpdateManyWithoutStoresNestedInput
    brands?: brandsUpdateOneWithoutStoresNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: salesUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type sub_brandsUpsertWithoutCustomersInput = {
    update: XOR<sub_brandsUpdateWithoutCustomersInput, sub_brandsUncheckedUpdateWithoutCustomersInput>
    create: XOR<sub_brandsCreateWithoutCustomersInput, sub_brandsUncheckedCreateWithoutCustomersInput>
    where?: sub_brandsWhereInput
  }

  export type sub_brandsUpdateToOneWithWhereWithoutCustomersInput = {
    where?: sub_brandsWhereInput
    data: XOR<sub_brandsUpdateWithoutCustomersInput, sub_brandsUncheckedUpdateWithoutCustomersInput>
  }

  export type sub_brandsUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutSub_brandsNestedInput
    products?: productsUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUpdateManyWithoutSub_brandsNestedInput
    brands?: brandsUpdateOneWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput
    products?: productsUncheckedUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUncheckedUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type salesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: salesWhereUniqueInput
    update: XOR<salesUpdateWithoutCustomersInput, salesUncheckedUpdateWithoutCustomersInput>
    create: XOR<salesCreateWithoutCustomersInput, salesUncheckedCreateWithoutCustomersInput>
  }

  export type salesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: salesWhereUniqueInput
    data: XOR<salesUpdateWithoutCustomersInput, salesUncheckedUpdateWithoutCustomersInput>
  }

  export type salesUpdateManyWithWhereWithoutCustomersInput = {
    where: salesScalarWhereInput
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyWithoutCustomersInput>
  }

  export type delivery_salesCreateWithoutDelivery_addressesInput = {
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    sales: salesCreateNestedOneWithoutDelivery_salesInput
  }

  export type delivery_salesUncheckedCreateWithoutDelivery_addressesInput = {
    id?: number
    sale_id: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
  }

  export type delivery_salesCreateOrConnectWithoutDelivery_addressesInput = {
    where: delivery_salesWhereUniqueInput
    create: XOR<delivery_salesCreateWithoutDelivery_addressesInput, delivery_salesUncheckedCreateWithoutDelivery_addressesInput>
  }

  export type salesCreateWithoutDelivery_addressesInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutDelivery_addressesInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutDelivery_addressesInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutDelivery_addressesInput, salesUncheckedCreateWithoutDelivery_addressesInput>
  }

  export type delivery_salesUpsertWithoutDelivery_addressesInput = {
    update: XOR<delivery_salesUpdateWithoutDelivery_addressesInput, delivery_salesUncheckedUpdateWithoutDelivery_addressesInput>
    create: XOR<delivery_salesCreateWithoutDelivery_addressesInput, delivery_salesUncheckedCreateWithoutDelivery_addressesInput>
    where?: delivery_salesWhereInput
  }

  export type delivery_salesUpdateToOneWithWhereWithoutDelivery_addressesInput = {
    where?: delivery_salesWhereInput
    data: XOR<delivery_salesUpdateWithoutDelivery_addressesInput, delivery_salesUncheckedUpdateWithoutDelivery_addressesInput>
  }

  export type delivery_salesUpdateWithoutDelivery_addressesInput = {
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: salesUpdateOneRequiredWithoutDelivery_salesNestedInput
  }

  export type delivery_salesUncheckedUpdateWithoutDelivery_addressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type salesUpsertWithoutDelivery_addressesInput = {
    update: XOR<salesUpdateWithoutDelivery_addressesInput, salesUncheckedUpdateWithoutDelivery_addressesInput>
    create: XOR<salesCreateWithoutDelivery_addressesInput, salesUncheckedCreateWithoutDelivery_addressesInput>
    where?: salesWhereInput
  }

  export type salesUpdateToOneWithWhereWithoutDelivery_addressesInput = {
    where?: salesWhereInput
    data: XOR<salesUpdateWithoutDelivery_addressesInput, salesUncheckedUpdateWithoutDelivery_addressesInput>
  }

  export type salesUpdateWithoutDelivery_addressesInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutDelivery_addressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type delivery_addressesCreateWithoutDelivery_salesInput = {
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
    sales: salesCreateNestedOneWithoutDelivery_addressesInput
  }

  export type delivery_addressesUncheckedCreateWithoutDelivery_salesInput = {
    id?: number
    sale_id: number
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type delivery_addressesCreateOrConnectWithoutDelivery_salesInput = {
    where: delivery_addressesWhereUniqueInput
    create: XOR<delivery_addressesCreateWithoutDelivery_salesInput, delivery_addressesUncheckedCreateWithoutDelivery_salesInput>
  }

  export type delivery_addressesCreateManyDelivery_salesInputEnvelope = {
    data: delivery_addressesCreateManyDelivery_salesInput | delivery_addressesCreateManyDelivery_salesInput[]
    skipDuplicates?: boolean
  }

  export type salesCreateWithoutDelivery_salesInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutDelivery_salesInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutDelivery_salesInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutDelivery_salesInput, salesUncheckedCreateWithoutDelivery_salesInput>
  }

  export type delivery_addressesUpsertWithWhereUniqueWithoutDelivery_salesInput = {
    where: delivery_addressesWhereUniqueInput
    update: XOR<delivery_addressesUpdateWithoutDelivery_salesInput, delivery_addressesUncheckedUpdateWithoutDelivery_salesInput>
    create: XOR<delivery_addressesCreateWithoutDelivery_salesInput, delivery_addressesUncheckedCreateWithoutDelivery_salesInput>
  }

  export type delivery_addressesUpdateWithWhereUniqueWithoutDelivery_salesInput = {
    where: delivery_addressesWhereUniqueInput
    data: XOR<delivery_addressesUpdateWithoutDelivery_salesInput, delivery_addressesUncheckedUpdateWithoutDelivery_salesInput>
  }

  export type delivery_addressesUpdateManyWithWhereWithoutDelivery_salesInput = {
    where: delivery_addressesScalarWhereInput
    data: XOR<delivery_addressesUpdateManyMutationInput, delivery_addressesUncheckedUpdateManyWithoutDelivery_salesInput>
  }

  export type delivery_addressesScalarWhereInput = {
    AND?: delivery_addressesScalarWhereInput | delivery_addressesScalarWhereInput[]
    OR?: delivery_addressesScalarWhereInput[]
    NOT?: delivery_addressesScalarWhereInput | delivery_addressesScalarWhereInput[]
    id?: IntFilter<"delivery_addresses"> | number
    sale_id?: IntFilter<"delivery_addresses"> | number
    delivery_sale_id?: IntNullableFilter<"delivery_addresses"> | number | null
    street?: StringNullableFilter<"delivery_addresses"> | string | null
    number?: StringNullableFilter<"delivery_addresses"> | string | null
    complement?: StringNullableFilter<"delivery_addresses"> | string | null
    formatted_address?: StringNullableFilter<"delivery_addresses"> | string | null
    neighborhood?: StringNullableFilter<"delivery_addresses"> | string | null
    city?: StringNullableFilter<"delivery_addresses"> | string | null
    state?: StringNullableFilter<"delivery_addresses"> | string | null
    country?: StringNullableFilter<"delivery_addresses"> | string | null
    postal_code?: StringNullableFilter<"delivery_addresses"> | string | null
    reference?: StringNullableFilter<"delivery_addresses"> | string | null
    latitude?: FloatNullableFilter<"delivery_addresses"> | number | null
    longitude?: FloatNullableFilter<"delivery_addresses"> | number | null
  }

  export type salesUpsertWithoutDelivery_salesInput = {
    update: XOR<salesUpdateWithoutDelivery_salesInput, salesUncheckedUpdateWithoutDelivery_salesInput>
    create: XOR<salesCreateWithoutDelivery_salesInput, salesUncheckedCreateWithoutDelivery_salesInput>
    where?: salesWhereInput
  }

  export type salesUpdateToOneWithWhereWithoutDelivery_salesInput = {
    where?: salesWhereInput
    data: XOR<salesUpdateWithoutDelivery_salesInput, salesUncheckedUpdateWithoutDelivery_salesInput>
  }

  export type salesUpdateWithoutDelivery_salesInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutDelivery_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type itemsCreateWithoutItem_item_product_salesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_product_sales?: item_product_salesCreateNestedManyWithoutItemsInput
    brands?: brandsCreateNestedOneWithoutItemsInput
    categories?: categoriesCreateNestedOneWithoutItemsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutItem_item_product_salesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutItem_item_product_salesInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutItem_item_product_salesInput, itemsUncheckedCreateWithoutItem_item_product_salesInput>
  }

  export type item_product_salesCreateWithoutItem_item_product_salesInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    items: itemsCreateNestedOneWithoutItem_product_salesInput
    option_groups?: option_groupsCreateNestedOneWithoutItem_product_salesInput
    product_sales: product_salesCreateNestedOneWithoutItem_product_salesInput
  }

  export type item_product_salesUncheckedCreateWithoutItem_item_product_salesInput = {
    id?: number
    product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type item_product_salesCreateOrConnectWithoutItem_item_product_salesInput = {
    where: item_product_salesWhereUniqueInput
    create: XOR<item_product_salesCreateWithoutItem_item_product_salesInput, item_product_salesUncheckedCreateWithoutItem_item_product_salesInput>
  }

  export type option_groupsCreateWithoutItem_item_product_salesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_product_sales?: item_product_salesCreateNestedManyWithoutOption_groupsInput
    brands?: brandsCreateNestedOneWithoutOption_groupsInput
    categories?: categoriesCreateNestedOneWithoutOption_groupsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutOption_groupsInput
  }

  export type option_groupsUncheckedCreateWithoutItem_item_product_salesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
  }

  export type option_groupsCreateOrConnectWithoutItem_item_product_salesInput = {
    where: option_groupsWhereUniqueInput
    create: XOR<option_groupsCreateWithoutItem_item_product_salesInput, option_groupsUncheckedCreateWithoutItem_item_product_salesInput>
  }

  export type itemsUpsertWithoutItem_item_product_salesInput = {
    update: XOR<itemsUpdateWithoutItem_item_product_salesInput, itemsUncheckedUpdateWithoutItem_item_product_salesInput>
    create: XOR<itemsCreateWithoutItem_item_product_salesInput, itemsUncheckedCreateWithoutItem_item_product_salesInput>
    where?: itemsWhereInput
  }

  export type itemsUpdateToOneWithWhereWithoutItem_item_product_salesInput = {
    where?: itemsWhereInput
    data: XOR<itemsUpdateWithoutItem_item_product_salesInput, itemsUncheckedUpdateWithoutItem_item_product_salesInput>
  }

  export type itemsUpdateWithoutItem_item_product_salesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_product_sales?: item_product_salesUpdateManyWithoutItemsNestedInput
    brands?: brandsUpdateOneWithoutItemsNestedInput
    categories?: categoriesUpdateOneWithoutItemsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutItem_item_product_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type item_product_salesUpsertWithoutItem_item_product_salesInput = {
    update: XOR<item_product_salesUpdateWithoutItem_item_product_salesInput, item_product_salesUncheckedUpdateWithoutItem_item_product_salesInput>
    create: XOR<item_product_salesCreateWithoutItem_item_product_salesInput, item_product_salesUncheckedCreateWithoutItem_item_product_salesInput>
    where?: item_product_salesWhereInput
  }

  export type item_product_salesUpdateToOneWithWhereWithoutItem_item_product_salesInput = {
    where?: item_product_salesWhereInput
    data: XOR<item_product_salesUpdateWithoutItem_item_product_salesInput, item_product_salesUncheckedUpdateWithoutItem_item_product_salesInput>
  }

  export type item_product_salesUpdateWithoutItem_item_product_salesInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    items?: itemsUpdateOneRequiredWithoutItem_product_salesNestedInput
    option_groups?: option_groupsUpdateOneWithoutItem_product_salesNestedInput
    product_sales?: product_salesUpdateOneRequiredWithoutItem_product_salesNestedInput
  }

  export type item_product_salesUncheckedUpdateWithoutItem_item_product_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type option_groupsUpsertWithoutItem_item_product_salesInput = {
    update: XOR<option_groupsUpdateWithoutItem_item_product_salesInput, option_groupsUncheckedUpdateWithoutItem_item_product_salesInput>
    create: XOR<option_groupsCreateWithoutItem_item_product_salesInput, option_groupsUncheckedCreateWithoutItem_item_product_salesInput>
    where?: option_groupsWhereInput
  }

  export type option_groupsUpdateToOneWithWhereWithoutItem_item_product_salesInput = {
    where?: option_groupsWhereInput
    data: XOR<option_groupsUpdateWithoutItem_item_product_salesInput, option_groupsUncheckedUpdateWithoutItem_item_product_salesInput>
  }

  export type option_groupsUpdateWithoutItem_item_product_salesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_product_sales?: item_product_salesUpdateManyWithoutOption_groupsNestedInput
    brands?: brandsUpdateOneWithoutOption_groupsNestedInput
    categories?: categoriesUpdateOneWithoutOption_groupsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateWithoutItem_item_product_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
  }

  export type item_item_product_salesCreateWithoutItem_product_salesInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    items: itemsCreateNestedOneWithoutItem_item_product_salesInput
    option_groups?: option_groupsCreateNestedOneWithoutItem_item_product_salesInput
  }

  export type item_item_product_salesUncheckedCreateWithoutItem_product_salesInput = {
    id?: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type item_item_product_salesCreateOrConnectWithoutItem_product_salesInput = {
    where: item_item_product_salesWhereUniqueInput
    create: XOR<item_item_product_salesCreateWithoutItem_product_salesInput, item_item_product_salesUncheckedCreateWithoutItem_product_salesInput>
  }

  export type item_item_product_salesCreateManyItem_product_salesInputEnvelope = {
    data: item_item_product_salesCreateManyItem_product_salesInput | item_item_product_salesCreateManyItem_product_salesInput[]
    skipDuplicates?: boolean
  }

  export type itemsCreateWithoutItem_product_salesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItemsInput
    brands?: brandsCreateNestedOneWithoutItemsInput
    categories?: categoriesCreateNestedOneWithoutItemsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutItem_product_salesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutItem_product_salesInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutItem_product_salesInput, itemsUncheckedCreateWithoutItem_product_salesInput>
  }

  export type option_groupsCreateWithoutItem_product_salesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutOption_groupsInput
    brands?: brandsCreateNestedOneWithoutOption_groupsInput
    categories?: categoriesCreateNestedOneWithoutOption_groupsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutOption_groupsInput
  }

  export type option_groupsUncheckedCreateWithoutItem_product_salesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
  }

  export type option_groupsCreateOrConnectWithoutItem_product_salesInput = {
    where: option_groupsWhereUniqueInput
    create: XOR<option_groupsCreateWithoutItem_product_salesInput, option_groupsUncheckedCreateWithoutItem_product_salesInput>
  }

  export type product_salesCreateWithoutItem_product_salesInput = {
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    products: productsCreateNestedOneWithoutProduct_salesInput
    sales: salesCreateNestedOneWithoutProduct_salesInput
  }

  export type product_salesUncheckedCreateWithoutItem_product_salesInput = {
    id?: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
  }

  export type product_salesCreateOrConnectWithoutItem_product_salesInput = {
    where: product_salesWhereUniqueInput
    create: XOR<product_salesCreateWithoutItem_product_salesInput, product_salesUncheckedCreateWithoutItem_product_salesInput>
  }

  export type item_item_product_salesUpsertWithWhereUniqueWithoutItem_product_salesInput = {
    where: item_item_product_salesWhereUniqueInput
    update: XOR<item_item_product_salesUpdateWithoutItem_product_salesInput, item_item_product_salesUncheckedUpdateWithoutItem_product_salesInput>
    create: XOR<item_item_product_salesCreateWithoutItem_product_salesInput, item_item_product_salesUncheckedCreateWithoutItem_product_salesInput>
  }

  export type item_item_product_salesUpdateWithWhereUniqueWithoutItem_product_salesInput = {
    where: item_item_product_salesWhereUniqueInput
    data: XOR<item_item_product_salesUpdateWithoutItem_product_salesInput, item_item_product_salesUncheckedUpdateWithoutItem_product_salesInput>
  }

  export type item_item_product_salesUpdateManyWithWhereWithoutItem_product_salesInput = {
    where: item_item_product_salesScalarWhereInput
    data: XOR<item_item_product_salesUpdateManyMutationInput, item_item_product_salesUncheckedUpdateManyWithoutItem_product_salesInput>
  }

  export type item_item_product_salesScalarWhereInput = {
    AND?: item_item_product_salesScalarWhereInput | item_item_product_salesScalarWhereInput[]
    OR?: item_item_product_salesScalarWhereInput[]
    NOT?: item_item_product_salesScalarWhereInput | item_item_product_salesScalarWhereInput[]
    id?: IntFilter<"item_item_product_sales"> | number
    item_product_sale_id?: IntFilter<"item_item_product_sales"> | number
    item_id?: IntFilter<"item_item_product_sales"> | number
    option_group_id?: IntNullableFilter<"item_item_product_sales"> | number | null
    quantity?: FloatFilter<"item_item_product_sales"> | number
    additional_price?: FloatFilter<"item_item_product_sales"> | number
    price?: FloatFilter<"item_item_product_sales"> | number
    amount?: FloatNullableFilter<"item_item_product_sales"> | number | null
  }

  export type itemsUpsertWithoutItem_product_salesInput = {
    update: XOR<itemsUpdateWithoutItem_product_salesInput, itemsUncheckedUpdateWithoutItem_product_salesInput>
    create: XOR<itemsCreateWithoutItem_product_salesInput, itemsUncheckedCreateWithoutItem_product_salesInput>
    where?: itemsWhereInput
  }

  export type itemsUpdateToOneWithWhereWithoutItem_product_salesInput = {
    where?: itemsWhereInput
    data: XOR<itemsUpdateWithoutItem_product_salesInput, itemsUncheckedUpdateWithoutItem_product_salesInput>
  }

  export type itemsUpdateWithoutItem_product_salesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItemsNestedInput
    brands?: brandsUpdateOneWithoutItemsNestedInput
    categories?: categoriesUpdateOneWithoutItemsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutItem_product_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type option_groupsUpsertWithoutItem_product_salesInput = {
    update: XOR<option_groupsUpdateWithoutItem_product_salesInput, option_groupsUncheckedUpdateWithoutItem_product_salesInput>
    create: XOR<option_groupsCreateWithoutItem_product_salesInput, option_groupsUncheckedCreateWithoutItem_product_salesInput>
    where?: option_groupsWhereInput
  }

  export type option_groupsUpdateToOneWithWhereWithoutItem_product_salesInput = {
    where?: option_groupsWhereInput
    data: XOR<option_groupsUpdateWithoutItem_product_salesInput, option_groupsUncheckedUpdateWithoutItem_product_salesInput>
  }

  export type option_groupsUpdateWithoutItem_product_salesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutOption_groupsNestedInput
    brands?: brandsUpdateOneWithoutOption_groupsNestedInput
    categories?: categoriesUpdateOneWithoutOption_groupsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateWithoutItem_product_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
  }

  export type product_salesUpsertWithoutItem_product_salesInput = {
    update: XOR<product_salesUpdateWithoutItem_product_salesInput, product_salesUncheckedUpdateWithoutItem_product_salesInput>
    create: XOR<product_salesCreateWithoutItem_product_salesInput, product_salesUncheckedCreateWithoutItem_product_salesInput>
    where?: product_salesWhereInput
  }

  export type product_salesUpdateToOneWithWhereWithoutItem_product_salesInput = {
    where?: product_salesWhereInput
    data: XOR<product_salesUpdateWithoutItem_product_salesInput, product_salesUncheckedUpdateWithoutItem_product_salesInput>
  }

  export type product_salesUpdateWithoutItem_product_salesInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    products?: productsUpdateOneRequiredWithoutProduct_salesNestedInput
    sales?: salesUpdateOneRequiredWithoutProduct_salesNestedInput
  }

  export type product_salesUncheckedUpdateWithoutItem_product_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type item_item_product_salesCreateWithoutItemsInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    item_product_sales: item_product_salesCreateNestedOneWithoutItem_item_product_salesInput
    option_groups?: option_groupsCreateNestedOneWithoutItem_item_product_salesInput
  }

  export type item_item_product_salesUncheckedCreateWithoutItemsInput = {
    id?: number
    item_product_sale_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type item_item_product_salesCreateOrConnectWithoutItemsInput = {
    where: item_item_product_salesWhereUniqueInput
    create: XOR<item_item_product_salesCreateWithoutItemsInput, item_item_product_salesUncheckedCreateWithoutItemsInput>
  }

  export type item_item_product_salesCreateManyItemsInputEnvelope = {
    data: item_item_product_salesCreateManyItemsInput | item_item_product_salesCreateManyItemsInput[]
    skipDuplicates?: boolean
  }

  export type item_product_salesCreateWithoutItemsInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItem_product_salesInput
    option_groups?: option_groupsCreateNestedOneWithoutItem_product_salesInput
    product_sales: product_salesCreateNestedOneWithoutItem_product_salesInput
  }

  export type item_product_salesUncheckedCreateWithoutItemsInput = {
    id?: number
    product_sale_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItem_product_salesInput
  }

  export type item_product_salesCreateOrConnectWithoutItemsInput = {
    where: item_product_salesWhereUniqueInput
    create: XOR<item_product_salesCreateWithoutItemsInput, item_product_salesUncheckedCreateWithoutItemsInput>
  }

  export type item_product_salesCreateManyItemsInputEnvelope = {
    data: item_product_salesCreateManyItemsInput | item_product_salesCreateManyItemsInput[]
    skipDuplicates?: boolean
  }

  export type brandsCreateWithoutItemsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    channels?: channelsCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutItemsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutItemsInput, brandsUncheckedCreateWithoutItemsInput>
  }

  export type categoriesCreateWithoutItemsInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brands?: brandsCreateNestedOneWithoutCategoriesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutCategoriesInput
    option_groups?: option_groupsCreateNestedManyWithoutCategoriesInput
    products?: productsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutItemsInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutCategoriesInput
    products?: productsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutItemsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutItemsInput, categoriesUncheckedCreateWithoutItemsInput>
  }

  export type sub_brandsCreateWithoutItemsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutSub_brandsInput
    customers?: customersCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsCreateNestedManyWithoutSub_brandsInput
    products?: productsCreateNestedManyWithoutSub_brandsInput
    sales?: salesCreateNestedManyWithoutSub_brandsInput
    stores?: storesCreateNestedManyWithoutSub_brandsInput
    brands?: brandsCreateNestedOneWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateWithoutItemsInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSub_brandsInput
    customers?: customersUncheckedCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput
    products?: productsUncheckedCreateNestedManyWithoutSub_brandsInput
    sales?: salesUncheckedCreateNestedManyWithoutSub_brandsInput
    stores?: storesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsCreateOrConnectWithoutItemsInput = {
    where: sub_brandsWhereUniqueInput
    create: XOR<sub_brandsCreateWithoutItemsInput, sub_brandsUncheckedCreateWithoutItemsInput>
  }

  export type item_item_product_salesUpsertWithWhereUniqueWithoutItemsInput = {
    where: item_item_product_salesWhereUniqueInput
    update: XOR<item_item_product_salesUpdateWithoutItemsInput, item_item_product_salesUncheckedUpdateWithoutItemsInput>
    create: XOR<item_item_product_salesCreateWithoutItemsInput, item_item_product_salesUncheckedCreateWithoutItemsInput>
  }

  export type item_item_product_salesUpdateWithWhereUniqueWithoutItemsInput = {
    where: item_item_product_salesWhereUniqueInput
    data: XOR<item_item_product_salesUpdateWithoutItemsInput, item_item_product_salesUncheckedUpdateWithoutItemsInput>
  }

  export type item_item_product_salesUpdateManyWithWhereWithoutItemsInput = {
    where: item_item_product_salesScalarWhereInput
    data: XOR<item_item_product_salesUpdateManyMutationInput, item_item_product_salesUncheckedUpdateManyWithoutItemsInput>
  }

  export type item_product_salesUpsertWithWhereUniqueWithoutItemsInput = {
    where: item_product_salesWhereUniqueInput
    update: XOR<item_product_salesUpdateWithoutItemsInput, item_product_salesUncheckedUpdateWithoutItemsInput>
    create: XOR<item_product_salesCreateWithoutItemsInput, item_product_salesUncheckedCreateWithoutItemsInput>
  }

  export type item_product_salesUpdateWithWhereUniqueWithoutItemsInput = {
    where: item_product_salesWhereUniqueInput
    data: XOR<item_product_salesUpdateWithoutItemsInput, item_product_salesUncheckedUpdateWithoutItemsInput>
  }

  export type item_product_salesUpdateManyWithWhereWithoutItemsInput = {
    where: item_product_salesScalarWhereInput
    data: XOR<item_product_salesUpdateManyMutationInput, item_product_salesUncheckedUpdateManyWithoutItemsInput>
  }

  export type item_product_salesScalarWhereInput = {
    AND?: item_product_salesScalarWhereInput | item_product_salesScalarWhereInput[]
    OR?: item_product_salesScalarWhereInput[]
    NOT?: item_product_salesScalarWhereInput | item_product_salesScalarWhereInput[]
    id?: IntFilter<"item_product_sales"> | number
    product_sale_id?: IntFilter<"item_product_sales"> | number
    item_id?: IntFilter<"item_product_sales"> | number
    option_group_id?: IntNullableFilter<"item_product_sales"> | number | null
    quantity?: FloatFilter<"item_product_sales"> | number
    additional_price?: FloatFilter<"item_product_sales"> | number
    price?: FloatFilter<"item_product_sales"> | number
    amount?: FloatNullableFilter<"item_product_sales"> | number | null
    observations?: StringNullableFilter<"item_product_sales"> | string | null
  }

  export type brandsUpsertWithoutItemsInput = {
    update: XOR<brandsUpdateWithoutItemsInput, brandsUncheckedUpdateWithoutItemsInput>
    create: XOR<brandsCreateWithoutItemsInput, brandsUncheckedCreateWithoutItemsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutItemsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutItemsInput, brandsUncheckedUpdateWithoutItemsInput>
  }

  export type brandsUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type categoriesUpsertWithoutItemsInput = {
    update: XOR<categoriesUpdateWithoutItemsInput, categoriesUncheckedUpdateWithoutItemsInput>
    create: XOR<categoriesCreateWithoutItemsInput, categoriesUncheckedCreateWithoutItemsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutItemsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutItemsInput, categoriesUncheckedUpdateWithoutItemsInput>
  }

  export type categoriesUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutCategoriesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutCategoriesNestedInput
    option_groups?: option_groupsUpdateManyWithoutCategoriesNestedInput
    products?: productsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    option_groups?: option_groupsUncheckedUpdateManyWithoutCategoriesNestedInput
    products?: productsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type sub_brandsUpsertWithoutItemsInput = {
    update: XOR<sub_brandsUpdateWithoutItemsInput, sub_brandsUncheckedUpdateWithoutItemsInput>
    create: XOR<sub_brandsCreateWithoutItemsInput, sub_brandsUncheckedCreateWithoutItemsInput>
    where?: sub_brandsWhereInput
  }

  export type sub_brandsUpdateToOneWithWhereWithoutItemsInput = {
    where?: sub_brandsWhereInput
    data: XOR<sub_brandsUpdateWithoutItemsInput, sub_brandsUncheckedUpdateWithoutItemsInput>
  }

  export type sub_brandsUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutSub_brandsNestedInput
    products?: productsUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUpdateManyWithoutSub_brandsNestedInput
    brands?: brandsUpdateOneWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUncheckedUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput
    products?: productsUncheckedUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUncheckedUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type item_item_product_salesCreateWithoutOption_groupsInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    items: itemsCreateNestedOneWithoutItem_item_product_salesInput
    item_product_sales: item_product_salesCreateNestedOneWithoutItem_item_product_salesInput
  }

  export type item_item_product_salesUncheckedCreateWithoutOption_groupsInput = {
    id?: number
    item_product_sale_id: number
    item_id: number
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type item_item_product_salesCreateOrConnectWithoutOption_groupsInput = {
    where: item_item_product_salesWhereUniqueInput
    create: XOR<item_item_product_salesCreateWithoutOption_groupsInput, item_item_product_salesUncheckedCreateWithoutOption_groupsInput>
  }

  export type item_item_product_salesCreateManyOption_groupsInputEnvelope = {
    data: item_item_product_salesCreateManyOption_groupsInput | item_item_product_salesCreateManyOption_groupsInput[]
    skipDuplicates?: boolean
  }

  export type item_product_salesCreateWithoutOption_groupsInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItem_product_salesInput
    items: itemsCreateNestedOneWithoutItem_product_salesInput
    product_sales: product_salesCreateNestedOneWithoutItem_product_salesInput
  }

  export type item_product_salesUncheckedCreateWithoutOption_groupsInput = {
    id?: number
    product_sale_id: number
    item_id: number
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItem_product_salesInput
  }

  export type item_product_salesCreateOrConnectWithoutOption_groupsInput = {
    where: item_product_salesWhereUniqueInput
    create: XOR<item_product_salesCreateWithoutOption_groupsInput, item_product_salesUncheckedCreateWithoutOption_groupsInput>
  }

  export type item_product_salesCreateManyOption_groupsInputEnvelope = {
    data: item_product_salesCreateManyOption_groupsInput | item_product_salesCreateManyOption_groupsInput[]
    skipDuplicates?: boolean
  }

  export type brandsCreateWithoutOption_groupsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    channels?: channelsCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutOption_groupsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutOption_groupsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutOption_groupsInput, brandsUncheckedCreateWithoutOption_groupsInput>
  }

  export type categoriesCreateWithoutOption_groupsInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brands?: brandsCreateNestedOneWithoutCategoriesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutCategoriesInput
    items?: itemsCreateNestedManyWithoutCategoriesInput
    products?: productsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutOption_groupsInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    items?: itemsUncheckedCreateNestedManyWithoutCategoriesInput
    products?: productsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutOption_groupsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutOption_groupsInput, categoriesUncheckedCreateWithoutOption_groupsInput>
  }

  export type sub_brandsCreateWithoutOption_groupsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutSub_brandsInput
    customers?: customersCreateNestedManyWithoutSub_brandsInput
    items?: itemsCreateNestedManyWithoutSub_brandsInput
    products?: productsCreateNestedManyWithoutSub_brandsInput
    sales?: salesCreateNestedManyWithoutSub_brandsInput
    stores?: storesCreateNestedManyWithoutSub_brandsInput
    brands?: brandsCreateNestedOneWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateWithoutOption_groupsInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSub_brandsInput
    customers?: customersUncheckedCreateNestedManyWithoutSub_brandsInput
    items?: itemsUncheckedCreateNestedManyWithoutSub_brandsInput
    products?: productsUncheckedCreateNestedManyWithoutSub_brandsInput
    sales?: salesUncheckedCreateNestedManyWithoutSub_brandsInput
    stores?: storesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsCreateOrConnectWithoutOption_groupsInput = {
    where: sub_brandsWhereUniqueInput
    create: XOR<sub_brandsCreateWithoutOption_groupsInput, sub_brandsUncheckedCreateWithoutOption_groupsInput>
  }

  export type item_item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput = {
    where: item_item_product_salesWhereUniqueInput
    update: XOR<item_item_product_salesUpdateWithoutOption_groupsInput, item_item_product_salesUncheckedUpdateWithoutOption_groupsInput>
    create: XOR<item_item_product_salesCreateWithoutOption_groupsInput, item_item_product_salesUncheckedCreateWithoutOption_groupsInput>
  }

  export type item_item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput = {
    where: item_item_product_salesWhereUniqueInput
    data: XOR<item_item_product_salesUpdateWithoutOption_groupsInput, item_item_product_salesUncheckedUpdateWithoutOption_groupsInput>
  }

  export type item_item_product_salesUpdateManyWithWhereWithoutOption_groupsInput = {
    where: item_item_product_salesScalarWhereInput
    data: XOR<item_item_product_salesUpdateManyMutationInput, item_item_product_salesUncheckedUpdateManyWithoutOption_groupsInput>
  }

  export type item_product_salesUpsertWithWhereUniqueWithoutOption_groupsInput = {
    where: item_product_salesWhereUniqueInput
    update: XOR<item_product_salesUpdateWithoutOption_groupsInput, item_product_salesUncheckedUpdateWithoutOption_groupsInput>
    create: XOR<item_product_salesCreateWithoutOption_groupsInput, item_product_salesUncheckedCreateWithoutOption_groupsInput>
  }

  export type item_product_salesUpdateWithWhereUniqueWithoutOption_groupsInput = {
    where: item_product_salesWhereUniqueInput
    data: XOR<item_product_salesUpdateWithoutOption_groupsInput, item_product_salesUncheckedUpdateWithoutOption_groupsInput>
  }

  export type item_product_salesUpdateManyWithWhereWithoutOption_groupsInput = {
    where: item_product_salesScalarWhereInput
    data: XOR<item_product_salesUpdateManyMutationInput, item_product_salesUncheckedUpdateManyWithoutOption_groupsInput>
  }

  export type brandsUpsertWithoutOption_groupsInput = {
    update: XOR<brandsUpdateWithoutOption_groupsInput, brandsUncheckedUpdateWithoutOption_groupsInput>
    create: XOR<brandsCreateWithoutOption_groupsInput, brandsUncheckedCreateWithoutOption_groupsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutOption_groupsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutOption_groupsInput, brandsUncheckedUpdateWithoutOption_groupsInput>
  }

  export type brandsUpdateWithoutOption_groupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutOption_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type categoriesUpsertWithoutOption_groupsInput = {
    update: XOR<categoriesUpdateWithoutOption_groupsInput, categoriesUncheckedUpdateWithoutOption_groupsInput>
    create: XOR<categoriesCreateWithoutOption_groupsInput, categoriesUncheckedCreateWithoutOption_groupsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutOption_groupsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutOption_groupsInput, categoriesUncheckedUpdateWithoutOption_groupsInput>
  }

  export type categoriesUpdateWithoutOption_groupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutCategoriesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutCategoriesNestedInput
    items?: itemsUpdateManyWithoutCategoriesNestedInput
    products?: productsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutOption_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUncheckedUpdateManyWithoutCategoriesNestedInput
    products?: productsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type sub_brandsUpsertWithoutOption_groupsInput = {
    update: XOR<sub_brandsUpdateWithoutOption_groupsInput, sub_brandsUncheckedUpdateWithoutOption_groupsInput>
    create: XOR<sub_brandsCreateWithoutOption_groupsInput, sub_brandsUncheckedCreateWithoutOption_groupsInput>
    where?: sub_brandsWhereInput
  }

  export type sub_brandsUpdateToOneWithWhereWithoutOption_groupsInput = {
    where?: sub_brandsWhereInput
    data: XOR<sub_brandsUpdateWithoutOption_groupsInput, sub_brandsUncheckedUpdateWithoutOption_groupsInput>
  }

  export type sub_brandsUpdateWithoutOption_groupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUpdateManyWithoutSub_brandsNestedInput
    products?: productsUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUpdateManyWithoutSub_brandsNestedInput
    brands?: brandsUpdateOneWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateWithoutOption_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUncheckedUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutSub_brandsNestedInput
    products?: productsUncheckedUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUncheckedUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type brandsCreateWithoutPayment_typesInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    channels?: channelsCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutPayment_typesInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutPayment_typesInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutPayment_typesInput, brandsUncheckedCreateWithoutPayment_typesInput>
  }

  export type paymentsCreateWithoutPayment_typesInput = {
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
    sales: salesCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutPayment_typesInput = {
    id?: number
    sale_id: number
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentsCreateOrConnectWithoutPayment_typesInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutPayment_typesInput, paymentsUncheckedCreateWithoutPayment_typesInput>
  }

  export type paymentsCreateManyPayment_typesInputEnvelope = {
    data: paymentsCreateManyPayment_typesInput | paymentsCreateManyPayment_typesInput[]
    skipDuplicates?: boolean
  }

  export type brandsUpsertWithoutPayment_typesInput = {
    update: XOR<brandsUpdateWithoutPayment_typesInput, brandsUncheckedUpdateWithoutPayment_typesInput>
    create: XOR<brandsCreateWithoutPayment_typesInput, brandsUncheckedCreateWithoutPayment_typesInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutPayment_typesInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutPayment_typesInput, brandsUncheckedUpdateWithoutPayment_typesInput>
  }

  export type brandsUpdateWithoutPayment_typesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutPayment_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type paymentsUpsertWithWhereUniqueWithoutPayment_typesInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutPayment_typesInput, paymentsUncheckedUpdateWithoutPayment_typesInput>
    create: XOR<paymentsCreateWithoutPayment_typesInput, paymentsUncheckedCreateWithoutPayment_typesInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutPayment_typesInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutPayment_typesInput, paymentsUncheckedUpdateWithoutPayment_typesInput>
  }

  export type paymentsUpdateManyWithWhereWithoutPayment_typesInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutPayment_typesInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: IntFilter<"payments"> | number
    sale_id?: IntFilter<"payments"> | number
    payment_type_id?: IntNullableFilter<"payments"> | number | null
    value?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    is_online?: BoolNullableFilter<"payments"> | boolean | null
    description?: StringNullableFilter<"payments"> | string | null
    currency?: StringNullableFilter<"payments"> | string | null
  }

  export type payment_typesCreateWithoutPaymentsInput = {
    description: string
    brands?: brandsCreateNestedOneWithoutPayment_typesInput
  }

  export type payment_typesUncheckedCreateWithoutPaymentsInput = {
    id?: number
    brand_id?: number | null
    description: string
  }

  export type payment_typesCreateOrConnectWithoutPaymentsInput = {
    where: payment_typesWhereUniqueInput
    create: XOR<payment_typesCreateWithoutPaymentsInput, payment_typesUncheckedCreateWithoutPaymentsInput>
  }

  export type salesCreateWithoutPaymentsInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutPaymentsInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutPaymentsInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutPaymentsInput, salesUncheckedCreateWithoutPaymentsInput>
  }

  export type payment_typesUpsertWithoutPaymentsInput = {
    update: XOR<payment_typesUpdateWithoutPaymentsInput, payment_typesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<payment_typesCreateWithoutPaymentsInput, payment_typesUncheckedCreateWithoutPaymentsInput>
    where?: payment_typesWhereInput
  }

  export type payment_typesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: payment_typesWhereInput
    data: XOR<payment_typesUpdateWithoutPaymentsInput, payment_typesUncheckedUpdateWithoutPaymentsInput>
  }

  export type payment_typesUpdateWithoutPaymentsInput = {
    description?: StringFieldUpdateOperationsInput | string
    brands?: brandsUpdateOneWithoutPayment_typesNestedInput
  }

  export type payment_typesUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type salesUpsertWithoutPaymentsInput = {
    update: XOR<salesUpdateWithoutPaymentsInput, salesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<salesCreateWithoutPaymentsInput, salesUncheckedCreateWithoutPaymentsInput>
    where?: salesWhereInput
  }

  export type salesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: salesWhereInput
    data: XOR<salesUpdateWithoutPaymentsInput, salesUncheckedUpdateWithoutPaymentsInput>
  }

  export type salesUpdateWithoutPaymentsInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type item_product_salesCreateWithoutProduct_salesInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItem_product_salesInput
    items: itemsCreateNestedOneWithoutItem_product_salesInput
    option_groups?: option_groupsCreateNestedOneWithoutItem_product_salesInput
  }

  export type item_product_salesUncheckedCreateWithoutProduct_salesInput = {
    id?: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItem_product_salesInput
  }

  export type item_product_salesCreateOrConnectWithoutProduct_salesInput = {
    where: item_product_salesWhereUniqueInput
    create: XOR<item_product_salesCreateWithoutProduct_salesInput, item_product_salesUncheckedCreateWithoutProduct_salesInput>
  }

  export type item_product_salesCreateManyProduct_salesInputEnvelope = {
    data: item_product_salesCreateManyProduct_salesInput | item_product_salesCreateManyProduct_salesInput[]
    skipDuplicates?: boolean
  }

  export type productsCreateWithoutProduct_salesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brands?: brandsCreateNestedOneWithoutProductsInput
    categories?: categoriesCreateNestedOneWithoutProductsInput
    sub_brands?: sub_brandsCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutProduct_salesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productsCreateOrConnectWithoutProduct_salesInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutProduct_salesInput, productsUncheckedCreateWithoutProduct_salesInput>
  }

  export type salesCreateWithoutProduct_salesInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutProduct_salesInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutProduct_salesInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutProduct_salesInput, salesUncheckedCreateWithoutProduct_salesInput>
  }

  export type item_product_salesUpsertWithWhereUniqueWithoutProduct_salesInput = {
    where: item_product_salesWhereUniqueInput
    update: XOR<item_product_salesUpdateWithoutProduct_salesInput, item_product_salesUncheckedUpdateWithoutProduct_salesInput>
    create: XOR<item_product_salesCreateWithoutProduct_salesInput, item_product_salesUncheckedCreateWithoutProduct_salesInput>
  }

  export type item_product_salesUpdateWithWhereUniqueWithoutProduct_salesInput = {
    where: item_product_salesWhereUniqueInput
    data: XOR<item_product_salesUpdateWithoutProduct_salesInput, item_product_salesUncheckedUpdateWithoutProduct_salesInput>
  }

  export type item_product_salesUpdateManyWithWhereWithoutProduct_salesInput = {
    where: item_product_salesScalarWhereInput
    data: XOR<item_product_salesUpdateManyMutationInput, item_product_salesUncheckedUpdateManyWithoutProduct_salesInput>
  }

  export type productsUpsertWithoutProduct_salesInput = {
    update: XOR<productsUpdateWithoutProduct_salesInput, productsUncheckedUpdateWithoutProduct_salesInput>
    create: XOR<productsCreateWithoutProduct_salesInput, productsUncheckedCreateWithoutProduct_salesInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutProduct_salesInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutProduct_salesInput, productsUncheckedUpdateWithoutProduct_salesInput>
  }

  export type productsUpdateWithoutProduct_salesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutProductsNestedInput
    categories?: categoriesUpdateOneWithoutProductsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutProduct_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salesUpsertWithoutProduct_salesInput = {
    update: XOR<salesUpdateWithoutProduct_salesInput, salesUncheckedUpdateWithoutProduct_salesInput>
    create: XOR<salesCreateWithoutProduct_salesInput, salesUncheckedCreateWithoutProduct_salesInput>
    where?: salesWhereInput
  }

  export type salesUpdateToOneWithWhereWithoutProduct_salesInput = {
    where?: salesWhereInput
    data: XOR<salesUpdateWithoutProduct_salesInput, salesUncheckedUpdateWithoutProduct_salesInput>
  }

  export type salesUpdateWithoutProduct_salesInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutProduct_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type product_salesCreateWithoutProductsInput = {
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    item_product_sales?: item_product_salesCreateNestedManyWithoutProduct_salesInput
    sales: salesCreateNestedOneWithoutProduct_salesInput
  }

  export type product_salesUncheckedCreateWithoutProductsInput = {
    id?: number
    sale_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutProduct_salesInput
  }

  export type product_salesCreateOrConnectWithoutProductsInput = {
    where: product_salesWhereUniqueInput
    create: XOR<product_salesCreateWithoutProductsInput, product_salesUncheckedCreateWithoutProductsInput>
  }

  export type product_salesCreateManyProductsInputEnvelope = {
    data: product_salesCreateManyProductsInput | product_salesCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type brandsCreateWithoutProductsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    channels?: channelsCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutProductsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
  }

  export type categoriesCreateWithoutProductsInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brands?: brandsCreateNestedOneWithoutCategoriesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutCategoriesInput
    items?: itemsCreateNestedManyWithoutCategoriesInput
    option_groups?: option_groupsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutProductsInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    items?: itemsUncheckedCreateNestedManyWithoutCategoriesInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutProductsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutProductsInput, categoriesUncheckedCreateWithoutProductsInput>
  }

  export type sub_brandsCreateWithoutProductsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutSub_brandsInput
    customers?: customersCreateNestedManyWithoutSub_brandsInput
    items?: itemsCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsCreateNestedManyWithoutSub_brandsInput
    sales?: salesCreateNestedManyWithoutSub_brandsInput
    stores?: storesCreateNestedManyWithoutSub_brandsInput
    brands?: brandsCreateNestedOneWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateWithoutProductsInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSub_brandsInput
    customers?: customersUncheckedCreateNestedManyWithoutSub_brandsInput
    items?: itemsUncheckedCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput
    sales?: salesUncheckedCreateNestedManyWithoutSub_brandsInput
    stores?: storesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsCreateOrConnectWithoutProductsInput = {
    where: sub_brandsWhereUniqueInput
    create: XOR<sub_brandsCreateWithoutProductsInput, sub_brandsUncheckedCreateWithoutProductsInput>
  }

  export type product_salesUpsertWithWhereUniqueWithoutProductsInput = {
    where: product_salesWhereUniqueInput
    update: XOR<product_salesUpdateWithoutProductsInput, product_salesUncheckedUpdateWithoutProductsInput>
    create: XOR<product_salesCreateWithoutProductsInput, product_salesUncheckedCreateWithoutProductsInput>
  }

  export type product_salesUpdateWithWhereUniqueWithoutProductsInput = {
    where: product_salesWhereUniqueInput
    data: XOR<product_salesUpdateWithoutProductsInput, product_salesUncheckedUpdateWithoutProductsInput>
  }

  export type product_salesUpdateManyWithWhereWithoutProductsInput = {
    where: product_salesScalarWhereInput
    data: XOR<product_salesUpdateManyMutationInput, product_salesUncheckedUpdateManyWithoutProductsInput>
  }

  export type product_salesScalarWhereInput = {
    AND?: product_salesScalarWhereInput | product_salesScalarWhereInput[]
    OR?: product_salesScalarWhereInput[]
    NOT?: product_salesScalarWhereInput | product_salesScalarWhereInput[]
    id?: IntFilter<"product_sales"> | number
    sale_id?: IntFilter<"product_sales"> | number
    product_id?: IntFilter<"product_sales"> | number
    quantity?: FloatFilter<"product_sales"> | number
    base_price?: FloatFilter<"product_sales"> | number
    total_price?: FloatFilter<"product_sales"> | number
    observations?: StringNullableFilter<"product_sales"> | string | null
  }

  export type brandsUpsertWithoutProductsInput = {
    update: XOR<brandsUpdateWithoutProductsInput, brandsUncheckedUpdateWithoutProductsInput>
    create: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutProductsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutProductsInput, brandsUncheckedUpdateWithoutProductsInput>
  }

  export type brandsUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type categoriesUpsertWithoutProductsInput = {
    update: XOR<categoriesUpdateWithoutProductsInput, categoriesUncheckedUpdateWithoutProductsInput>
    create: XOR<categoriesCreateWithoutProductsInput, categoriesUncheckedCreateWithoutProductsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutProductsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutProductsInput, categoriesUncheckedUpdateWithoutProductsInput>
  }

  export type categoriesUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutCategoriesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutCategoriesNestedInput
    items?: itemsUpdateManyWithoutCategoriesNestedInput
    option_groups?: option_groupsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUncheckedUpdateManyWithoutCategoriesNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type sub_brandsUpsertWithoutProductsInput = {
    update: XOR<sub_brandsUpdateWithoutProductsInput, sub_brandsUncheckedUpdateWithoutProductsInput>
    create: XOR<sub_brandsCreateWithoutProductsInput, sub_brandsUncheckedCreateWithoutProductsInput>
    where?: sub_brandsWhereInput
  }

  export type sub_brandsUpdateToOneWithWhereWithoutProductsInput = {
    where?: sub_brandsWhereInput
    data: XOR<sub_brandsUpdateWithoutProductsInput, sub_brandsUncheckedUpdateWithoutProductsInput>
  }

  export type sub_brandsUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUpdateManyWithoutSub_brandsNestedInput
    brands?: brandsUpdateOneWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUncheckedUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUncheckedUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type coupon_salesCreateWithoutSalesInput = {
    value?: number | null
    target?: string | null
    sponsorship?: string | null
    coupons?: couponsCreateNestedOneWithoutCoupon_salesInput
  }

  export type coupon_salesUncheckedCreateWithoutSalesInput = {
    id?: number
    coupon_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type coupon_salesCreateOrConnectWithoutSalesInput = {
    where: coupon_salesWhereUniqueInput
    create: XOR<coupon_salesCreateWithoutSalesInput, coupon_salesUncheckedCreateWithoutSalesInput>
  }

  export type coupon_salesCreateManySalesInputEnvelope = {
    data: coupon_salesCreateManySalesInput | coupon_salesCreateManySalesInput[]
    skipDuplicates?: boolean
  }

  export type delivery_addressesCreateWithoutSalesInput = {
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
    delivery_sales?: delivery_salesCreateNestedOneWithoutDelivery_addressesInput
  }

  export type delivery_addressesUncheckedCreateWithoutSalesInput = {
    id?: number
    delivery_sale_id?: number | null
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type delivery_addressesCreateOrConnectWithoutSalesInput = {
    where: delivery_addressesWhereUniqueInput
    create: XOR<delivery_addressesCreateWithoutSalesInput, delivery_addressesUncheckedCreateWithoutSalesInput>
  }

  export type delivery_addressesCreateManySalesInputEnvelope = {
    data: delivery_addressesCreateManySalesInput | delivery_addressesCreateManySalesInput[]
    skipDuplicates?: boolean
  }

  export type delivery_salesCreateWithoutSalesInput = {
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutDelivery_salesInput
  }

  export type delivery_salesUncheckedCreateWithoutSalesInput = {
    id?: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutDelivery_salesInput
  }

  export type delivery_salesCreateOrConnectWithoutSalesInput = {
    where: delivery_salesWhereUniqueInput
    create: XOR<delivery_salesCreateWithoutSalesInput, delivery_salesUncheckedCreateWithoutSalesInput>
  }

  export type delivery_salesCreateManySalesInputEnvelope = {
    data: delivery_salesCreateManySalesInput | delivery_salesCreateManySalesInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutSalesInput = {
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
    payment_types?: payment_typesCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutSalesInput = {
    id?: number
    payment_type_id?: number | null
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentsCreateOrConnectWithoutSalesInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutSalesInput, paymentsUncheckedCreateWithoutSalesInput>
  }

  export type paymentsCreateManySalesInputEnvelope = {
    data: paymentsCreateManySalesInput | paymentsCreateManySalesInput[]
    skipDuplicates?: boolean
  }

  export type product_salesCreateWithoutSalesInput = {
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    item_product_sales?: item_product_salesCreateNestedManyWithoutProduct_salesInput
    products: productsCreateNestedOneWithoutProduct_salesInput
  }

  export type product_salesUncheckedCreateWithoutSalesInput = {
    id?: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutProduct_salesInput
  }

  export type product_salesCreateOrConnectWithoutSalesInput = {
    where: product_salesWhereUniqueInput
    create: XOR<product_salesCreateWithoutSalesInput, product_salesUncheckedCreateWithoutSalesInput>
  }

  export type product_salesCreateManySalesInputEnvelope = {
    data: product_salesCreateManySalesInput | product_salesCreateManySalesInput[]
    skipDuplicates?: boolean
  }

  export type channelsCreateWithoutSalesInput = {
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    brands?: brandsCreateNestedOneWithoutChannelsInput
  }

  export type channelsUncheckedCreateWithoutSalesInput = {
    id?: number
    brand_id?: number | null
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type channelsCreateOrConnectWithoutSalesInput = {
    where: channelsWhereUniqueInput
    create: XOR<channelsCreateWithoutSalesInput, channelsUncheckedCreateWithoutSalesInput>
  }

  export type customersCreateWithoutSalesInput = {
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    stores?: storesCreateNestedOneWithoutCustomersInput
    sub_brands?: sub_brandsCreateNestedOneWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutSalesInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
  }

  export type customersCreateOrConnectWithoutSalesInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutSalesInput, customersUncheckedCreateWithoutSalesInput>
  }

  export type storesCreateWithoutSalesInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customersCreateNestedManyWithoutStoresInput
    brands?: brandsCreateNestedOneWithoutStoresInput
    sub_brands?: sub_brandsCreateNestedOneWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutSalesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customersUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutSalesInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutSalesInput, storesUncheckedCreateWithoutSalesInput>
  }

  export type sub_brandsCreateWithoutSalesInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutSub_brandsInput
    customers?: customersCreateNestedManyWithoutSub_brandsInput
    items?: itemsCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsCreateNestedManyWithoutSub_brandsInput
    products?: productsCreateNestedManyWithoutSub_brandsInput
    stores?: storesCreateNestedManyWithoutSub_brandsInput
    brands?: brandsCreateNestedOneWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateWithoutSalesInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSub_brandsInput
    customers?: customersUncheckedCreateNestedManyWithoutSub_brandsInput
    items?: itemsUncheckedCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput
    products?: productsUncheckedCreateNestedManyWithoutSub_brandsInput
    stores?: storesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsCreateOrConnectWithoutSalesInput = {
    where: sub_brandsWhereUniqueInput
    create: XOR<sub_brandsCreateWithoutSalesInput, sub_brandsUncheckedCreateWithoutSalesInput>
  }

  export type coupon_salesUpsertWithWhereUniqueWithoutSalesInput = {
    where: coupon_salesWhereUniqueInput
    update: XOR<coupon_salesUpdateWithoutSalesInput, coupon_salesUncheckedUpdateWithoutSalesInput>
    create: XOR<coupon_salesCreateWithoutSalesInput, coupon_salesUncheckedCreateWithoutSalesInput>
  }

  export type coupon_salesUpdateWithWhereUniqueWithoutSalesInput = {
    where: coupon_salesWhereUniqueInput
    data: XOR<coupon_salesUpdateWithoutSalesInput, coupon_salesUncheckedUpdateWithoutSalesInput>
  }

  export type coupon_salesUpdateManyWithWhereWithoutSalesInput = {
    where: coupon_salesScalarWhereInput
    data: XOR<coupon_salesUpdateManyMutationInput, coupon_salesUncheckedUpdateManyWithoutSalesInput>
  }

  export type delivery_addressesUpsertWithWhereUniqueWithoutSalesInput = {
    where: delivery_addressesWhereUniqueInput
    update: XOR<delivery_addressesUpdateWithoutSalesInput, delivery_addressesUncheckedUpdateWithoutSalesInput>
    create: XOR<delivery_addressesCreateWithoutSalesInput, delivery_addressesUncheckedCreateWithoutSalesInput>
  }

  export type delivery_addressesUpdateWithWhereUniqueWithoutSalesInput = {
    where: delivery_addressesWhereUniqueInput
    data: XOR<delivery_addressesUpdateWithoutSalesInput, delivery_addressesUncheckedUpdateWithoutSalesInput>
  }

  export type delivery_addressesUpdateManyWithWhereWithoutSalesInput = {
    where: delivery_addressesScalarWhereInput
    data: XOR<delivery_addressesUpdateManyMutationInput, delivery_addressesUncheckedUpdateManyWithoutSalesInput>
  }

  export type delivery_salesUpsertWithWhereUniqueWithoutSalesInput = {
    where: delivery_salesWhereUniqueInput
    update: XOR<delivery_salesUpdateWithoutSalesInput, delivery_salesUncheckedUpdateWithoutSalesInput>
    create: XOR<delivery_salesCreateWithoutSalesInput, delivery_salesUncheckedCreateWithoutSalesInput>
  }

  export type delivery_salesUpdateWithWhereUniqueWithoutSalesInput = {
    where: delivery_salesWhereUniqueInput
    data: XOR<delivery_salesUpdateWithoutSalesInput, delivery_salesUncheckedUpdateWithoutSalesInput>
  }

  export type delivery_salesUpdateManyWithWhereWithoutSalesInput = {
    where: delivery_salesScalarWhereInput
    data: XOR<delivery_salesUpdateManyMutationInput, delivery_salesUncheckedUpdateManyWithoutSalesInput>
  }

  export type delivery_salesScalarWhereInput = {
    AND?: delivery_salesScalarWhereInput | delivery_salesScalarWhereInput[]
    OR?: delivery_salesScalarWhereInput[]
    NOT?: delivery_salesScalarWhereInput | delivery_salesScalarWhereInput[]
    id?: IntFilter<"delivery_sales"> | number
    sale_id?: IntFilter<"delivery_sales"> | number
    courier_id?: StringNullableFilter<"delivery_sales"> | string | null
    courier_name?: StringNullableFilter<"delivery_sales"> | string | null
    courier_phone?: StringNullableFilter<"delivery_sales"> | string | null
    courier_type?: StringNullableFilter<"delivery_sales"> | string | null
    delivered_by?: StringNullableFilter<"delivery_sales"> | string | null
    delivery_type?: StringNullableFilter<"delivery_sales"> | string | null
    status?: StringNullableFilter<"delivery_sales"> | string | null
    delivery_fee?: FloatNullableFilter<"delivery_sales"> | number | null
    courier_fee?: FloatNullableFilter<"delivery_sales"> | number | null
    timing?: StringNullableFilter<"delivery_sales"> | string | null
    mode?: StringNullableFilter<"delivery_sales"> | string | null
  }

  export type paymentsUpsertWithWhereUniqueWithoutSalesInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutSalesInput, paymentsUncheckedUpdateWithoutSalesInput>
    create: XOR<paymentsCreateWithoutSalesInput, paymentsUncheckedCreateWithoutSalesInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutSalesInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutSalesInput, paymentsUncheckedUpdateWithoutSalesInput>
  }

  export type paymentsUpdateManyWithWhereWithoutSalesInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutSalesInput>
  }

  export type product_salesUpsertWithWhereUniqueWithoutSalesInput = {
    where: product_salesWhereUniqueInput
    update: XOR<product_salesUpdateWithoutSalesInput, product_salesUncheckedUpdateWithoutSalesInput>
    create: XOR<product_salesCreateWithoutSalesInput, product_salesUncheckedCreateWithoutSalesInput>
  }

  export type product_salesUpdateWithWhereUniqueWithoutSalesInput = {
    where: product_salesWhereUniqueInput
    data: XOR<product_salesUpdateWithoutSalesInput, product_salesUncheckedUpdateWithoutSalesInput>
  }

  export type product_salesUpdateManyWithWhereWithoutSalesInput = {
    where: product_salesScalarWhereInput
    data: XOR<product_salesUpdateManyMutationInput, product_salesUncheckedUpdateManyWithoutSalesInput>
  }

  export type channelsUpsertWithoutSalesInput = {
    update: XOR<channelsUpdateWithoutSalesInput, channelsUncheckedUpdateWithoutSalesInput>
    create: XOR<channelsCreateWithoutSalesInput, channelsUncheckedCreateWithoutSalesInput>
    where?: channelsWhereInput
  }

  export type channelsUpdateToOneWithWhereWithoutSalesInput = {
    where?: channelsWhereInput
    data: XOR<channelsUpdateWithoutSalesInput, channelsUncheckedUpdateWithoutSalesInput>
  }

  export type channelsUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutChannelsNestedInput
  }

  export type channelsUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customersUpsertWithoutSalesInput = {
    update: XOR<customersUpdateWithoutSalesInput, customersUncheckedUpdateWithoutSalesInput>
    create: XOR<customersCreateWithoutSalesInput, customersUncheckedCreateWithoutSalesInput>
    where?: customersWhereInput
  }

  export type customersUpdateToOneWithWhereWithoutSalesInput = {
    where?: customersWhereInput
    data: XOR<customersUpdateWithoutSalesInput, customersUncheckedUpdateWithoutSalesInput>
  }

  export type customersUpdateWithoutSalesInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storesUpdateOneWithoutCustomersNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storesUpsertWithoutSalesInput = {
    update: XOR<storesUpdateWithoutSalesInput, storesUncheckedUpdateWithoutSalesInput>
    create: XOR<storesCreateWithoutSalesInput, storesUncheckedCreateWithoutSalesInput>
    where?: storesWhereInput
  }

  export type storesUpdateToOneWithWhereWithoutSalesInput = {
    where?: storesWhereInput
    data: XOR<storesUpdateWithoutSalesInput, storesUncheckedUpdateWithoutSalesInput>
  }

  export type storesUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUpdateManyWithoutStoresNestedInput
    brands?: brandsUpdateOneWithoutStoresNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type sub_brandsUpsertWithoutSalesInput = {
    update: XOR<sub_brandsUpdateWithoutSalesInput, sub_brandsUncheckedUpdateWithoutSalesInput>
    create: XOR<sub_brandsCreateWithoutSalesInput, sub_brandsUncheckedCreateWithoutSalesInput>
    where?: sub_brandsWhereInput
  }

  export type sub_brandsUpdateToOneWithWhereWithoutSalesInput = {
    where?: sub_brandsWhereInput
    data: XOR<sub_brandsUpdateWithoutSalesInput, sub_brandsUncheckedUpdateWithoutSalesInput>
  }

  export type sub_brandsUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutSub_brandsNestedInput
    products?: productsUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUpdateManyWithoutSub_brandsNestedInput
    brands?: brandsUpdateOneWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUncheckedUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput
    products?: productsUncheckedUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type customersCreateWithoutStoresInput = {
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    sub_brands?: sub_brandsCreateNestedOneWithoutCustomersInput
    sales?: salesCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutStoresInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    sales?: salesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersCreateOrConnectWithoutStoresInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutStoresInput, customersUncheckedCreateWithoutStoresInput>
  }

  export type customersCreateManyStoresInputEnvelope = {
    data: customersCreateManyStoresInput | customersCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type salesCreateWithoutStoresInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    sub_brands?: sub_brandsCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutStoresInput = {
    id?: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutStoresInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutStoresInput, salesUncheckedCreateWithoutStoresInput>
  }

  export type salesCreateManyStoresInputEnvelope = {
    data: salesCreateManyStoresInput | salesCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type brandsCreateWithoutStoresInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    channels?: channelsCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutStoresInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    sub_brands?: sub_brandsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutStoresInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutStoresInput, brandsUncheckedCreateWithoutStoresInput>
  }

  export type sub_brandsCreateWithoutStoresInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutSub_brandsInput
    customers?: customersCreateNestedManyWithoutSub_brandsInput
    items?: itemsCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsCreateNestedManyWithoutSub_brandsInput
    products?: productsCreateNestedManyWithoutSub_brandsInput
    sales?: salesCreateNestedManyWithoutSub_brandsInput
    brands?: brandsCreateNestedOneWithoutSub_brandsInput
  }

  export type sub_brandsUncheckedCreateWithoutStoresInput = {
    id?: number
    brand_id?: number | null
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSub_brandsInput
    customers?: customersUncheckedCreateNestedManyWithoutSub_brandsInput
    items?: itemsUncheckedCreateNestedManyWithoutSub_brandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutSub_brandsInput
    products?: productsUncheckedCreateNestedManyWithoutSub_brandsInput
    sales?: salesUncheckedCreateNestedManyWithoutSub_brandsInput
  }

  export type sub_brandsCreateOrConnectWithoutStoresInput = {
    where: sub_brandsWhereUniqueInput
    create: XOR<sub_brandsCreateWithoutStoresInput, sub_brandsUncheckedCreateWithoutStoresInput>
  }

  export type customersUpsertWithWhereUniqueWithoutStoresInput = {
    where: customersWhereUniqueInput
    update: XOR<customersUpdateWithoutStoresInput, customersUncheckedUpdateWithoutStoresInput>
    create: XOR<customersCreateWithoutStoresInput, customersUncheckedCreateWithoutStoresInput>
  }

  export type customersUpdateWithWhereUniqueWithoutStoresInput = {
    where: customersWhereUniqueInput
    data: XOR<customersUpdateWithoutStoresInput, customersUncheckedUpdateWithoutStoresInput>
  }

  export type customersUpdateManyWithWhereWithoutStoresInput = {
    where: customersScalarWhereInput
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyWithoutStoresInput>
  }

  export type customersScalarWhereInput = {
    AND?: customersScalarWhereInput | customersScalarWhereInput[]
    OR?: customersScalarWhereInput[]
    NOT?: customersScalarWhereInput | customersScalarWhereInput[]
    id?: IntFilter<"customers"> | number
    customer_name?: StringNullableFilter<"customers"> | string | null
    email?: StringNullableFilter<"customers"> | string | null
    phone_number?: StringNullableFilter<"customers"> | string | null
    cpf?: StringNullableFilter<"customers"> | string | null
    birth_date?: DateTimeNullableFilter<"customers"> | Date | string | null
    gender?: StringNullableFilter<"customers"> | string | null
    store_id?: IntNullableFilter<"customers"> | number | null
    sub_brand_id?: IntNullableFilter<"customers"> | number | null
    registration_origin?: StringNullableFilter<"customers"> | string | null
    agree_terms?: BoolNullableFilter<"customers"> | boolean | null
    receive_promotions_email?: BoolNullableFilter<"customers"> | boolean | null
    receive_promotions_sms?: BoolNullableFilter<"customers"> | boolean | null
    created_at?: DateTimeNullableFilter<"customers"> | Date | string | null
  }

  export type salesUpsertWithWhereUniqueWithoutStoresInput = {
    where: salesWhereUniqueInput
    update: XOR<salesUpdateWithoutStoresInput, salesUncheckedUpdateWithoutStoresInput>
    create: XOR<salesCreateWithoutStoresInput, salesUncheckedCreateWithoutStoresInput>
  }

  export type salesUpdateWithWhereUniqueWithoutStoresInput = {
    where: salesWhereUniqueInput
    data: XOR<salesUpdateWithoutStoresInput, salesUncheckedUpdateWithoutStoresInput>
  }

  export type salesUpdateManyWithWhereWithoutStoresInput = {
    where: salesScalarWhereInput
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyWithoutStoresInput>
  }

  export type brandsUpsertWithoutStoresInput = {
    update: XOR<brandsUpdateWithoutStoresInput, brandsUncheckedUpdateWithoutStoresInput>
    create: XOR<brandsCreateWithoutStoresInput, brandsUncheckedCreateWithoutStoresInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutStoresInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutStoresInput, brandsUncheckedUpdateWithoutStoresInput>
  }

  export type brandsUpdateWithoutStoresInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    sub_brands?: sub_brandsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type sub_brandsUpsertWithoutStoresInput = {
    update: XOR<sub_brandsUpdateWithoutStoresInput, sub_brandsUncheckedUpdateWithoutStoresInput>
    create: XOR<sub_brandsCreateWithoutStoresInput, sub_brandsUncheckedCreateWithoutStoresInput>
    where?: sub_brandsWhereInput
  }

  export type sub_brandsUpdateToOneWithWhereWithoutStoresInput = {
    where?: sub_brandsWhereInput
    data: XOR<sub_brandsUpdateWithoutStoresInput, sub_brandsUncheckedUpdateWithoutStoresInput>
  }

  export type sub_brandsUpdateWithoutStoresInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutSub_brandsNestedInput
    products?: productsUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUpdateManyWithoutSub_brandsNestedInput
    brands?: brandsUpdateOneWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUncheckedUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput
    products?: productsUncheckedUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type categoriesCreateWithoutSub_brandsInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brands?: brandsCreateNestedOneWithoutCategoriesInput
    items?: itemsCreateNestedManyWithoutCategoriesInput
    option_groups?: option_groupsCreateNestedManyWithoutCategoriesInput
    products?: productsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutSub_brandsInput = {
    id?: number
    brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    items?: itemsUncheckedCreateNestedManyWithoutCategoriesInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutCategoriesInput
    products?: productsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutSub_brandsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutSub_brandsInput, categoriesUncheckedCreateWithoutSub_brandsInput>
  }

  export type categoriesCreateManySub_brandsInputEnvelope = {
    data: categoriesCreateManySub_brandsInput | categoriesCreateManySub_brandsInput[]
    skipDuplicates?: boolean
  }

  export type customersCreateWithoutSub_brandsInput = {
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    stores?: storesCreateNestedOneWithoutCustomersInput
    sales?: salesCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutSub_brandsInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    sales?: salesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersCreateOrConnectWithoutSub_brandsInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutSub_brandsInput, customersUncheckedCreateWithoutSub_brandsInput>
  }

  export type customersCreateManySub_brandsInputEnvelope = {
    data: customersCreateManySub_brandsInput | customersCreateManySub_brandsInput[]
    skipDuplicates?: boolean
  }

  export type itemsCreateWithoutSub_brandsInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutItemsInput
    item_product_sales?: item_product_salesCreateNestedManyWithoutItemsInput
    brands?: brandsCreateNestedOneWithoutItemsInput
    categories?: categoriesCreateNestedOneWithoutItemsInput
  }

  export type itemsUncheckedCreateWithoutSub_brandsInput = {
    id?: number
    brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutItemsInput
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutItemsInput
  }

  export type itemsCreateOrConnectWithoutSub_brandsInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutSub_brandsInput, itemsUncheckedCreateWithoutSub_brandsInput>
  }

  export type itemsCreateManySub_brandsInputEnvelope = {
    data: itemsCreateManySub_brandsInput | itemsCreateManySub_brandsInput[]
    skipDuplicates?: boolean
  }

  export type option_groupsCreateWithoutSub_brandsInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesCreateNestedManyWithoutOption_groupsInput
    item_product_sales?: item_product_salesCreateNestedManyWithoutOption_groupsInput
    brands?: brandsCreateNestedOneWithoutOption_groupsInput
    categories?: categoriesCreateNestedOneWithoutOption_groupsInput
  }

  export type option_groupsUncheckedCreateWithoutSub_brandsInput = {
    id?: number
    brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
    item_product_sales?: item_product_salesUncheckedCreateNestedManyWithoutOption_groupsInput
  }

  export type option_groupsCreateOrConnectWithoutSub_brandsInput = {
    where: option_groupsWhereUniqueInput
    create: XOR<option_groupsCreateWithoutSub_brandsInput, option_groupsUncheckedCreateWithoutSub_brandsInput>
  }

  export type option_groupsCreateManySub_brandsInputEnvelope = {
    data: option_groupsCreateManySub_brandsInput | option_groupsCreateManySub_brandsInput[]
    skipDuplicates?: boolean
  }

  export type productsCreateWithoutSub_brandsInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    product_sales?: product_salesCreateNestedManyWithoutProductsInput
    brands?: brandsCreateNestedOneWithoutProductsInput
    categories?: categoriesCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutSub_brandsInput = {
    id?: number
    brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    product_sales?: product_salesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutSub_brandsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutSub_brandsInput, productsUncheckedCreateWithoutSub_brandsInput>
  }

  export type productsCreateManySub_brandsInputEnvelope = {
    data: productsCreateManySub_brandsInput | productsCreateManySub_brandsInput[]
    skipDuplicates?: boolean
  }

  export type salesCreateWithoutSub_brandsInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesCreateNestedManyWithoutSalesInput
    payments?: paymentsCreateNestedManyWithoutSalesInput
    product_sales?: product_salesCreateNestedManyWithoutSalesInput
    channels: channelsCreateNestedOneWithoutSalesInput
    customers?: customersCreateNestedOneWithoutSalesInput
    stores: storesCreateNestedOneWithoutSalesInput
  }

  export type salesUncheckedCreateWithoutSub_brandsInput = {
    id?: number
    store_id: number
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    coupon_sales?: coupon_salesUncheckedCreateNestedManyWithoutSalesInput
    delivery_addresses?: delivery_addressesUncheckedCreateNestedManyWithoutSalesInput
    delivery_sales?: delivery_salesUncheckedCreateNestedManyWithoutSalesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutSalesInput
    product_sales?: product_salesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type salesCreateOrConnectWithoutSub_brandsInput = {
    where: salesWhereUniqueInput
    create: XOR<salesCreateWithoutSub_brandsInput, salesUncheckedCreateWithoutSub_brandsInput>
  }

  export type salesCreateManySub_brandsInputEnvelope = {
    data: salesCreateManySub_brandsInput | salesCreateManySub_brandsInput[]
    skipDuplicates?: boolean
  }

  export type storesCreateWithoutSub_brandsInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customersCreateNestedManyWithoutStoresInput
    sales?: salesCreateNestedManyWithoutStoresInput
    brands?: brandsCreateNestedOneWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutSub_brandsInput = {
    id?: number
    brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customersUncheckedCreateNestedManyWithoutStoresInput
    sales?: salesUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutSub_brandsInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutSub_brandsInput, storesUncheckedCreateWithoutSub_brandsInput>
  }

  export type storesCreateManySub_brandsInputEnvelope = {
    data: storesCreateManySub_brandsInput | storesCreateManySub_brandsInput[]
    skipDuplicates?: boolean
  }

  export type brandsCreateWithoutSub_brandsInput = {
    name: string
    created_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutBrandsInput
    channels?: channelsCreateNestedManyWithoutBrandsInput
    coupons?: couponsCreateNestedManyWithoutBrandsInput
    items?: itemsCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesCreateNestedManyWithoutBrandsInput
    products?: productsCreateNestedManyWithoutBrandsInput
    stores?: storesCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutSub_brandsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutBrandsInput
    channels?: channelsUncheckedCreateNestedManyWithoutBrandsInput
    coupons?: couponsUncheckedCreateNestedManyWithoutBrandsInput
    items?: itemsUncheckedCreateNestedManyWithoutBrandsInput
    option_groups?: option_groupsUncheckedCreateNestedManyWithoutBrandsInput
    payment_types?: payment_typesUncheckedCreateNestedManyWithoutBrandsInput
    products?: productsUncheckedCreateNestedManyWithoutBrandsInput
    stores?: storesUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutSub_brandsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutSub_brandsInput, brandsUncheckedCreateWithoutSub_brandsInput>
  }

  export type categoriesUpsertWithWhereUniqueWithoutSub_brandsInput = {
    where: categoriesWhereUniqueInput
    update: XOR<categoriesUpdateWithoutSub_brandsInput, categoriesUncheckedUpdateWithoutSub_brandsInput>
    create: XOR<categoriesCreateWithoutSub_brandsInput, categoriesUncheckedCreateWithoutSub_brandsInput>
  }

  export type categoriesUpdateWithWhereUniqueWithoutSub_brandsInput = {
    where: categoriesWhereUniqueInput
    data: XOR<categoriesUpdateWithoutSub_brandsInput, categoriesUncheckedUpdateWithoutSub_brandsInput>
  }

  export type categoriesUpdateManyWithWhereWithoutSub_brandsInput = {
    where: categoriesScalarWhereInput
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyWithoutSub_brandsInput>
  }

  export type customersUpsertWithWhereUniqueWithoutSub_brandsInput = {
    where: customersWhereUniqueInput
    update: XOR<customersUpdateWithoutSub_brandsInput, customersUncheckedUpdateWithoutSub_brandsInput>
    create: XOR<customersCreateWithoutSub_brandsInput, customersUncheckedCreateWithoutSub_brandsInput>
  }

  export type customersUpdateWithWhereUniqueWithoutSub_brandsInput = {
    where: customersWhereUniqueInput
    data: XOR<customersUpdateWithoutSub_brandsInput, customersUncheckedUpdateWithoutSub_brandsInput>
  }

  export type customersUpdateManyWithWhereWithoutSub_brandsInput = {
    where: customersScalarWhereInput
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyWithoutSub_brandsInput>
  }

  export type itemsUpsertWithWhereUniqueWithoutSub_brandsInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutSub_brandsInput, itemsUncheckedUpdateWithoutSub_brandsInput>
    create: XOR<itemsCreateWithoutSub_brandsInput, itemsUncheckedCreateWithoutSub_brandsInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutSub_brandsInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutSub_brandsInput, itemsUncheckedUpdateWithoutSub_brandsInput>
  }

  export type itemsUpdateManyWithWhereWithoutSub_brandsInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutSub_brandsInput>
  }

  export type option_groupsUpsertWithWhereUniqueWithoutSub_brandsInput = {
    where: option_groupsWhereUniqueInput
    update: XOR<option_groupsUpdateWithoutSub_brandsInput, option_groupsUncheckedUpdateWithoutSub_brandsInput>
    create: XOR<option_groupsCreateWithoutSub_brandsInput, option_groupsUncheckedCreateWithoutSub_brandsInput>
  }

  export type option_groupsUpdateWithWhereUniqueWithoutSub_brandsInput = {
    where: option_groupsWhereUniqueInput
    data: XOR<option_groupsUpdateWithoutSub_brandsInput, option_groupsUncheckedUpdateWithoutSub_brandsInput>
  }

  export type option_groupsUpdateManyWithWhereWithoutSub_brandsInput = {
    where: option_groupsScalarWhereInput
    data: XOR<option_groupsUpdateManyMutationInput, option_groupsUncheckedUpdateManyWithoutSub_brandsInput>
  }

  export type productsUpsertWithWhereUniqueWithoutSub_brandsInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutSub_brandsInput, productsUncheckedUpdateWithoutSub_brandsInput>
    create: XOR<productsCreateWithoutSub_brandsInput, productsUncheckedCreateWithoutSub_brandsInput>
  }

  export type productsUpdateWithWhereUniqueWithoutSub_brandsInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutSub_brandsInput, productsUncheckedUpdateWithoutSub_brandsInput>
  }

  export type productsUpdateManyWithWhereWithoutSub_brandsInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutSub_brandsInput>
  }

  export type salesUpsertWithWhereUniqueWithoutSub_brandsInput = {
    where: salesWhereUniqueInput
    update: XOR<salesUpdateWithoutSub_brandsInput, salesUncheckedUpdateWithoutSub_brandsInput>
    create: XOR<salesCreateWithoutSub_brandsInput, salesUncheckedCreateWithoutSub_brandsInput>
  }

  export type salesUpdateWithWhereUniqueWithoutSub_brandsInput = {
    where: salesWhereUniqueInput
    data: XOR<salesUpdateWithoutSub_brandsInput, salesUncheckedUpdateWithoutSub_brandsInput>
  }

  export type salesUpdateManyWithWhereWithoutSub_brandsInput = {
    where: salesScalarWhereInput
    data: XOR<salesUpdateManyMutationInput, salesUncheckedUpdateManyWithoutSub_brandsInput>
  }

  export type storesUpsertWithWhereUniqueWithoutSub_brandsInput = {
    where: storesWhereUniqueInput
    update: XOR<storesUpdateWithoutSub_brandsInput, storesUncheckedUpdateWithoutSub_brandsInput>
    create: XOR<storesCreateWithoutSub_brandsInput, storesUncheckedCreateWithoutSub_brandsInput>
  }

  export type storesUpdateWithWhereUniqueWithoutSub_brandsInput = {
    where: storesWhereUniqueInput
    data: XOR<storesUpdateWithoutSub_brandsInput, storesUncheckedUpdateWithoutSub_brandsInput>
  }

  export type storesUpdateManyWithWhereWithoutSub_brandsInput = {
    where: storesScalarWhereInput
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyWithoutSub_brandsInput>
  }

  export type brandsUpsertWithoutSub_brandsInput = {
    update: XOR<brandsUpdateWithoutSub_brandsInput, brandsUncheckedUpdateWithoutSub_brandsInput>
    create: XOR<brandsCreateWithoutSub_brandsInput, brandsUncheckedCreateWithoutSub_brandsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutSub_brandsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutSub_brandsInput, brandsUncheckedUpdateWithoutSub_brandsInput>
  }

  export type brandsUpdateWithoutSub_brandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutBrandsNestedInput
    channels?: channelsUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUpdateManyWithoutBrandsNestedInput
    items?: itemsUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUpdateManyWithoutBrandsNestedInput
    products?: productsUpdateManyWithoutBrandsNestedInput
    stores?: storesUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutBrandsNestedInput
    channels?: channelsUncheckedUpdateManyWithoutBrandsNestedInput
    coupons?: couponsUncheckedUpdateManyWithoutBrandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutBrandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutBrandsNestedInput
    payment_types?: payment_typesUncheckedUpdateManyWithoutBrandsNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type categoriesCreateManyBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type channelsCreateManyBrandsInput = {
    id?: number
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type couponsCreateManyBrandsInput = {
    id?: number
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
  }

  export type itemsCreateManyBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type option_groupsCreateManyBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type payment_typesCreateManyBrandsInput = {
    id?: number
    description: string
  }

  export type productsCreateManyBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type storesCreateManyBrandsInput = {
    id?: number
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type sub_brandsCreateManyBrandsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
  }

  export type categoriesUpdateWithoutBrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_brands?: sub_brandsUpdateOneWithoutCategoriesNestedInput
    items?: itemsUpdateManyWithoutCategoriesNestedInput
    option_groups?: option_groupsUpdateManyWithoutCategoriesNestedInput
    products?: productsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUncheckedUpdateManyWithoutCategoriesNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutCategoriesNestedInput
    products?: productsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type channelsUpdateWithoutBrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: salesUpdateManyWithoutChannelsNestedInput
  }

  export type channelsUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: salesUncheckedUpdateManyWithoutChannelsNestedInput
  }

  export type channelsUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsUpdateWithoutBrandsInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutCouponsNestedInput
  }

  export type couponsUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutCouponsNestedInput
  }

  export type couponsUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsUpdateWithoutBrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItemsNestedInput
    item_product_sales?: item_product_salesUpdateManyWithoutItemsNestedInput
    categories?: categoriesUpdateOneWithoutItemsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type option_groupsUpdateWithoutBrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutOption_groupsNestedInput
    item_product_sales?: item_product_salesUpdateManyWithoutOption_groupsNestedInput
    categories?: categoriesUpdateOneWithoutOption_groupsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_typesUpdateWithoutBrandsInput = {
    description?: StringFieldUpdateOperationsInput | string
    payments?: paymentsUpdateManyWithoutPayment_typesNestedInput
  }

  export type payment_typesUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    payments?: paymentsUncheckedUpdateManyWithoutPayment_typesNestedInput
  }

  export type payment_typesUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type productsUpdateWithoutBrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_sales?: product_salesUpdateManyWithoutProductsNestedInput
    categories?: categoriesUpdateOneWithoutProductsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_sales?: product_salesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storesUpdateWithoutBrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUpdateManyWithoutStoresNestedInput
    sales?: salesUpdateManyWithoutStoresNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUncheckedUpdateManyWithoutStoresNestedInput
    sales?: salesUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_brandsUpdateWithoutBrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUpdateManyWithoutSub_brandsNestedInput
    products?: productsUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUpdateManyWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSub_brandsNestedInput
    customers?: customersUncheckedUpdateManyWithoutSub_brandsNestedInput
    items?: itemsUncheckedUpdateManyWithoutSub_brandsNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutSub_brandsNestedInput
    products?: productsUncheckedUpdateManyWithoutSub_brandsNestedInput
    sales?: salesUncheckedUpdateManyWithoutSub_brandsNestedInput
    stores?: storesUncheckedUpdateManyWithoutSub_brandsNestedInput
  }

  export type sub_brandsUncheckedUpdateManyWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsCreateManyCategoriesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type option_groupsCreateManyCategoriesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productsCreateManyCategoriesInput = {
    id?: number
    brand_id?: number | null
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type itemsUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItemsNestedInput
    item_product_sales?: item_product_salesUpdateManyWithoutItemsNestedInput
    brands?: brandsUpdateOneWithoutItemsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type option_groupsUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutOption_groupsNestedInput
    item_product_sales?: item_product_salesUpdateManyWithoutOption_groupsNestedInput
    brands?: brandsUpdateOneWithoutOption_groupsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productsUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_sales?: product_salesUpdateManyWithoutProductsNestedInput
    brands?: brandsUpdateOneWithoutProductsNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_sales?: product_salesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salesCreateManyChannelsInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type salesUpdateWithoutChannelsInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateManyWithoutChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coupon_salesCreateManyCouponsInput = {
    id?: number
    sale_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type coupon_salesUpdateWithoutCouponsInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: salesUpdateOneWithoutCoupon_salesNestedInput
  }

  export type coupon_salesUncheckedUpdateWithoutCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coupon_salesUncheckedUpdateManyWithoutCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type salesCreateManyCustomersInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type salesUpdateWithoutCustomersInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type delivery_addressesCreateManyDelivery_salesInput = {
    id?: number
    sale_id: number
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type delivery_addressesUpdateWithoutDelivery_salesInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sales?: salesUpdateOneRequiredWithoutDelivery_addressesNestedInput
  }

  export type delivery_addressesUncheckedUpdateWithoutDelivery_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type delivery_addressesUncheckedUpdateManyWithoutDelivery_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_item_product_salesCreateManyItem_product_salesInput = {
    id?: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type item_item_product_salesUpdateWithoutItem_product_salesInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    items?: itemsUpdateOneRequiredWithoutItem_item_product_salesNestedInput
    option_groups?: option_groupsUpdateOneWithoutItem_item_product_salesNestedInput
  }

  export type item_item_product_salesUncheckedUpdateWithoutItem_product_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_item_product_salesUncheckedUpdateManyWithoutItem_product_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_item_product_salesCreateManyItemsInput = {
    id?: number
    item_product_sale_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type item_product_salesCreateManyItemsInput = {
    id?: number
    product_sale_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type item_item_product_salesUpdateWithoutItemsInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    item_product_sales?: item_product_salesUpdateOneRequiredWithoutItem_item_product_salesNestedInput
    option_groups?: option_groupsUpdateOneWithoutItem_item_product_salesNestedInput
  }

  export type item_item_product_salesUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_item_product_salesUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_product_salesUpdateWithoutItemsInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItem_product_salesNestedInput
    option_groups?: option_groupsUpdateOneWithoutItem_product_salesNestedInput
    product_sales?: product_salesUpdateOneRequiredWithoutItem_product_salesNestedInput
  }

  export type item_product_salesUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItem_product_salesNestedInput
  }

  export type item_product_salesUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type item_item_product_salesCreateManyOption_groupsInput = {
    id?: number
    item_product_sale_id: number
    item_id: number
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type item_product_salesCreateManyOption_groupsInput = {
    id?: number
    product_sale_id: number
    item_id: number
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type item_item_product_salesUpdateWithoutOption_groupsInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    items?: itemsUpdateOneRequiredWithoutItem_item_product_salesNestedInput
    item_product_sales?: item_product_salesUpdateOneRequiredWithoutItem_item_product_salesNestedInput
  }

  export type item_item_product_salesUncheckedUpdateWithoutOption_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_item_product_salesUncheckedUpdateManyWithoutOption_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type item_product_salesUpdateWithoutOption_groupsInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItem_product_salesNestedInput
    items?: itemsUpdateOneRequiredWithoutItem_product_salesNestedInput
    product_sales?: product_salesUpdateOneRequiredWithoutItem_product_salesNestedInput
  }

  export type item_product_salesUncheckedUpdateWithoutOption_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItem_product_salesNestedInput
  }

  export type item_product_salesUncheckedUpdateManyWithoutOption_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsCreateManyPayment_typesInput = {
    id?: number
    sale_id: number
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentsUpdateWithoutPayment_typesInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: salesUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutPayment_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutPayment_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type item_product_salesCreateManyProduct_salesInput = {
    id?: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type item_product_salesUpdateWithoutProduct_salesInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItem_product_salesNestedInput
    items?: itemsUpdateOneRequiredWithoutItem_product_salesNestedInput
    option_groups?: option_groupsUpdateOneWithoutItem_product_salesNestedInput
  }

  export type item_product_salesUncheckedUpdateWithoutProduct_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItem_product_salesNestedInput
  }

  export type item_product_salesUncheckedUpdateManyWithoutProduct_salesInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type product_salesCreateManyProductsInput = {
    id?: number
    sale_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
  }

  export type product_salesUpdateWithoutProductsInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_product_sales?: item_product_salesUpdateManyWithoutProduct_salesNestedInput
    sales?: salesUpdateOneRequiredWithoutProduct_salesNestedInput
  }

  export type product_salesUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutProduct_salesNestedInput
  }

  export type product_salesUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coupon_salesCreateManySalesInput = {
    id?: number
    coupon_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type delivery_addressesCreateManySalesInput = {
    id?: number
    delivery_sale_id?: number | null
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type delivery_salesCreateManySalesInput = {
    id?: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
  }

  export type paymentsCreateManySalesInput = {
    id?: number
    payment_type_id?: number | null
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type product_salesCreateManySalesInput = {
    id?: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
  }

  export type coupon_salesUpdateWithoutSalesInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
    coupons?: couponsUpdateOneWithoutCoupon_salesNestedInput
  }

  export type coupon_salesUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coupon_salesUncheckedUpdateManyWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type delivery_addressesUpdateWithoutSalesInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_sales?: delivery_salesUpdateOneWithoutDelivery_addressesNestedInput
  }

  export type delivery_addressesUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type delivery_addressesUncheckedUpdateManyWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type delivery_salesUpdateWithoutSalesInput = {
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_addresses?: delivery_addressesUpdateManyWithoutDelivery_salesNestedInput
  }

  export type delivery_salesUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutDelivery_salesNestedInput
  }

  export type delivery_salesUncheckedUpdateManyWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUpdateWithoutSalesInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_types?: payment_typesUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type product_salesUpdateWithoutSalesInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_product_sales?: item_product_salesUpdateManyWithoutProduct_salesNestedInput
    products?: productsUpdateOneRequiredWithoutProduct_salesNestedInput
  }

  export type product_salesUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutProduct_salesNestedInput
  }

  export type product_salesUncheckedUpdateManyWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customersCreateManyStoresInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
  }

  export type salesCreateManyStoresInput = {
    id?: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type customersUpdateWithoutStoresInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_brands?: sub_brandsUpdateOneWithoutCustomersNestedInput
    sales?: salesUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: salesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salesUpdateWithoutStoresInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    sub_brands?: sub_brandsUpdateOneWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriesCreateManySub_brandsInput = {
    id?: number
    brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type customersCreateManySub_brandsInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
  }

  export type itemsCreateManySub_brandsInput = {
    id?: number
    brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type option_groupsCreateManySub_brandsInput = {
    id?: number
    brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productsCreateManySub_brandsInput = {
    id?: number
    brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type salesCreateManySub_brandsInput = {
    id?: number
    store_id: number
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type storesCreateManySub_brandsInput = {
    id?: number
    brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type categoriesUpdateWithoutSub_brandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: brandsUpdateOneWithoutCategoriesNestedInput
    items?: itemsUpdateManyWithoutCategoriesNestedInput
    option_groups?: option_groupsUpdateManyWithoutCategoriesNestedInput
    products?: productsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: itemsUncheckedUpdateManyWithoutCategoriesNestedInput
    option_groups?: option_groupsUncheckedUpdateManyWithoutCategoriesNestedInput
    products?: productsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateManyWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customersUpdateWithoutSub_brandsInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storesUpdateOneWithoutCustomersNestedInput
    sales?: salesUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: salesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateManyWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemsUpdateWithoutSub_brandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutItemsNestedInput
    item_product_sales?: item_product_salesUpdateManyWithoutItemsNestedInput
    brands?: brandsUpdateOneWithoutItemsNestedInput
    categories?: categoriesUpdateOneWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type itemsUncheckedUpdateManyWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type option_groupsUpdateWithoutSub_brandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUpdateManyWithoutOption_groupsNestedInput
    item_product_sales?: item_product_salesUpdateManyWithoutOption_groupsNestedInput
    brands?: brandsUpdateOneWithoutOption_groupsNestedInput
    categories?: categoriesUpdateOneWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item_item_product_sales?: item_item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
    item_product_sales?: item_product_salesUncheckedUpdateManyWithoutOption_groupsNestedInput
  }

  export type option_groupsUncheckedUpdateManyWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productsUpdateWithoutSub_brandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_sales?: product_salesUpdateManyWithoutProductsNestedInput
    brands?: brandsUpdateOneWithoutProductsNestedInput
    categories?: categoriesUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_sales?: product_salesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateManyWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salesUpdateWithoutSub_brandsInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUpdateManyWithoutSalesNestedInput
    payments?: paymentsUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUpdateManyWithoutSalesNestedInput
    channels?: channelsUpdateOneRequiredWithoutSalesNestedInput
    customers?: customersUpdateOneWithoutSalesNestedInput
    stores?: storesUpdateOneRequiredWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_sales?: coupon_salesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_addresses?: delivery_addressesUncheckedUpdateManyWithoutSalesNestedInput
    delivery_sales?: delivery_salesUncheckedUpdateManyWithoutSalesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutSalesNestedInput
    product_sales?: product_salesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type salesUncheckedUpdateManyWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storesUpdateWithoutSub_brandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUpdateManyWithoutStoresNestedInput
    sales?: salesUpdateManyWithoutStoresNestedInput
    brands?: brandsUpdateOneWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customersUncheckedUpdateManyWithoutStoresNestedInput
    sales?: salesUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateManyWithoutSub_brandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}